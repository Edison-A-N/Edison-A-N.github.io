<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Edison</title>
  
  
  <link href="https://edison-a-n.github.io/atom.xml" rel="self"/>
  
  <link href="https://edison-a-n.github.io/"/>
  <updated>2025-10-28T08:36:13.429Z</updated>
  <id>https://edison-a-n.github.io/</id>
  
  <author>
    <name>Edison</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Tool Args Documentation Format Comparison Analysis</title>
    <link href="https://edison-a-n.github.io/2025/10/28/args_doc_format_comparison/"/>
    <id>https://edison-a-n.github.io/2025/10/28/args_doc_format_comparison/</id>
    <published>2025-10-27T16:00:00.000Z</published>
    <updated>2025-10-28T08:36:13.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tool-Args-Documentation-Format-Comparison-Analysis"><a href="#Tool-Args-Documentation-Format-Comparison-Analysis" class="headerlink" title="Tool Args Documentation Format Comparison Analysis"></a>Tool Args Documentation Format Comparison Analysis</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文档对比分析了 <a href="https://github.com/huggingface/smolagents">smolagents</a> 项目中两种不同的 <code>to_code_prompt</code> 方法中 <code>args_doc</code> 组织形式的优劣势。这两种格式分别实现在以下分支中：</p><ul><li><strong>Indent 格式</strong>: <a href="https://github.com/Edison-A-N/smolagents/tree/feature/nested-args-formatting">feature&#x2F;nested-args-formatting</a></li><li><strong>JSON 格式</strong>: <a href="https://github.com/Edison-A-N/smolagents/tree/feature/json-input-schema-formatting">feature&#x2F;json-input-schema-formatting</a></li></ul><h2 id="两种格式对比"><a href="#两种格式对比" class="headerlink" title="两种格式对比"></a>两种格式对比</h2><h3 id="1-Indent-格式-feature-x2F-nested-args-formatting"><a href="#1-Indent-格式-feature-x2F-nested-args-formatting" class="headerlink" title="1. Indent 格式 (feature&#x2F;nested-args-formatting)"></a>1. Indent 格式 (<a href="https://github.com/Edison-A-N/smolagents/tree/feature/nested-args-formatting">feature&#x2F;nested-args-formatting</a>)</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>使用递归函数 <code>format_nested_args</code> 格式化嵌套参数</li><li>采用缩进层级显示参数结构</li><li><strong>智能深度限制</strong>：最大深度固定为 3 层，这是经过深思熟虑的设计决策</li><li>简洁的描述性文本格式</li></ul><p><strong>深度限制的设计理念</strong>：</p><ul><li><strong>LLM 理解优化</strong>：超过 3 层的嵌套结构会使 LLM 难以理解和准确配置参数</li><li><strong>实用性平衡</strong>：3 层深度已覆盖绝大多数实际使用场景</li><li><strong>性能考虑</strong>：避免过深的嵌套导致信息过载，影响 LLM 的决策质量</li><li><strong>可扩展性</strong>：如需要更深嵌套，可在未来版本中讨论和改进</li></ul><h4 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_items_v1_item_search</span>(<span class="params">page: integer, page_size: integer, <span class="built_in">filter</span>: <span class="built_in">object</span>, sort: array</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Search items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Important: This tool returns structured output! Use the JSON schema below to directly access fields like result[&#x27;field_name&#x27;]. NO print() statements needed to inspect the output!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        page: Page number</span></span><br><span class="line"><span class="string">        page_size: Page size</span></span><br><span class="line"><span class="string">        filter: 查询项目的请求参数</span></span><br><span class="line"><span class="string">            project_id: Project ID</span></span><br><span class="line"><span class="string">            id__in: Item ID to include, split by comma</span></span><br><span class="line"><span class="string">            tags__in: Tags name to include, split by comma</span></span><br><span class="line"><span class="string">            # ... 更多嵌套参数</span></span><br><span class="line"><span class="string">        sort (array): see tool description</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>Token 效率高</strong>：内容简洁，token 消耗少</li><li><strong>可读性强</strong>：层级结构清晰，人类容易理解</li><li><strong>简洁明了</strong>：只显示关键信息（参数名和描述）</li><li><strong>智能嵌套处理</strong>：通过 3 层深度限制，平衡了复杂性和可理解性</li><li><strong>LLM 优化设计</strong>：专门针对 LLM 的理解能力进行优化，避免信息过载</li><li><strong>实用性导向</strong>：覆盖绝大多数实际使用场景，避免过度复杂化</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li><strong>信息不完整</strong>：缺少详细的类型约束、枚举值、默认值等</li><li><strong>结构化程度低</strong>：不是标准化的 JSON Schema 格式</li><li><strong>验证信息缺失</strong>：缺少 <code>required</code>、<code>minLength</code>、<code>maxLength</code> 等验证规则</li></ol><h3 id="2-JSON-格式-feature-x2F-json-input-schema-formatting"><a href="#2-JSON-格式-feature-x2F-json-input-schema-formatting" class="headerlink" title="2. JSON 格式 (feature&#x2F;json-input-schema-formatting)"></a>2. JSON 格式 (<a href="https://github.com/Edison-A-N/smolagents/tree/feature/json-input-schema-formatting">feature&#x2F;json-input-schema-formatting</a>)</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>直接使用 <code>json.dumps()</code> 序列化完整的 <code>inputs</code> 字典</li><li>保持完整的 JSON Schema 结构</li><li>包含所有类型信息和约束条件</li></ul><h4 id="示例输出-1"><a href="#示例输出-1" class="headerlink" title="示例输出"></a>示例输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_items_v1_item_search</span>(<span class="params">page: integer, page_size: integer, <span class="built_in">filter</span>: <span class="built_in">object</span>, sort: array</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Search items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Important: This tool returns structured output! Use the JSON schema below to directly access fields like result[&#x27;field_name&#x27;]. NO print() statements needed to inspect the output!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dict (input schema): This tool expects arguments that strictly adhere to the following JSON schema:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;page&quot;: &#123;</span></span><br><span class="line"><span class="string">                    &quot;type&quot;: &quot;integer&quot;,</span></span><br><span class="line"><span class="string">                    &quot;minimum&quot;: 1.0,</span></span><br><span class="line"><span class="string">                    &quot;title&quot;: &quot;Page&quot;,</span></span><br><span class="line"><span class="string">                    &quot;description&quot;: &quot;Page number&quot;,</span></span><br><span class="line"><span class="string">                    &quot;default&quot;: 1</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &quot;page_size&quot;: &#123;</span></span><br><span class="line"><span class="string">                    &quot;type&quot;: &quot;integer&quot;,</span></span><br><span class="line"><span class="string">                    &quot;maximum&quot;: 10000.0,</span></span><br><span class="line"><span class="string">                    &quot;minimum&quot;: 1.0,</span></span><br><span class="line"><span class="string">                    &quot;title&quot;: &quot;Page Size&quot;,</span></span><br><span class="line"><span class="string">                    &quot;description&quot;: &quot;Page size&quot;,</span></span><br><span class="line"><span class="string">                    &quot;default&quot;: 25</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                # ... 完整的 JSON Schema</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>信息完整</strong>：包含完整的 JSON Schema 信息</li><li><strong>标准化</strong>：符合 JSON Schema 标准，便于程序化处理</li><li><strong>详细约束</strong>：包含类型、枚举、默认值、验证规则等</li><li><strong>精确匹配</strong>：提供精确的参数结构定义</li><li><strong>未来扩展性</strong>：易于添加新的 Schema 属性</li></ol><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol><li><strong>Token 消耗大</strong>：内容冗长，token 消耗多</li><li><strong>可读性差</strong>：对 LLM 来说，大量 JSON 结构可能造成信息过载</li><li><strong>解析复杂</strong>：LLM 需要从大量 JSON 中提取关键信息</li><li><strong>冗余信息</strong>：包含很多 LLM 可能不需要的详细约束</li></ol><h2 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h2><blockquote><p><strong>重要说明</strong>：以下性能数据基于前述方法的单一测试用例，仅作为定性示例展示两种格式的差异趋势，不应用于定量判断或生产环境的性能评估。实际性能可能因具体使用场景、模型类型、参数复杂度等因素而有所差异。</p></blockquote><h3 id="Token-使用量对比"><a href="#Token-使用量对比" class="headerlink" title="Token 使用量对比"></a>Token 使用量对比</h3><table><thead><tr><th>格式</th><th>Step 1 Tokens</th><th>Step 2 Tokens</th><th>总 Tokens</th><th>相对差异</th></tr></thead><tbody><tr><td>Indent 格式</td><td>53,953</td><td>108,123</td><td>162,076</td><td>基准</td></tr><tr><td>JSON 格式</td><td>76,436</td><td>153,135</td><td>229,571</td><td>+42%</td></tr></tbody></table><p><strong>结论</strong>：JSON 格式比 Indent 格式多消耗约 42% 的 tokens</p><h3 id="参数内容长度对比"><a href="#参数内容长度对比" class="headerlink" title="参数内容长度对比"></a>参数内容长度对比</h3><table><thead><tr><th>格式</th><th>输出行数</th><th>相对差异</th></tr></thead><tbody><tr><td>Indent 格式</td><td>874 行</td><td>基准</td></tr><tr><td>JSON 格式</td><td>1,269 行</td><td>+45%</td></tr></tbody></table><p><strong>结论</strong>：JSON 格式比 Indent 格式多约 45% 的内容</p><h2 id="准确性对比"><a href="#准确性对比" class="headerlink" title="准确性对比"></a>准确性对比</h2><h3 id="参数匹配准确性"><a href="#参数匹配准确性" class="headerlink" title="参数匹配准确性"></a>参数匹配准确性</h3><ul><li><strong>Indent 格式</strong>：✅ 能正确识别和匹配复杂参数</li><li><strong>JSON 格式</strong>：✅ 能正确识别和匹配复杂参数</li><li><strong>结论</strong>：两种格式的参数匹配准确性基本相同</li></ul><h3 id="任务执行结果"><a href="#任务执行结果" class="headerlink" title="任务执行结果"></a>任务执行结果</h3><ul><li><strong>Indent 格式</strong>：✅ 成功执行任务，返回正确结果 (291)</li><li><strong>JSON 格式</strong>：✅ 成功执行任务，返回正确结果 (291)</li><li><strong>结论</strong>：两种格式都能正确完成任务</li></ul><h2 id="综合评估"><a href="#综合评估" class="headerlink" title="综合评估"></a>综合评估</h2><h3 id="推荐方案：Indent-格式"><a href="#推荐方案：Indent-格式" class="headerlink" title="推荐方案：Indent 格式"></a>推荐方案：Indent 格式</h3><p>基于全面的分析，<strong>推荐使用 Indent 格式</strong>，理由如下：</p><ol><li><strong>成本效益最优</strong>：Token 消耗减少 42%，成本显著降低</li><li><strong>准确性相当</strong>：两种格式的参数匹配准确性基本相同</li><li><strong>LLM 友好</strong>：简洁的格式更适合 LLM 理解和处理</li><li><strong>实用性更强</strong>：对于大多数用例，LLM 只需要知道参数名和基本描述</li></ol><h3 id="可能的改进建议"><a href="#可能的改进建议" class="headerlink" title="可能的改进建议"></a>可能的改进建议</h3><ol><li><strong>混合方案</strong>：可以考虑在 Indent 格式基础上，为关键参数添加类型信息</li><li><strong>关键约束保留</strong>：对于重要的验证规则（如 <code>required</code>），可以在描述中体现</li><li><strong>分层显示</strong>：简单参数用 Indent 格式，复杂嵌套参数可选择 JSON 格式</li></ol><h3 id="使用场景建议"><a href="#使用场景建议" class="headerlink" title="使用场景建议"></a>使用场景建议</h3><h4 id="推荐使用-Indent-格式的场景："><a href="#推荐使用-Indent-格式的场景：" class="headerlink" title="推荐使用 Indent 格式的场景："></a>推荐使用 Indent 格式的场景：</h4><ul><li>大多数常规工具调用场景</li><li>成本敏感的应用</li><li>需要快速响应的应用</li><li>参数结构相对简单的工具</li></ul><h4 id="可考虑使用-JSON-格式的场景："><a href="#可考虑使用-JSON-格式的场景：" class="headerlink" title="可考虑使用 JSON 格式的场景："></a>可考虑使用 JSON 格式的场景：</h4><ul><li>需要严格参数验证的场景</li><li>参数结构极其复杂的工具</li><li>需要程序化处理 Schema 的场景</li><li>对成本不敏感的应用</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基于单一测试用例的对比分析，虽然 JSON 格式提供了更完整的信息，但在测试场景中，<strong>Indent 格式在保持相同准确性的同时，显著降低了成本</strong>。更重要的是，Indent 格式的设计体现了对 LLM 认知特性的深度理解：</p><blockquote><p><strong>测试局限性说明</strong>：本分析基于特定的测试用例，实际效果可能因具体应用场景而异。建议在生产环境中进行更全面的测试验证。</p></blockquote><ol><li><strong>成本效益最优</strong>：在保持功能完整性的前提下，最大化成本效益</li><li><strong>用户体验导向</strong>：优先考虑 LLM 的理解能力和开发者的使用体验</li></ol><p><strong>最终建议</strong>：采用 Indent 格式作为默认方案，其设计哲学体现了对技术细节的深度思考。同时保留 JSON 格式作为可选的高级配置选项，以满足特殊场景的需求。这种设计既保证了实用性，又为未来的优化和改进留下了空间。</p><hr><p><em>基于分支：<a href="https://github.com/Edison-A-N/smolagents/tree/feature/nested-args-formatting">feature&#x2F;nested-args-formatting</a> vs <a href="https://github.com/Edison-A-N/smolagents/tree/feature/json-input-schema-formatting">feature&#x2F;json-input-schema-formatting</a></em></p>]]></content>
    
    
    <summary type="html">本文对比分析了 smolagents 项目中两种不同的 args_doc 组织形式（Indent 格式 vs JSON 格式），评估了它们在 Token 消耗、可读性、LLM 理解能力等方面的优劣势，并提出了推荐方案和使用场景建议。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="Tool Format" scheme="https://edison-a-n.github.io/tags/Tool-Format/"/>
    
  </entry>
  
  <entry>
    <title>ASGI Lifespan 完整指南</title>
    <link href="https://edison-a-n.github.io/2025/10/27/asgi_lifespan_complete_guide/"/>
    <id>https://edison-a-n.github.io/2025/10/27/asgi_lifespan_complete_guide/</id>
    <published>2025-10-26T16:00:00.000Z</published>
    <updated>2025-10-27T09:02:29.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#asgi-lifespan-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">ASGI Lifespan 协议概述</a></li><li><a href="#%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83%E8%AF%A6%E8%A7%A3">协议规范详解</a></li><li><a href="#uvicorn-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90">Uvicorn 实现分析</a></li><li><a href="#starlette-%E9%9B%86%E6%88%90%E6%9C%BA%E5%88%B6">Starlette 集成机制</a></li><li><a href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">实际应用示例</a></li><li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li></ol><h2 id="ASGI-Lifespan-协议概述"><a href="#ASGI-Lifespan-协议概述" class="headerlink" title="ASGI Lifespan 协议概述"></a>ASGI Lifespan 协议概述</h2><h3 id="什么是-Lifespan-协议？"><a href="#什么是-Lifespan-协议？" class="headerlink" title="什么是 Lifespan 协议？"></a>什么是 Lifespan 协议？</h3><p>ASGI Lifespan 协议是 ASGI 规范的一个子协议，用于管理应用程序的启动和关闭生命周期。它允许应用程序在服务器启动时执行初始化操作（如连接数据库），在服务器关闭时执行清理操作（如关闭连接）。</p><h3 id="核心设计原则"><a href="#核心设计原则" class="headerlink" title="核心设计原则"></a>核心设计原则</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI 官方文档</a>：</p><ol><li><p><strong>单一连接模式</strong>：整个应用生命周期使用一个持久的连接</p><blockquote><p>Lifespans should be executed once per event loop that will be processing requests</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Protocol</a></p></blockquote></li><li><p><strong>事件驱动</strong>：通过特定事件类型触发启动和关闭逻辑</p></li><li><p><strong>状态管理</strong>：支持在应用状态中持久化数据</p><blockquote><p>The <code>scope[&quot;state&quot;]</code> namespace provides a place to store these sorts of things. The server will ensure that a <em>shallow copy</em> of the namespace is passed into each subsequent request&#x2F;response call into the application.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#lifespan-state">ASGI Lifespan State</a></p></blockquote></li><li><p><strong>异常安全</strong>：提供完整的错误处理机制</p><blockquote><p>If an exception is raised when calling the application callable with a <code>lifespan.startup</code> message or a <code>scope</code> with type <code>lifespan</code>, the server must continue but not send any lifespan events.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI Lifespan Scope</a></p></blockquote></li></ol><h2 id="协议规范详解"><a href="#协议规范详解" class="headerlink" title="协议规范详解"></a>协议规范详解</h2><h3 id="Scope-结构"><a href="#Scope-结构" class="headerlink" title="Scope 结构"></a>Scope 结构</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI Lifespan Scope 规范</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ASGI Lifespan Scope 结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan&quot;</span>,                    <span class="comment"># 固定值</span></span><br><span class="line">    <span class="string">&quot;asgi&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;version&quot;</span>: <span class="string">&quot;3.0&quot;</span>,                 <span class="comment"># ASGI 版本</span></span><br><span class="line">        <span class="string">&quot;spec_version&quot;</span>: <span class="string">&quot;2.0&quot;</span>             <span class="comment"># Lifespan 协议版本</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: &#123;&#125;                           <span class="comment"># 应用状态字典（可选）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The lifespan scope exists for the duration of the event loop. The scope information passed in <code>scope</code> contains basic metadata:</p><ul><li><code>type</code> (<em>Unicode string</em>) – <code>&quot;lifespan&quot;</code></li><li><code>asgi[&quot;version&quot;]</code> (<em>Unicode string</em>) – The version of the ASGI spec</li><li><code>asgi[&quot;spec_version&quot;]</code> (<em>Unicode string</em>) – The version of this spec being used. Optional; if missing defaults to <code>&quot;1.0&quot;</code></li><li><code>state</code> Optional(<em>dict[Unicode string, Any]</em>) – An empty namespace where the application can persist state to be used when handling subsequent requests</li></ul><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI Lifespan Scope</a></p></blockquote><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan 事件规范</a>：</p><h4 id="接收事件（receive）"><a href="#接收事件（receive）" class="headerlink" title="接收事件（receive）"></a>接收事件（receive）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Startup - receive event</strong>: Sent to the application when the server is ready to startup and receive connections, but before it has started to do so.</p><p><strong>Shutdown - receive event</strong>: Sent to the application when the server has stopped accepting connections and closed all active connections.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Events</a></p></blockquote><h4 id="发送事件（send）"><a href="#发送事件（send）" class="headerlink" title="发送事件（send）"></a>发送事件（send）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动完成</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.complete&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动失败</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.failed&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;错误信息&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭完成</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.complete&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭失败</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.failed&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;错误信息&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Startup Complete - send event</strong>: Sent by the application when it has completed its startup. A server must wait for this message before it starts processing connections.</p><p><strong>Startup Failed - send event</strong>: Sent by the application when it has failed to complete its startup. If a server sees this it should log&#x2F;print the message provided and then exit.</p><p><strong>Shutdown Complete - send event</strong>: Sent by the application when it has completed its cleanup. A server must wait for this message before terminating.</p><p><strong>Shutdown Failed - send event</strong>: Sent by the application when it has failed to complete its cleanup. If a server sees this it should log&#x2F;print the message provided and then terminate.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Events</a></p></blockquote><h3 id="标准应用实现"><a href="#标准应用实现" class="headerlink" title="标准应用实现"></a>标准应用实现</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan 协议示例</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">app</span>(<span class="params">scope, receive, send</span>):</span><br><span class="line">    <span class="keyword">if</span> scope[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;lifespan&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            message = <span class="keyword">await</span> receive()</span><br><span class="line">            <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;lifespan.startup&#x27;</span>:</span><br><span class="line">                <span class="comment"># 执行启动逻辑</span></span><br><span class="line">                <span class="keyword">await</span> send(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;lifespan.startup.complete&#x27;</span>&#125;)</span><br><span class="line">            <span class="keyword">elif</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;lifespan.shutdown&#x27;</span>:</span><br><span class="line">                <span class="comment"># 执行关闭逻辑</span></span><br><span class="line">                <span class="keyword">await</span> send(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;lifespan.shutdown.complete&#x27;</span>&#125;)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理其他类型的请求</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>A possible implementation of this protocol is given below:</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Protocol</a></p></blockquote><h2 id="Uvicorn-实现分析"><a href="#Uvicorn-实现分析" class="headerlink" title="Uvicorn 实现分析"></a>Uvicorn 实现分析</h2><p>基于 <a href="https://github.com/encode/uvicorn">Uvicorn 源码</a> 的分析：</p><h3 id="核心实现类"><a href="#核心实现类" class="headerlink" title="核心实现类"></a>核心实现类</h3><h4 id="LifespanOn-类"><a href="#LifespanOn-类" class="headerlink" title="LifespanOn 类"></a>LifespanOn 类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uvicorn/lifespan/on.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifespanOn</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config: Config</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> config.loaded:</span><br><span class="line">            config.load()</span><br><span class="line">        </span><br><span class="line">        self.config = config</span><br><span class="line">        self.logger = logging.getLogger(<span class="string">&quot;uvicorn.error&quot;</span>)</span><br><span class="line">        self.startup_event = asyncio.Event()</span><br><span class="line">        self.shutdown_event = asyncio.Event()</span><br><span class="line">        self.receive_queue: Queue[LifespanReceiveMessage] = asyncio.Queue()</span><br><span class="line">        self.error_occured = <span class="literal">False</span></span><br><span class="line">        self.startup_failed = <span class="literal">False</span></span><br><span class="line">        self.shutdown_failed = <span class="literal">False</span></span><br><span class="line">        self.should_exit = <span class="literal">False</span></span><br><span class="line">        self.state: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">startup</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    self.logger.info(<span class="string">&quot;Waiting for application startup.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建 lifespan 主任务</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    main_lifespan_task = loop.create_task(self.main())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送 startup 事件</span></span><br><span class="line">    startup_event: LifespanStartupEvent = &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">await</span> self.receive_queue.put(startup_event)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待应用完成启动</span></span><br><span class="line">    <span class="keyword">await</span> self.startup_event.wait()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查启动结果</span></span><br><span class="line">    <span class="keyword">if</span> self.startup_failed <span class="keyword">or</span> (self.error_occured <span class="keyword">and</span> self.config.lifespan == <span class="string">&quot;on&quot;</span>):</span><br><span class="line">        self.logger.error(<span class="string">&quot;Application startup failed. Exiting.&quot;</span>)</span><br><span class="line">        self.should_exit = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;Application startup complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关闭流程"><a href="#关闭流程" class="headerlink" title="关闭流程"></a>关闭流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> self.error_occured:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.logger.info(<span class="string">&quot;Waiting for application shutdown.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送 shutdown 事件</span></span><br><span class="line">    shutdown_event: LifespanShutdownEvent = &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">await</span> self.receive_queue.put(shutdown_event)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待应用完成关闭</span></span><br><span class="line">    <span class="keyword">await</span> self.shutdown_event.wait()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查关闭结果</span></span><br><span class="line">    <span class="keyword">if</span> self.shutdown_failed <span class="keyword">or</span> (self.error_occured <span class="keyword">and</span> self.config.lifespan == <span class="string">&quot;on&quot;</span>):</span><br><span class="line">        self.logger.error(<span class="string">&quot;Application shutdown failed. Exiting.&quot;</span>)</span><br><span class="line">        self.should_exit = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;Application shutdown complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="核心通信机制"><a href="#核心通信机制" class="headerlink" title="核心通信机制"></a>核心通信机制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        app = self.config.loaded_app</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建 lifespan scope</span></span><br><span class="line">        scope: LifespanScope = &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan&quot;</span>,</span><br><span class="line">            <span class="string">&quot;asgi&quot;</span>: &#123;<span class="string">&quot;version&quot;</span>: self.config.asgi_version, <span class="string">&quot;spec_version&quot;</span>: <span class="string">&quot;2.0&quot;</span>&#125;,</span><br><span class="line">            <span class="string">&quot;state&quot;</span>: self.state,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用应用的 lifespan 处理器</span></span><br><span class="line">        <span class="keyword">await</span> app(scope, self.receive, self.send)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">        self.asgi = <span class="literal">None</span></span><br><span class="line">        self.error_occured = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.startup_failed <span class="keyword">or</span> self.shutdown_failed:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.config.lifespan == <span class="string">&quot;auto&quot;</span>:</span><br><span class="line">            msg = <span class="string">&quot;ASGI &#x27;lifespan&#x27; protocol appears unsupported.&quot;</span></span><br><span class="line">            self.logger.info(msg)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&quot;Exception in &#x27;lifespan&#x27; protocol\n&quot;</span></span><br><span class="line">            self.logger.error(msg, exc_info=exc)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.startup_event.<span class="built_in">set</span>()</span><br><span class="line">        self.shutdown_event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, message: LifespanSendMessage</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">assert</span> message[<span class="string">&quot;type&quot;</span>] <span class="keyword">in</span> (</span><br><span class="line">        <span class="string">&quot;lifespan.startup.complete&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lifespan.startup.failed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lifespan.shutdown.complete&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lifespan.shutdown.failed&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.startup.complete&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.startup_event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.startup.failed&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.startup_event.<span class="built_in">set</span>()</span><br><span class="line">        self.startup_failed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&quot;message&quot;</span>):</span><br><span class="line">            self.logger.error(message[<span class="string">&quot;message&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.shutdown.complete&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.shutdown_event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.shutdown.failed&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.shutdown_event.<span class="built_in">set</span>()</span><br><span class="line">        self.shutdown_failed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&quot;message&quot;</span>):</span><br><span class="line">            self.logger.error(message[<span class="string">&quot;message&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self</span>) -&gt; LifespanReceiveMessage:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> self.receive_queue.get()</span><br></pre></td></tr></table></figure><h3 id="配置选择机制"><a href="#配置选择机制" class="headerlink" title="配置选择机制"></a>配置选择机制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uvicorn/config.py</span></span><br><span class="line">LIFESPAN: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;auto&quot;</span>: <span class="string">&quot;uvicorn.lifespan.on:LifespanOn&quot;</span>,    <span class="comment"># 自动检测</span></span><br><span class="line">    <span class="string">&quot;on&quot;</span>: <span class="string">&quot;uvicorn.lifespan.on:LifespanOn&quot;</span>,      <span class="comment"># 强制启用</span></span><br><span class="line">    <span class="string">&quot;off&quot;</span>: <span class="string">&quot;uvicorn.lifespan.off:LifespanOff&quot;</span>,   <span class="comment"># 禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Starlette-集成机制"><a href="#Starlette-集成机制" class="headerlink" title="Starlette 集成机制"></a>Starlette 集成机制</h2><p>基于 <a href="https://github.com/encode/starlette">Starlette 源码</a> 的分析：</p><h3 id="事件路由"><a href="#事件路由" class="headerlink" title="事件路由"></a>事件路由</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Starlette Application.__call__</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    scope[<span class="string">&quot;app&quot;</span>] = self</span><br><span class="line">    <span class="keyword">if</span> self.middleware_stack <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.middleware_stack = self.build_middleware_stack()</span><br><span class="line">    <span class="keyword">await</span> self.middleware_stack(scope, receive, send)</span><br></pre></td></tr></table></figure><h3 id="Lifespan-处理"><a href="#Lifespan-处理" class="headerlink" title="Lifespan 处理"></a>Lifespan 处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">lifespan</span>(<span class="params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Handle ASGI lifespan messages, which allows us to manage application</span></span><br><span class="line"><span class="string">    startup and shutdown events.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    started = <span class="literal">False</span></span><br><span class="line">    app: <span class="type">Any</span> = scope.get(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> receive()  <span class="comment"># 接收第一个 lifespan.startup 事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> self.lifespan_context(app) <span class="keyword">as</span> maybe_state:</span><br><span class="line">            <span class="keyword">if</span> maybe_state <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;state&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> scope:</span><br><span class="line">                    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;The server does not support &quot;state&quot; in the lifespan scope.&#x27;</span>)</span><br><span class="line">                scope[<span class="string">&quot;state&quot;</span>].update(maybe_state)</span><br><span class="line">            <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.complete&quot;</span>&#125;)</span><br><span class="line">            started = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">await</span> receive()  <span class="comment"># 等待 lifespan.shutdown 事件</span></span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        exc_text = traceback.format_exc()</span><br><span class="line">        <span class="keyword">if</span> started:</span><br><span class="line">            <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.failed&quot;</span>, <span class="string">&quot;message&quot;</span>: exc_text&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.failed&quot;</span>, <span class="string">&quot;message&quot;</span>: exc_text&#125;)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.complete&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="关键设计特点"><a href="#关键设计特点" class="headerlink" title="关键设计特点"></a>关键设计特点</h3><p>根据 <a href="https://github.com/encode/starlette/blob/master/starlette/routing.py">Starlette Lifespan 实现</a>：</p><ol><li><strong>一次性处理</strong>：<code>lifespan</code> 方法执行一次，处理整个应用生命周期</li><li><strong>阻塞等待</strong>：通过两次 <code>await receive()</code> 分别处理 startup 和 shutdown 事件</li><li><strong>异常安全</strong>：完整的错误处理和状态管理</li><li><strong>状态传递</strong>：支持将 lifespan 结果传递给应用状态</li></ol><blockquote><p>The lifespan protocol runs as a sibling task alongside your main application, allowing both to execute concurrently.</p><p>来源：<a href="https://www.starlette.io/lifespan/">Starlette Lifespan 文档</a></p></blockquote><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><p>基于 <a href="https://fastapi.tiangolo.com/advanced/events/">FastAPI Lifespan 指南</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> asynccontextmanager</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库连接</span></span><br><span class="line">db_connection = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="comment"># 启动时执行</span></span><br><span class="line">    <span class="keyword">global</span> db_connection</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connecting to database...&quot;</span>)</span><br><span class="line">    db_connection = <span class="keyword">await</span> connect_database()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> &#123;<span class="string">&quot;database&quot;</span>: db_connection&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 关闭时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Closing database connection...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> db_connection.close()</span><br><span class="line"></span><br><span class="line">app = FastAPI(lifespan=lifespan)</span><br></pre></td></tr></table></figure><blockquote><p>You can define lifespan events (startup and shutdown) with FastAPI using a <code>lifespan</code> parameter in the <code>FastAPI</code> app.</p><p>来源：<a href="https://fastapi.tiangolo.com/advanced/events/">FastAPI Lifespan 指南</a></p></blockquote><h3 id="复杂资源管理"><a href="#复杂资源管理" class="headerlink" title="复杂资源管理"></a>复杂资源管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> AsyncExitStack</span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">complex_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">        <span class="comment"># 动态管理多个资源</span></span><br><span class="line">        db = <span class="keyword">await</span> stack.enter_async_context(connect_database())</span><br><span class="line">        cache = <span class="keyword">await</span> stack.enter_async_context(connect_redis())</span><br><span class="line">        session_pool = <span class="keyword">await</span> stack.enter_async_context(create_session_pool())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注册清理回调</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cleanup_logs</span>():</span><br><span class="line">            cleanup_log_files()</span><br><span class="line">        stack.callback(cleanup_logs)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">&quot;database&quot;</span>: db,</span><br><span class="line">            <span class="string">&quot;cache&quot;</span>: cache,</span><br><span class="line">            <span class="string">&quot;sessions&quot;</span>: session_pool</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 所有资源会自动按相反顺序清理</span></span><br></pre></td></tr></table></figure><h3 id="FastMCP-集成示例"><a href="#FastMCP-集成示例" class="headerlink" title="FastMCP 集成示例"></a>FastMCP 集成示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;MyServer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.lifespan</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_lifespan</span>(<span class="params">server</span>):</span><br><span class="line">    <span class="comment"># 启动时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initializing MCP server...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> server.setup_tools()</span><br><span class="line">    <span class="keyword">await</span> server.connect_to_database()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> &#123;<span class="string">&quot;server&quot;</span>: server&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 关闭时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shutting down MCP server...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> server.cleanup_tools()</span><br><span class="line">    <span class="keyword">await</span> server.close_database()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建应用</span></span><br><span class="line">app = mcp.create_app()</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-资源管理"><a href="#1-资源管理" class="headerlink" title="1. 资源管理"></a>1. 资源管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">proper_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    resources = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 初始化资源</span></span><br><span class="line">        resources[<span class="string">&quot;db&quot;</span>] = <span class="keyword">await</span> connect_database()</span><br><span class="line">        resources[<span class="string">&quot;cache&quot;</span>] = <span class="keyword">await</span> connect_redis()</span><br><span class="line">        resources[<span class="string">&quot;http_client&quot;</span>] = aiohttp.ClientSession()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> resources</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 确保资源被正确清理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;http_client&quot;</span> <span class="keyword">in</span> resources:</span><br><span class="line">            <span class="keyword">await</span> resources[<span class="string">&quot;http_client&quot;</span>].close()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;cache&quot;</span> <span class="keyword">in</span> resources:</span><br><span class="line">            <span class="keyword">await</span> resources[<span class="string">&quot;cache&quot;</span>].close()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;db&quot;</span> <span class="keyword">in</span> resources:</span><br><span class="line">            <span class="keyword">await</span> resources[<span class="string">&quot;db&quot;</span>].close()</span><br></pre></td></tr></table></figure><h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">robust_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 启动逻辑</span></span><br><span class="line">        db = <span class="keyword">await</span> connect_database()</span><br><span class="line">        <span class="keyword">yield</span> &#123;<span class="string">&quot;database&quot;</span>: db&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 记录错误但不阻止应用启动</span></span><br><span class="line">        logger.error(<span class="string">f&quot;Failed to initialize database: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 清理逻辑</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;db&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():</span><br><span class="line">                <span class="keyword">await</span> db.close()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;Failed to close database: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-状态管理"><a href="#3-状态管理" class="headerlink" title="3. 状态管理"></a>3. 状态管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stateful_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="comment"># 初始化应用状态</span></span><br><span class="line">    app_state = &#123;</span><br><span class="line">        <span class="string">&quot;startup_time&quot;</span>: time.time(),</span><br><span class="line">        <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;environment&quot;</span>: os.getenv(<span class="string">&quot;ENV&quot;</span>, <span class="string">&quot;development&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接数据库</span></span><br><span class="line">    db = <span class="keyword">await</span> connect_database()</span><br><span class="line">    app_state[<span class="string">&quot;database&quot;</span>] = db</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置全局配置</span></span><br><span class="line">    app.state.config = app_state</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> app_state</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清理</span></span><br><span class="line">    <span class="keyword">await</span> db.close()</span><br></pre></td></tr></table></figure><h3 id="4-性能监控"><a href="#4-性能监控" class="headerlink" title="4. 性能监控"></a>4. 性能监控</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">monitored_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 启动监控</span></span><br><span class="line">        metrics = <span class="keyword">await</span> setup_metrics_collection()</span><br><span class="line">        <span class="keyword">yield</span> &#123;<span class="string">&quot;metrics&quot;</span>: metrics&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 记录运行时间</span></span><br><span class="line">        runtime = time.time() - start_time</span><br><span class="line">        logger.info(<span class="string">f&quot;Application ran for <span class="subst">&#123;runtime:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ASGI Lifespan 协议是现代异步 Python Web 应用的核心组件，它提供了：</p><ol><li><strong>标准化的生命周期管理</strong>：统一的启动和关闭流程</li><li><strong>异常安全保证</strong>：确保资源正确清理</li><li><strong>状态管理</strong>：支持应用状态持久化</li><li><strong>协议兼容性</strong>：与所有 ASGI 服务器兼容</li></ol><blockquote><p>The lifespan messages allow for an application to initialise and shutdown in the context of a running event loop. An example of this would be creating a connection pool and subsequently closing the connection pool to release the connections.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Protocol</a></p></blockquote><p>通过合理使用 Lifespan 协议，可以构建更加健壮和可维护的异步 Web 应用。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan 协议规范</a></li><li><a href="https://github.com/encode/uvicorn">Uvicorn 源码</a></li><li><a href="https://www.starlette.io/lifespan/">Starlette 文档</a></li><li><a href="https://fastapi.tiangolo.com/advanced/events/">FastAPI Lifespan 指南</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了ASGI Lifespan协议的规范、Uvicorn实现、Starlette集成机制，并提供了实际应用示例和最佳实践。</summary>
    
    
    
    
    <category term="ASGI, Python, FastAPI" scheme="https://edison-a-n.github.io/tags/ASGI-Python-FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>MCP Output Schema：数据验证与结构化输出的技术实现</title>
    <link href="https://edison-a-n.github.io/2025/09/29/mcp-output-schema/"/>
    <id>https://edison-a-n.github.io/2025/09/29/mcp-output-schema/</id>
    <published>2025-09-28T16:00:00.000Z</published>
    <updated>2025-10-21T01:09:44.876Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由AI生成</div><h3 id="MCP-Output-Schema的核心价值与应用场景"><a href="#MCP-Output-Schema的核心价值与应用场景" class="headerlink" title="MCP Output Schema的核心价值与应用场景"></a>MCP Output Schema的核心价值与应用场景</h3><p>Model Context Protocol (MCP) 的output schema机制在复杂的数据交互场景中发挥着关键作用。基于<a href="https://modelcontextprotocol.io/specification/2025-06-18/server/tools#output-schema">MCP官方文档</a>的定义，output schema能够”验证工具结果的结构，并在验证后对包含的值进行更明智的检查”。</p><h4 id="1-数据验证与安全保障"><a href="#1-数据验证与安全保障" class="headerlink" title="1. 数据验证与安全保障"></a>1. 数据验证与安全保障</h4><p>MCP output schema的首要价值体现在数据验证层面。这一功能在与不可信服务器交互时尤为重要，它确保了：</p><ul><li><strong>结构完整性保障</strong>：服务端返回的数据必须符合预定义的schema结构</li><li><strong>异常处理机制</strong>：当数据校验失败时，服务端能够及时识别并处理异常</li><li>**<a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">安全增强</a>**：提升了与第三方服务交互时的数据安全性</li></ul><h4 id="2-结构化数据在编程环境中的直接应用"><a href="#2-结构化数据在编程环境中的直接应用" class="headerlink" title="2. 结构化数据在编程环境中的直接应用"></a>2. 结构化数据在编程环境中的直接应用</h4><p>在 <a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">PR</a> 还提到，”Making tool results available as structured data in coding environments.”这一应用场景具有极高的实用价值。参考HuggingFace的 <a href="https://www.linkedin.com/pulse/huggingface-smolagents-fast-lightweight-llm-agents-powered-mishra-v5sxc/">SmolAgents</a> 项目，我们可以看到结构化输出的重要意义：</p><ul><li><strong>直接数据使用</strong>：LLM代理能够直接消费结构化数据，无需复杂的文本解析</li><li><strong>效率提升</strong>：避免了LLM对复杂JSON结构的理解和转换过程</li><li><strong>准确性增强</strong>：减少了因解析错误导致的代码执行问题</li></ul><h3 id="LLM处理结构化数据的局限性"><a href="#LLM处理结构化数据的局限性" class="headerlink" title="LLM处理结构化数据的局限性"></a>LLM处理结构化数据的局限性</h3><h4 id="解析复杂度的挑战"><a href="#解析复杂度的挑战" class="headerlink" title="解析复杂度的挑战"></a>解析复杂度的挑战</h4><p><strong>LLM极不擅长解析结构数据</strong>，这一观点在MCP tool设计中至关重要：</p><ul><li><strong>解析复杂度</strong>：对于嵌套层次深、字段众多的JSON对象，LLM容易出现解析错误，复杂结构交给LLM解析是不合适的</li><li><strong>认知负担</strong>：复杂的数据结构会显著增加LLM的理解负担，影响响应质量和可靠性</li><li><strong>提示工程需求</strong>：需要额外的提示工程来指导LLM正确处理结构化输出，增加了使用复杂度</li></ul><h4 id="单一职责原则的重要性"><a href="#单一职责原则的重要性" class="headerlink" title="单一职责原则的重要性"></a>单一职责原则的重要性</h4><p>基于上述局限性，<strong>Tool的input和output应该尽量简单</strong>，Single Responsibility Principle在MCP tool设计中越来越显现价值：</p><ul><li><strong>职责单一化</strong>：每个tool应该专注于单一功能，避免处理过于复杂的输入输出</li><li><strong>接口简洁性</strong>：保持输入输出参数的简洁性，降低LLM的理解难度</li><li><strong>可组合性</strong>：通过简单tool的组合来实现复杂功能，而不是设计复杂的单体tool</li></ul><h3 id="Schema设计原则"><a href="#Schema设计原则" class="headerlink" title="Schema设计原则"></a>Schema设计原则</h3><p>基于Tool输入输出应该尽量简单的原则：</p><ul><li><strong>保持输出结构的简洁性和一致性</strong>，避免过度复杂</li><li><strong>避免过度嵌套和字段冗余</strong>，降低LLM解析难度</li><li><strong>提供清晰的文档说明和示例</strong>，帮助LLM正确理解</li></ul><h3 id="技术实现考量"><a href="#技术实现考量" class="headerlink" title="技术实现考量"></a>技术实现考量</h3><h4 id="数据验证机制"><a href="#数据验证机制" class="headerlink" title="数据验证机制"></a>数据验证机制</h4><p>MCP output schema通过以下机制确保数据质量：</p><ol><li><strong>结构验证</strong>：检查返回数据是否符合预定义的JSON schema</li><li><strong>类型检查</strong>：验证数据类型是否匹配预期</li><li><strong>必填字段验证</strong>：确保关键字段不为空</li><li><strong>格式验证</strong>：检查字符串格式、数值范围等</li></ol><h4 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h4><p>当schema验证失败时，系统应该：</p><ul><li><strong>提供清晰的错误信息</strong>，说明具体哪个字段验证失败</li><li><strong>记录详细的日志</strong>，便于调试和问题排查</li><li><strong>优雅降级</strong>，在验证失败时提供默认值或跳过该字段</li><li><strong>重试机制</strong>，对于临时性错误提供重试机会</li></ul><h3 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><h4 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1. 设计原则"></a>1. 设计原则</h4><ul><li><strong>保持简单</strong>：避免过度复杂的嵌套结构</li><li><strong>一致性</strong>：在整个系统中保持schema的一致性</li><li><strong>文档化</strong>：为每个字段提供清晰的说明和示例</li><li><strong>版本控制</strong>：考虑schema的向后兼容性</li></ul><h4 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h4><ul><li><strong>缓存机制</strong>：对频繁调用的schema进行缓存</li><li><strong>批量处理</strong>：支持批量数据验证</li><li><strong>异步处理</strong>：对于复杂验证使用异步处理</li><li><strong>监控指标</strong>：监控验证成功率和性能指标</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>MCP Output Schema通过结构验证确保数据完整性和安全性，结构化输出减少了LLM的解析负担，统一的schema设计提高了系统的可维护性。</p><p>通过合理应用MCP Output Schema，遵循单一职责原则，优化schema结构，我们可以构建更加可靠、高效的AI代理系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">MCP Output Schema Proposal</a></li><li><a href="https://www.linkedin.com/pulse/huggingface-smolagents-fast-lightweight-llm-agents-powered-mishra-v5sxc/">HuggingFace SmolAgents</a></li><li><a href="https://modelcontextprotocol.io/">MCP Official Documentation</a></li></ol>]]></content>
    
    
    <summary type="html">本文深入探讨了MCP Output Schema在数据验证、安全保障和结构化输出方面的核心价值，分析了LLM处理结构化数据的局限性，并提出了基于单一职责原则的Schema设计最佳实践，为构建可靠的AI代理系统提供技术指导。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="MCP" scheme="https://edison-a-n.github.io/tags/MCP/"/>
    
  </entry>
  
  <entry>
    <title>停止转换REST API到MCP：设计AI原生接口的正确方式</title>
    <link href="https://edison-a-n.github.io/2025/09/29/stop-converting-rest-api-to-mcp/"/>
    <id>https://edison-a-n.github.io/2025/09/29/stop-converting-rest-api-to-mcp/</id>
    <published>2025-09-28T16:00:00.000Z</published>
    <updated>2025-10-21T01:09:36.322Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由AI生成</div><h3 id="为什么开发者想要转换REST-API到MCP"><a href="#为什么开发者想要转换REST-API到MCP" class="headerlink" title="为什么开发者想要转换REST API到MCP"></a>为什么开发者想要转换REST API到MCP</h3><p>随着AI代理的兴起，许多开发者面临一个现实需求：如何让现有的REST API能够被LLM直接使用。这催生了各种自动转换工具，如 <a href="https://github.com/tadata-org/fastapi_mcp">fastapi_mcp</a> 和 <a href="https://gofastmcp.com/integrations/fastapi#mounting-an-mcp-server">FastMCP 的 <code>from_openapi()</code> 功能</a>，它们基于 OpenAPI 规范自动将 Web API 转换为符合 MCP Tool 规范的接口。</p><p>这种转换看似便利，但实际上存在根本性问题。</p><h3 id="自动转换的陷阱"><a href="#自动转换的陷阱" class="headerlink" title="自动转换的陷阱"></a>自动转换的陷阱</h3><p>正如 Jeremiah Lowin 在 <a href="https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp">Stop Converting Your REST APIs to MCP</a> 一文中指出的，”为人类构建的 API 会毒害你的 AI 代理”。自动转换工具虽然方便，但存在以下根本性问题：</p><h4 id="1-上下文污染"><a href="#1-上下文污染" class="headerlink" title="1. 上下文污染"></a>1. 上下文污染</h4><ul><li><strong>Token成本</strong>：LLM 必须处理每个工具的名称、描述和参数，每个端点都是需要支付token和延迟成本的税</li><li><strong>认知负担</strong>：过多的工具选择会淹没LLM的决策能力</li><li><strong>无关内容干扰</strong>：人类开发者擅长发现并忽略无关内容，但LLM会被过多的选择淹没</li></ul><h4 id="2-原子性反模式"><a href="#2-原子性反模式" class="headerlink" title="2. 原子性反模式"></a>2. 原子性反模式</h4><ul><li><strong>昂贵往返</strong>：每个工具调用都是昂贵的往返过程</li><li><strong>链式调用问题</strong>：强制代理链式调用多个原子调用既缓慢又容易出错</li><li><strong>状态管理复杂</strong>：多个原子操作之间的状态同步变得困难</li></ul><h4 id="3-选择过载"><a href="#3-选择过载" class="headerlink" title="3. 选择过载"></a>3. 选择过载</h4><ul><li><strong>决策瘫痪</strong>：过多的工具选择导致LLM难以做出最优决策</li><li><strong>性能下降</strong>：选择过载会显著影响响应时间和准确性</li><li><strong>维护困难</strong>：复杂的工具集合难以维护和调试</li></ul><h3 id="传统API设计与AI原生接口的根本差异"><a href="#传统API设计与AI原生接口的根本差异" class="headerlink" title="传统API设计与AI原生接口的根本差异"></a>传统API设计与AI原生接口的根本差异</h3><h4 id="设计理念的差异"><a href="#设计理念的差异" class="headerlink" title="设计理念的差异"></a>设计理念的差异</h4><p><strong>传统REST API设计</strong>：</p><ul><li>面向人类开发者</li><li>强调资源导向</li><li>支持复杂的查询和过滤</li><li>提供丰富的元数据</li></ul><p><strong>AI原生MCP接口设计</strong>：</p><ul><li>面向LLM代理</li><li>强调任务导向</li><li>简化输入输出</li><li>最小化认知负担</li></ul><h4 id="交互模式的差异"><a href="#交互模式的差异" class="headerlink" title="交互模式的差异"></a>交互模式的差异</h4><p><strong>人类交互模式</strong>：</p><ul><li>可以处理复杂的UI交互</li><li>能够理解上下文和隐含信息</li><li>可以处理多步骤的复杂流程</li><li>能够从错误中学习和调整</li></ul><p><strong>AI交互模式</strong>：</p><ul><li>需要明确的指令和参数</li><li>依赖结构化的输入输出</li><li>难以处理复杂的多步骤流程</li><li>对错误和异常处理要求更高</li></ul><h3 id="存量API适配的现实挑战"><a href="#存量API适配的现实挑战" class="headerlink" title="存量API适配的现实挑战"></a>存量API适配的现实挑战</h3><h4 id="1-处理逻辑依赖前端交互"><a href="#1-处理逻辑依赖前端交互" class="headerlink" title="1. 处理逻辑依赖前端交互"></a>1. 处理逻辑依赖前端交互</h4><p>大多数传统API设计面向客户端交互，具有以下特点：</p><ul><li><strong>业务逻辑耦合</strong>：处理逻辑严重依赖前端交互模式，不适合 LLM 直接使用</li><li><strong>客户端集成复杂</strong>：客户端集成复杂度极高，难以直接交给 LLM 思考并使用</li><li><strong>缺乏清晰映射</strong>：缺乏清晰的资源-行为映射关系，增加了 LLM 的理解复杂度</li></ul><h4 id="2-RESTful设计的一致性问题"><a href="#2-RESTful设计的一致性问题" class="headerlink" title="2. RESTful设计的一致性问题"></a>2. RESTful设计的一致性问题</h4><p>即使是公开API，如果无法保证：</p><ul><li><strong>资源行为分离</strong>：资源(resource)和行为(action)的清晰分离</li><li><strong>URI设计一致性</strong>：比如 resource&#x2F;<id>&#x2F;action与action&#x2F;resource混用，即使是细微差别也会提高LLM的理解复杂度</li><li><strong>统一错误处理</strong>：统一的错误处理和状态码机制</li></ul><p>都会显著增加LLM理解和使用API的难度，进而造成call API错误。</p><h3 id="正确的设计方式：从代理故事-Agent-Story-开始"><a href="#正确的设计方式：从代理故事-Agent-Story-开始" class="headerlink" title="正确的设计方式：从代理故事(Agent Story)开始"></a>正确的设计方式：从代理故事(Agent Story)开始</h3><h4 id="1-引导而非部署"><a href="#1-引导而非部署" class="headerlink" title="1. 引导而非部署"></a>1. 引导而非部署</h4><p>基于 Jeremiah Lowin 的观点，自动转换工具应该遵循以下原则：</p><ul><li><strong>快速探索</strong>：使用自动转换功能进行快速探索和内部演示</li><li><strong>不要部署到生产</strong>：避免将转换后的API直接部署到生产环境</li><li><strong>学习工具</strong>：将转换作为学习和理解现有API的工具</li></ul><h4 id="2-积极策划"><a href="#2-积极策划" class="headerlink" title="2. 积极策划"></a>2. 积极策划</h4><p>将策划作为构建代理的核心部分：</p><ul><li><strong>创建新版本</strong>：使用转换功能创建新的LLM友好版本</li><li><strong>重新设计</strong>：基于AI代理的需求重新设计接口</li><li><strong>优化体验</strong>：专注于提升AI代理的使用体验</li></ul><h4 id="3-从代理故事开始"><a href="#3-从代理故事开始" class="headerlink" title="3. 从代理故事开始"></a>3. 从代理故事开始</h4><p>为关键工作流构建新的最小化MCP服务器：</p><ul><li><strong>需求驱动</strong>：从代理需求出发而非API规范</li><li><strong>任务导向</strong>：围绕具体任务设计接口</li><li><strong>简化设计</strong>：避免过度复杂的功能设计</li></ul><h3 id="设计AI原生MCP接口的最佳实践"><a href="#设计AI原生MCP接口的最佳实践" class="headerlink" title="设计AI原生MCP接口的最佳实践"></a>设计AI原生MCP接口的最佳实践</h3><h4 id="1-直接构建MCP原生服务"><a href="#1-直接构建MCP原生服务" class="headerlink" title="1. 直接构建MCP原生服务"></a>1. 直接构建MCP原生服务</h4><ul><li><strong>避免中间层</strong>：直接构建符合MCP规范的HTTP服务，避免搭建web API再套壳</li><li><strong>协议层面考虑</strong>：从协议层面考虑LLM的使用模式</li><li><strong>AI代理优化</strong>：建立专门为AI代理优化的接口设计</li></ul><h4 id="2-持续优化"><a href="#2-持续优化" class="headerlink" title="2. 持续优化"></a>2. 持续优化</h4><ul><li><strong>性能监控</strong>：监控接口的使用性能和成功率</li><li><strong>用户反馈</strong>：收集AI代理使用过程中的反馈</li><li><strong>迭代改进</strong>：基于使用情况持续优化接口设计</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>AI代理的承诺不仅仅是让现有软件变得”健谈”，而是设计更简洁、更有意图、以机器为先的接口的机会。</p><p><strong>停止转换你的REST API，开始策划它们</strong>：从代理故事(Agent Story)开始，直接构建AI原生的MCP接口，而不是简单地将人类设计的API强加给AI系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp">Stop Converting Your REST APIs to MCP</a></li><li><a href="https://gofastmcp.com/integrations/fastapi#mounting-an-mcp-server">FastMCP FastAPI Integration</a></li><li><a href="https://github.com/tadata-org/fastapi_mcp">fastapi_mcp</a></li><li><a href="https://modelcontextprotocol.io/">MCP Official Documentation</a></li></ol>]]></content>
    
    
    <summary type="html">本文分析了自动转换REST API到MCP的陷阱和问题，探讨了传统API设计与AI原生接口的根本差异，提出了从代理故事开始设计、遵循单一职责原则等最佳实践，为构建真正适合AI代理的接口提供设计指导。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="MCP" scheme="https://edison-a-n.github.io/tags/MCP/"/>
    
    <category term="API Design" scheme="https://edison-a-n.github.io/tags/API-Design/"/>
    
  </entry>
  
  <entry>
    <title>大型语言模型在处理大批量数据时的一致性挑战与解决方案</title>
    <link href="https://edison-a-n.github.io/2025/09/20/llm-consistency-challenges-large-data-processing/"/>
    <id>https://edison-a-n.github.io/2025/09/20/llm-consistency-challenges-large-data-processing/</id>
    <published>2025-09-20T09:12:33.000Z</published>
    <updated>2025-10-21T01:08:34.077Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由AI生成</div><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大型语言模型（LLM）在处理大批量数据时面临着显著的一致性挑战。这些挑战主要源于LLM的注意力机制和上下文窗口的限制，导致在处理复杂数据任务时可能出现不一致、幻觉等问题。本文将深入探讨这些挑战及其解决方案。</p><h2 id="LLM的一致性挑战"><a href="#LLM的一致性挑战" class="headerlink" title="LLM的一致性挑战"></a>LLM的一致性挑战</h2><h3 id="1-🌀-前后不一致性"><a href="#1-🌀-前后不一致性" class="headerlink" title="1. 🌀 前后不一致性"></a>1. 🌀 前后不一致性</h3><p>LLM在处理过程中可能忘记之前的操作，导致结果不连贯。这种问题在处理需要多步推理或长期记忆的任务时尤为明显。</p><h3 id="2-🎭-幻觉问题"><a href="#2-🎭-幻觉问题" class="headerlink" title="2. 🎭 幻觉问题"></a>2. 🎭 幻觉问题</h3><p>模型可能生成与实际数据不符的内容，产生所谓的”幻觉”现象。这在数据密集型应用中可能导致严重的错误。</p><h3 id="3-📏-上下文溢出"><a href="#3-📏-上下文溢出" class="headerlink" title="3. 📏 上下文溢出"></a>3. 📏 上下文溢出</h3><p>当输入数据超过模型的上下文窗口时，模型无法有效处理全部信息，导致数据被截断或忽略。</p><h3 id="4-🧠-无状态性"><a href="#4-🧠-无状态性" class="headerlink" title="4. 🧠 无状态性"></a>4. 🧠 无状态性</h3><p>LLM缺乏内置的记忆机制，无法追踪已处理的数据项或状态，这使得持续性的数据处理任务变得困难。</p><h2 id="解决方案与策略"><a href="#解决方案与策略" class="headerlink" title="解决方案与策略"></a>解决方案与策略</h2><h3 id="1-🤝-LLM与外部工具结合"><a href="#1-🤝-LLM与外部工具结合" class="headerlink" title="1. 🤝 LLM与外部工具结合"></a>1. 🤝 LLM与外部工具结合</h3><p>让LLM负责决策和流程控制，而将具体的数据操作交由专门的完成。这种分工明确的架构能够充分发挥各自的优势。</p><h3 id="2-📚-使用索引系统管理数据"><a href="#2-📚-使用索引系统管理数据" class="headerlink" title="2. 📚 使用索引系统管理数据"></a>2. 📚 使用索引系统管理数据</h3><p>将大批量数据存储并索引化，LLM通过引用索引来访问数据，而不直接处理数据内容。这种方法有效解决了上下文窗口的限制问题。</p><h3 id="3-🔄-采用工作流（Workflow）模式"><a href="#3-🔄-采用工作流（Workflow）模式" class="headerlink" title="3. 🔄 采用工作流（Workflow）模式"></a>3. 🔄 采用工作流（Workflow）模式</h3><p>LLM生成操作指令或代码片段，由外部环境执行，并将结果反馈给LLM。这种迭代式的处理方式确保了数据处理的准确性和一致性。</p><h3 id="4-📊-优化元数据设计"><a href="#4-📊-优化元数据设计" class="headerlink" title="4. 📊 优化元数据设计"></a>4. 📊 优化元数据设计</h3><p>精心设计数据的metadata结构，包括数据类型、关系描述、时间戳、来源信息等。良好的元数据不仅帮助LLM更好地理解数据，还能提高检索效率和准确性，减少幻觉和不一致问题的发生。</p><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><h3 id="🦙-LlamaIndex"><a href="#🦙-LlamaIndex" class="headerlink" title="🦙 LlamaIndex"></a>🦙 LlamaIndex</h3><p>该项目将文档或数据索引化，LLM负责查询计划与任务调度，数据的读写由外部工具完成。这种架构设计有效分离了逻辑控制和数据操作。</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/run-llama/llama_index">https://github.com/run-llama/llama_index</a></li></ul><h3 id="🤖-AutoGPT"><a href="#🤖-AutoGPT" class="headerlink" title="🤖 AutoGPT"></a>🤖 AutoGPT</h3><p>LLM作为”指挥官”，调用外部工具（如文件系统、API、数据库）完成任务，避免直接操作数据。这种模式在处理复杂任务时表现出色。</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/Significant-Gravitas/AutoGPT">https://github.com/Significant-Gravitas/AutoGPT</a></li></ul><h3 id="🐍-smolagent"><a href="#🐍-smolagent" class="headerlink" title="🐍 smolagent"></a>🐍 smolagent</h3><p>LLM生成Python脚本，由沙箱环境执行，LLM仅负责逻辑控制。这种方法确保了数据处理的准确性和安全性。</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/microsoft/smolagent">https://github.com/microsoft/smolagent</a></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过将LLM与外部工具结合、使用索引系统管理数据以及采用工作流模式，我们可以有效提升LLM在处理大批量数据时的一致性和可靠性。这些解决方案不仅解决了LLM的内在限制，还为构建更强大、更可靠的AI系统提供了可行的路径。</p><p>未来，随着技术的不断发展，我们期待看到更多创新的方法来进一步优化LLM在数据处理方面的表现，推动人工智能技术在各个领域的深入应用。</p>]]></content>
    
    
    <summary type="html">本文探讨了LLM在处理大批量数据时面临的前后不一致性、幻觉问题、上下文溢出和无状态性等挑战，并提出了LLM与外部工具结合、使用索引系统管理数据、采用工作流模式等解决方案。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
  </entry>
  
  <entry>
    <title>nextjs-pagination</title>
    <link href="https://edison-a-n.github.io/2024/02/01/nextjs-pagination/"/>
    <id>https://edison-a-n.github.io/2024/02/01/nextjs-pagination/</id>
    <published>2024-02-01T09:11:31.000Z</published>
    <updated>2025-09-20T05:45:32.528Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node: v20.11.0</span><br><span class="line">npm: 10.2.4</span><br><span class="line">next: 14.1.0</span><br></pre></td></tr></table></figure><h2 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app</span><br></pre></td></tr></table></figure><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a><a href="https://nextjs.org/docs/app/building-your-application/rendering/client-components">客户端渲染</a></h2><ul><li>客户端渲染要求自身及子组件都是客户端渲染，即都需要上声明 <code>&#39;use client&#39;</code></li><li><code>state</code> 触发整个 DOM 重新渲染，所以使用必须是客户端渲染</li><li>客户端重新渲染，页面内容也要更新，所以描述页面的 DOM 也被当作客户端渲染组件，也需要声明 <code>&#39;use client&#39;</code>; 所以该组件不能以 <a href="https://react.dev/learn/passing-props-to-a-component">children</a> 组件传入。</li></ul><p>理解了客户端渲染的方式，就可以很容易的实现分页了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/page.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; cache &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PaginatedData</span>, <span class="title class_">Pagination</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./pagination&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getData = <span class="title function_">cache</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;c&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;d&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="string">&#x27;e&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">name</span>: <span class="string">&#x27;f&#x27;</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">getData</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Pagination</span> <span class="attr">data</span>=<span class="string">&#123;data.data&#125;</span> <span class="attr">itemsPerPage</span>=<span class="string">&#123;2&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">paginationEle</span>=<span class="string">&#123;PaginatedData&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/pagination.tsx</span></span><br><span class="line"><span class="comment">// 由 GPT-4 自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;use client&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Pagination</span>(<span class="params">&#123; data, itemsPerPage, paginationEle &#125;: &#123;</span></span><br><span class="line"><span class="params">    data: <span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params">    itemsPerPage: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">    paginationEle: (data: <span class="built_in">any</span>[]) =&gt; JSX.Element</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [currentPage, setCurrentPage] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxPage = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(data.<span class="property">length</span> / itemsPerPage) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> start = currentPage * itemsPerPage</span><br><span class="line">    <span class="keyword">const</span> end = start + itemsPerPage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;paginationEle(data.slice(start, end))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex justify-between my-4 space-x-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">disabled</span>=<span class="string">&#123;currentPage</span> === <span class="string">0&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentPage(currentPage - 1)&#125;</span></span><br><span class="line"><span class="language-xml">                    className=&#123;`px-4 py-2 rounded shadow $&#123;currentPage === 0 ? &#x27;bg-gray-300&#x27; : &#x27;bg-gray-500 hover:bg-gray-700&#x27;&#125; text-white`&#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                    Previous</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">disabled</span>=<span class="string">&#123;currentPage</span> === <span class="string">maxPage&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentPage(currentPage + 1)&#125;</span></span><br><span class="line"><span class="language-xml">                    className=&#123;`px-4 py-2 rounded shadow $&#123;currentPage === maxPage ? &#x27;bg-gray-300&#x27; : &#x27;bg-gray-500 hover:bg-gray-700&#x27;&#125; text-white`&#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                    Next</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">PaginatedData</span>(<span class="params">data: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.id&#125;: &#123;item.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>smart-contract-demo</title>
    <link href="https://edison-a-n.github.io/2023/09/20/smart-contract-demo/"/>
    <id>https://edison-a-n.github.io/2023/09/20/smart-contract-demo/</id>
    <published>2023-09-20T05:43:19.000Z</published>
    <updated>2025-09-20T05:45:32.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建一个DAPP的demo"><a href="#构建一个DAPP的demo" class="headerlink" title="构建一个DAPP的demo"></a>构建一个DAPP的demo</h1><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.dappuniversity.com/articles/how-to-build-a-blockchain-app">How To Build A Blockchain App with Ethereum, Web3.js &amp; Solidity Smart Contracts</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构建一个DAPP的demo&quot;&gt;&lt;a href=&quot;#构建一个DAPP的demo&quot; class=&quot;headerlink&quot; title=&quot;构建一个DAPP的demo&quot;&gt;&lt;/a&gt;构建一个DAPP的demo&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多租户应用与架构设计关注点</title>
    <link href="https://edison-a-n.github.io/2023/08/30/multi-tenant/"/>
    <id>https://edison-a-n.github.io/2023/08/30/multi-tenant/</id>
    <published>2023-08-29T23:12:32.000Z</published>
    <updated>2025-09-20T05:45:32.528Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇是关于多租户应用与架构设计关注点的一些自己的思考。本篇强调多租户本质是支持共享与隔离。同时提到应用架构可能的形式以及多租户集成的设计。核心的关注点强调了对业务未来长期的判断决定了隔离粒度，最终决定了业务应用的产品架构与技术架构设计。 本篇更多是提供一些启发，供商业规划、业务负责人、技术解决方案提供方在做多租户集成时，进行参考。本篇不作为多租户服务提供者的设计建议。</p></blockquote><h1 id="什么是多租户"><a href="#什么是多租户" class="headerlink" title="什么是多租户"></a>什么是多租户</h1><p>多租户是一种实现资源共享与隔离的架构。</p><h2 id="一、共享"><a href="#一、共享" class="headerlink" title="一、共享"></a>一、共享</h2><p><strong>用户不可直接触达的资源必然是共享。</strong></p><ul><li>共享是为降本增效，最重要还是为了增效。</li><li>计算资源有效运行时间</li><li>存储空间有效利用</li><li>降低应用维护、多集群维护、观测系统搭建、维护人员投入等成本</li></ul><p>有的服务可能不允许共享</p><ul><li>数据安全考虑，要求强隔离，比如独立的存储、独立的数据库、独立的计算集群、网络访问限制只允许在一个孤岛中计算</li><li>私有化部署，所有组件都在自己的运行环境中 这种情况下，多租户的解决方案要解决的问题并不存在。</li></ul><blockquote><p><strong>可以这么说，如果没有共享资源的需求和架构设计，完全不需要应用多租户。</strong></p></blockquote><h2 id="二、隔离"><a href="#二、隔离" class="headerlink" title="二、隔离"></a>二、隔离</h2><p><strong>共享架构下，用户访问需要一个逻辑隔离的环境。</strong></p><ul><li>计算资源隔离：集群配额，计算资源使用优先级，独占集群，用户自主提供的集群</li><li>存储资源隔离：逻辑路径(Unix路径)&#x2F;逻辑库&#x2F;逻辑服务，存储服务使用不互相干扰（某个租户大量请求造成存储服务触及峰值不影响其他租户使用），</li><li>网络资源隔离：带宽使用</li></ul><h1 id="核心关注点"><a href="#核心关注点" class="headerlink" title="核心关注点"></a>核心关注点</h1><h2 id="一、SAAS-尽早做多租户设计规划"><a href="#一、SAAS-尽早做多租户设计规划" class="headerlink" title="一、SAAS 尽早做多租户设计规划"></a>一、SAAS 尽早做多租户设计规划</h2><p>越早规划，越早预留扩展能力。</p><p>一旦自研服务设计不合适，业务逻辑耦合了应用内部的用户和权限，后期只能被当做第三方服务接入。这种情形下隔离和共享难支持，可能会被迫为每个租户提供单独的部署与维护支持。</p><h2 id="二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定"><a href="#二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定" class="headerlink" title="二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定"></a>二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定</h2><p>隔离粒度决定了用户看到的资源是什么样的。</p><p>举例来讲，一个果园由多个人承包，按地隔离，拥有者就会盯着土地划界；按拥有多少果树隔离，拥有者就会算着自己的果树；按产出的斤两隔离，拥有者只会盯着最后的果实。</p><p>所以隔离粒度，是业务决定的，是商业模式销售模式决定的，最终由技术架构实现支持。 技术架构往往落地之后会运行相当一段时间。隔离粒度的决策，需要对长期的业务发展方向进行评估。</p><h2 id="三、Access-层是核心处理多租户信息的组件，Business-层是对多租户的实现"><a href="#三、Access-层是核心处理多租户信息的组件，Business-层是对多租户的实现" class="headerlink" title="三、Access 层是核心处理多租户信息的组件，Business 层是对多租户的实现"></a>三、Access 层是核心处理多租户信息的组件，Business 层是对多租户的实现</h2><p>当你已经意识到并且早早地开始做多租户设计，当你已经对隔离粒度有一个比较明确的方向判断，就要开始对分层做设计和实现了。 最基本的设计是两层，</p><ul><li>Access 层负责支持验证和访问控制，生成 tenant 的 info 信息。</li><li>Business 层只依赖 tenant_id，不做其他的耦合。</li></ul><p><img src="/../images/tenant.png" alt="示例图"></p><h1 id="补充关注点"><a href="#补充关注点" class="headerlink" title="补充关注点"></a>补充关注点</h1><h2 id="一、微服务架构下，访问各个服务与资源的方式"><a href="#一、微服务架构下，访问各个服务与资源的方式" class="headerlink" title="一、微服务架构下，访问各个服务与资源的方式"></a>一、微服务架构下，访问各个服务与资源的方式</h2><ol><li><p>直接访问</p></li><li><p>Access 层会申请访问需要的资源的 <code>access_token</code></p></li><li><p>租户会分配到一个 <code>tenant_id</code> 并携带一些 metadata 信息, <code>OIDC</code> 协议的 <code>token</code> 可以解析出来</p></li><li><p>代理租户访问资源与服务</p></li></ol><p>这种模式相当于有一个agent，负责带着租户去访问各种资源，本质上还是租户自己在访问。同时，这种模式要求 agent 有自己的认证与访问控制判断实现，并且可以联通租户管理系统执行租户的验证。</p><ul><li><p>agent由于取得了资源代理人的资格，得到了服务提供者的信任，也拥有足够的权限，可以直接访问一部分资源，减少一些鉴权工作。</p></li><li><p>对于部分安全要求高的资源访问，仍然需要校验租户的权限，形式可能从<code>access_token</code>中解析，也可能拿着 <code>tenant_id</code> 去租户中心校验</p></li><li><p>租户只是一个标签</p><ul><li>强化 agent 的能力，弱化 tenant 的能力。</li><li>agent 相当于拿着一个 tenant_id 标识走一遍整个服务，并对资源访问做标签操作。 这时候的 agent 可以不理会 tenant 的任何实现。</li><li>要求 agent 对 tenant 有极高的信任；</li><li>要求访问的服务支持 agent 访问</li></ul></li></ul><h2 id="二、多租户服务提供者可能需要提供什么"><a href="#二、多租户服务提供者可能需要提供什么" class="headerlink" title="二、多租户服务提供者可能需要提供什么"></a>二、多租户服务提供者可能需要提供什么</h2><ol><li>用户、用户组多级管理</li><li>支持虚拟用户、用户灵活分组。</li><li>支持将组当做一个租户</li><li>支持一个真实用户可以拥有多个不同的租户身份</li><li>强大的配置能力 支持业务应用将各类权限数据灵活的配置到多租户服务提供者上</li></ol><p>所以在做选型的时候，需要一并评估业务对多租户服务提供者长周期扩展能力的需求，以最终决定选用什么服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇是关于多租户应用与架构设计关注点的一些自己的思考。本篇强调多租户本质是支持共享与隔离。同时提到应用架构可能的形式以及多租户集成的设计。核心的关注点强调了对业务未来长期的判断决定了隔离粒度，最终决定了业务应用的产品架构与技术架构设计。 本篇更多是</summary>
      
    
    
    
    
    <category term="multi-tenant" scheme="https://edison-a-n.github.io/tags/multi-tenant/"/>
    
  </entry>
  
  <entry>
    <title>go-ddd</title>
    <link href="https://edison-a-n.github.io/2022/12/13/go-ddd/"/>
    <id>https://edison-a-n.github.io/2022/12/13/go-ddd/</id>
    <published>2022-12-13T06:43:04.000Z</published>
    <updated>2025-09-20T05:45:32.527Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-internal-规划工程目录"><a href="#基于-internal-规划工程目录" class="headerlink" title="基于 internal 规划工程目录"></a>基于 <code>internal</code> 规划工程目录</h1><p><a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit">Go internal package design</a>介绍了设计的原因</p><blockquote><p>Go encourages structuring a program as a collection of packages interacting using exported APIs. However, all packages can be imported. This creates a tension when implementing a library or command: it may grow large enough to structure as multiple packages, but splitting it would export the API used in those additional packages to the world. Being able to create packages with restricted visibility would eliminate this tension.</p></blockquote><p>一个大的 <code>GO</code> 工程自然会含有大量的模块，我们会从拆分不同的 <code>.go</code> 文件到拆分不同的 <code>package</code>。一旦拆多个 <code>package</code> 就会遇到不得不把一些 <code>API</code> 和 <code>struct</code> 暴露出去的需求。<code>internal</code> 很好的解决了必须拆分 <code>package</code> 但是又希望相关的 <code>package</code> 只在当前工程中应用的问题。</p><p>基于这样的设计，我们可以将一个 <code>Domain Context</code> 目录设计成如下的样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- module</span><br><span class="line">|- internal</span><br><span class="line">   |- domain</span><br><span class="line">      |- entity</span><br><span class="line">      |- value_obj</span><br><span class="line">      |- repo</span><br><span class="line">      |- service</span><br><span class="line">|- facade</span><br><span class="line">|- app</span><br><span class="line">|- utils</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure><h2 id="app"><a href="#app" class="headerlink" title="app"></a><strong>app</strong></h2><p><code>app</code> 即<code>应用服务</code>，在 <code>DDD</code> 中是编排<code>领域对象</code>和<code>领域服务</code>的模块。在实现中，通常是负责实现 <code>HTTP框架</code> 的对应 <code>Handler</code></p><h1 id="DTO、PO-与-Entity"><a href="#DTO、PO-与-Entity" class="headerlink" title="DTO、PO 与 Entity"></a>DTO、PO 与 Entity</h1><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a><strong>DTO</strong></h2><p><code>DTO</code> 通常指的是请求传入 <code>app</code> 的数据，在<a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化反序列化 - 美团</a>中介绍了分层与实现。在 <code>WEB API</code> 中通常使用 <code>Rest</code> 风格，配合使用的是 <code>json</code> 进行序列化。而 <code>RPC</code> 风格的 <code>API</code> 则除了 <code>json</code> 外，也会使用 <code>protobuf</code> 等进行序列化。</p><h2 id="PO"><a href="#PO" class="headerlink" title="PO"></a><strong>PO</strong></h2><p><code>PO</code> 也是 <code>MVC</code> 常遇到的数据对象，英文是 <code>Persistent Object</code>。一般是在与数据库（MySQL 或者 MongoDB）交互的数据对象，会作为数据库模型的数据映射。</p><p>数据映射，一般有两种形式：</p><ul><li><strong><a href="https://en.wikipedia.org/wiki/Active_record_pattern">Active Record</a></strong>: 包含了数据和数据处理方法</li><li><strong><a href="https://en.wikipedia.org/wiki/Data_mapper_pattern">Data Mapper</a></strong>: 仅取出数据，并在内存模型中存储数据</li></ul><p><strong>本质上是将数据序列化封装在<code>ORM</code>库中</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>通常，<code>DTO</code> 需要重新定义 <code>struct</code>，对于使用 <code>json</code> 进行序列化的实现，则需在实现 <code>Request</code> 来做请求数据的 binding 与 validation。对于使用 <code>protobuf</code> 进行序列化的实现，则代码生成工具会帮助生成对应的对象。</li><li><code>Entity</code> 是领域中流转的对象，需要尽可能保持自身的独立。</li><li><code>PO</code> 一般仅在 <code>Repo</code> 中使用，根据 <code>Repo</code> 使用的 <code>ORM</code> 做设计。对于直接由 <code>Entity</code> 映射的数据模型，则可以使用 <em>结构体组合(此时，<code>Entity</code> 通常也需要定义一些 <code>ORM</code> 需要的 <code>tag</code>)</em> 。复杂的 <code>PO</code> 需要重新定义并转化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-internal-规划工程目录&quot;&gt;&lt;a href=&quot;#基于-internal-规划工程目录&quot; class=&quot;headerlink&quot; title=&quot;基于 internal 规划工程目录&quot;&gt;&lt;/a&gt;基于 &lt;code&gt;internal&lt;/code&gt; 规划工程目录&lt;</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://edison-a-n.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>使用 `git pull --rebase`</title>
    <link href="https://edison-a-n.github.io/2022/12/07/git-rebase/"/>
    <id>https://edison-a-n.github.io/2022/12/07/git-rebase/</id>
    <published>2022-12-07T02:45:07.000Z</published>
    <updated>2025-09-20T05:45:32.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git-rebase"></a>git-rebase</h3><p>使用 <code>git pull</code> 的时候，要加上 <code>--rebase</code>，减少merge，保持 <code>log</code> 整洁</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/a/3357174">git rebase</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git-rebase&quot;&gt;&lt;/a&gt;git-rebase&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;git pull&lt;/code&gt; 的时候，要加上 &lt;code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>opnetelemetry-jaeger</title>
    <link href="https://edison-a-n.github.io/2022/12/03/opentelemetry-jaeger/"/>
    <id>https://edison-a-n.github.io/2022/12/03/opentelemetry-jaeger/</id>
    <published>2022-12-03T07:43:31.000Z</published>
    <updated>2025-09-20T05:45:32.529Z</updated>
    
    <content type="html"><![CDATA[<p>在调研中，持续更新本篇 …</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><hr><h2 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>此处只介绍使用中会遇到的概念，具体细节请查阅<a href="https://opentelemetry.io/docs/reference/specification/trace/">文档</a></p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li><p><strong><a href="https://opentelemetry.io/docs/reference/specification/trace/api/#tracerprovider">TracerProvider</a></strong> 提供访问 Tracer 的入口。作为一个池子放置和管理 <code>Tracer</code>s</p></li><li><p><strong><a href="https://opentelemetry.io/docs/reference/specification/trace/sdk/#span-exporter">Span Exporter</a></strong> 定义一系列接口，执行 telemetry data 的序列化与反序列化，以将数据提交到不同的 backend。</p></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><hr><h2 id="Tracing-1"><a href="#Tracing-1" class="headerlink" title="Tracing"></a>Tracing</h2><p>根据其架构设计，所有的应用都可以实现为：</p><ol><li>定义 Resource</li><li>创建 Provider</li><li>设置全局 Provider (option)</li><li>设置 Exporter (option)</li><li>server 中使用 Tracing</li></ol><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> opentelemetry <span class="keyword">import</span> trace</span><br><span class="line"><span class="keyword">from</span> opentelemetry.exporter.jaeger.thrift <span class="keyword">import</span> JaegerExporter</span><br><span class="line"><span class="keyword">from</span> opentelemetry.sdk.resources <span class="keyword">import</span> SERVICE_NAME, Resource</span><br><span class="line"><span class="keyword">from</span> opentelemetry.sdk.trace <span class="keyword">import</span> TracerProvider</span><br><span class="line"><span class="keyword">from</span> opentelemetry.sdk.trace.export <span class="keyword">import</span> BatchSpanProcessor</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> opentelemetry.propagate <span class="keyword">import</span> set_global_textmap</span><br><span class="line"><span class="keyword">from</span> opentelemetry.propagators.jaeger <span class="keyword">import</span> JaegerPropagator</span><br><span class="line"></span><br><span class="line">APP_NAME = <span class="string">&quot;app&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    init_provider()</span><br><span class="line"></span><br><span class="line">    set_global_textmap(JaegerPropagator())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_provider</span>():</span><br><span class="line"></span><br><span class="line">    trace.set_tracer_provider(</span><br><span class="line">        TracerProvider(</span><br><span class="line">            resource=Resource.create(&#123;SERVICE_NAME: APP_NAME&#125;)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    jaeger_exporter = JaegerExporter()</span><br><span class="line">    trace.get_tracer_provider().add_span_processor(</span><br><span class="line">        BatchSpanProcessor(jaeger_exporter)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>常用的 package 如 <code>Flask</code>, <code>Django</code>, <code>FastAPI</code>, <code>psycopg2</code> 等都有提供 <code>instrument</code>, 实现基于AOP的注入。</p><p><strong>Golang</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;go.opentelemetry.io/otel&quot;</span></span><br><span class="line">    <span class="string">&quot;go.opentelemetry.io/otel/exporters/jaeger&quot;</span></span><br><span class="line">    <span class="string">&quot;go.opentelemetry.io/otel/sdk/resource&quot;</span></span><br><span class="line">    sdktrace <span class="string">&quot;go.opentelemetry.io/otel/sdk/trace&quot;</span></span><br><span class="line">    semconv <span class="string">&quot;go.opentelemetry.io/otel/semconv/v1.10.0&quot;</span></span><br><span class="line">    jaegerpropagator <span class="string">&quot;go.opentelemetry.io/contrib/propagators/jaeger&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_NAME := <span class="string">&quot;app&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGlobalProvider</span><span class="params">()</span></span> *sdktrace.TracerProvider &#123;</span><br><span class="line">    p, e := tracerProvider()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    otel.SetTracerProvider(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tracerProvider</span><span class="params">(url <span class="type">string</span>)</span></span> (*sdktrace.TracerProvider, <span class="type">error</span>) &#123;</span><br><span class="line">    serviceName := APP_NAME</span><br><span class="line"></span><br><span class="line">    exp, err := jaeger.New(jaeger.WithAgentEndpoint())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp := sdktrace.NewTracerProvider(</span><br><span class="line">        <span class="comment">// Always be sure to batch in production.</span></span><br><span class="line">        sdktrace.WithBatcher(exp),</span><br><span class="line">        <span class="comment">// Record information about this application in a Resource.</span></span><br><span class="line">        sdktrace.WithResource(resource.NewWithAttributes(</span><br><span class="line">            semconv.SchemaURL,</span><br><span class="line">            semconv.ServiceNameKey.String(serviceName),</span><br><span class="line">        )),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> tp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGlobalPropagator</span><span class="params">()</span></span> propagation.TextMapPropagator &#123;</span><br><span class="line">    otel.SetTextMapPropagator(jaegerpropagator.Jaeger&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr><p><a href="https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html">Metrics, tracing, and logging</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在调研中，持续更新本篇 …&lt;/p&gt;
&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Tracing&quot;&gt;&lt;a href=&quot;#Tracing&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="可观测性" scheme="https://edison-a-n.github.io/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
    <category term="opentelemetry" scheme="https://edison-a-n.github.io/tags/opentelemetry/"/>
    
  </entry>
  
  <entry>
    <title>ddd-thinking</title>
    <link href="https://edison-a-n.github.io/2022/06/09/ddd-thinking/"/>
    <id>https://edison-a-n.github.io/2022/06/09/ddd-thinking/</id>
    <published>2022-06-09T04:26:18.000Z</published>
    <updated>2025-09-20T05:45:32.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DDD-关键概念"><a href="#DDD-关键概念" class="headerlink" title="DDD 关键概念"></a>DDD 关键概念</h3><h4 id="Domain-中的概念"><a href="#Domain-中的概念" class="headerlink" title="Domain 中的概念"></a>Domain 中的概念</h4><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>一个Domain独占一个Context。在Context中完成下述的一系列逻辑。在应用DDD中，最难的一步是，划定Context。将不同Domain的边界准确的描述清楚，对于抽象能力、业务理解准确性与未来预期的判断能力要求极高。边界划定的不好，也将难以保障内聚与耦合的合理性。</p><h5 id="Aggregate、Entity、Value-Object"><a href="#Aggregate、Entity、Value-Object" class="headerlink" title="Aggregate、Entity、Value Object"></a>Aggregate、Entity、Value Object</h5><p>将三者放在一起，是因为三者是一个包含关系，并对上层提供引用。在这些model中，会提供独占的attribute以及对应的对attribute的访问方法。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>对于一些无法由一个model完成执行的方法逻辑，可以通过service进行包装。service的设计取舍比较复杂，在<a href="#%E5%85%B3%E4%BA%8Edomain-service">后续章节中详说</a></p><h5 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h5><p>将Domain Event提前到这个位置提出，是因为，Event Driven模式在越来越的复杂应用中，会被使用。（不复杂的应用，也不建议使用DDD进行建模，增加了过多的实体反而提高了理解成本）。Domain Event主要应用于异步驱动其他Domain执行一些业务处理，其中也会涉及到复杂的事务处理与资源竞争访问的问题。相关话题与Event Driven模式相关，在这里不详述。</p><h5 id="Factory方法"><a href="#Factory方法" class="headerlink" title="Factory方法"></a>Factory方法</h5><p><code>Factory</code>方法用于创建一个对应的model（可能是一个Aggregate、Entity或者Value Object），并执行一些复杂的初始化操作。**<code>Factory</code>不用于从<code>Repository</code>重建model，重建应该将<code>Factory</code>创建的model的引用，作为参数传入<code>Repository</code>接口中，执行重建**</p><h5 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h5><p><code>Repository</code>用于将model写入到数据存储中以及从数据存储中重建model。数据存储可以是sql数据库或nosql数据库以及具有存储能力的MQ以及磁盘系统。<code>Repository</code>提供一系列interface来访问数据存储。</p><ul><li>写入和重建<br>创建、更新、重建model，都会将model传入<code>Repository</code>的<code>interface</code>中，<strong>这是因为，<code>Repository</code>也是属于Domain，属于Context，所以，Repository需要理解同一个Context中的model包含什么attribute，并将其映射写入到存储中或从存储中重建model。</strong></li><li>其他访问数据的方法<br>list是一个在DDD中没有提到，在实际业务中经常使用的数据访问形式，这一系列扩展的数据访问方法，可以通过扩展<code>Repository</code>的<code>interface</code>支持Domain的数据访问。</li></ul><h4 id="跨Domain的访问"><a href="#跨Domain的访问" class="headerlink" title="跨Domain的访问"></a>跨Domain的访问</h4><h5 id="Facade接口"><a href="#Facade接口" class="headerlink" title="Facade接口"></a>Facade接口</h5><p>使用Facade模式来避免跨Context直接调用内部方法，便于底层model的持续重构。</p><h3 id="关于domain-service"><a href="#关于domain-service" class="headerlink" title="关于domain service"></a>关于domain service</h3><p>什么样的业务逻辑会放在领域服务中，在DDD中没有具体说，这可能也受限于DDD提出的时代背景。后续的实践者，包括我自己，也只能通过举例来说明。我个人的理解是，对于Web应用中，pagination、validator、permission、serializer等模块，都可以使用service来进行处理。也就是说，service是一个大的package，其中会根据不同domain需求再做复杂的service拆分。这些service通常也是interface模式，传入model的引用执行一些数据处理或校验，并按需返回数据。</p><h3 id="DDD-在不同领域的应用"><a href="#DDD-在不同领域的应用" class="headerlink" title="DDD 在不同领域的应用"></a>DDD 在不同领域的应用</h3><p>DDD的提出，是为了解决Web应用开发中出现的大量贫血模型。在前后端分离架构中，后端越来越专注与数据模型与数据处理逻辑的设计与开发，并最终交付Rest API。客户端渲染模式交由前端完成。随着后端数据模型复杂度的提高，原有的M+V模式割裂了数据处理逻辑与数据模型，不利于持续维护和迭代开发。DDD的设计可以将数据与数据处理很好的融合起来，实现了高内聚低耦合。</p><p>高内聚低耦合在复杂度高的软件开发中是十分必要的，对于保障软件整体的可维护性与稳定可用有很大价值。<strong>DDD的设计则可用应用在这一系列软件设计中。</strong> 比如，通过对Context-Aggregate-Entity-ValueObj的模型层次设计，让数据模型更好理解，通过Factory方法来维护唯一创建入口让初始化更简单易理解。跨domain使用facade模式进行interface设计，也让模型之间的访问不会产生复杂的耦合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DDD-关键概念&quot;&gt;&lt;a href=&quot;#DDD-关键概念&quot; class=&quot;headerlink&quot; title=&quot;DDD 关键概念&quot;&gt;&lt;/a&gt;DDD 关键概念&lt;/h3&gt;&lt;h4 id=&quot;Domain-中的概念&quot;&gt;&lt;a href=&quot;#Domain-中的概念&quot; class</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://edison-a-n.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>mvc-and-ddd</title>
    <link href="https://edison-a-n.github.io/2022/05/23/mvc-and-ddd/"/>
    <id>https://edison-a-n.github.io/2022/05/23/mvc-and-ddd/</id>
    <published>2022-05-23T05:10:03.000Z</published>
    <updated>2025-09-20T05:45:32.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC与DDD比较-2022-05-23"><a href="#MVC与DDD比较-2022-05-23" class="headerlink" title="MVC与DDD比较(2022.05.23)"></a>MVC与DDD比较(2022.05.23)</h1><p>MVC与DDD其实并不是对立的。在MVC中，我们会在controller中执行一些校验逻辑，包含可能的鉴权、参数校验等。我们也会在view里面实现service，包含各种validator与serializer以及data transfer。</p><p>DDD拆解并丰富了MVC中的M，将一些在V中执行的逻辑迁移到M中，由domain model执行model内的业务处理，同时将DTO从M中剥离出来放到infrastructure中，借由其他的设计模式如repository或者CQRS等进行处理。</p><p>同时，DDD中依然会有一些业务操作无法在model中完成，这时候，借由domain service和application service来进行处理。其中，domain service执行数据间的判断与操作，application service则负责完整执行需要service与model与infrastructure协同的操作。application service面向client提供完整功能，domain service仅处理model无法承担的业务功能。</p><p>其实这两种方式都是对web服务处理业务逻辑的一种抽象，而DDD只是提供我们另一种抽象方式，协助我们更紧凑的封装data model。当然，其代价就是由于严格的分层，造成同样属性的模型重复在request与response序列化、domain model处理以及repository处理中实现。借鉴<a href="https://www.django-rest-framework.org/">Django Rest Framework</a>中对serializer的设计，我们可以实现通用的从某一个<code>domain model Entity and ValueObj</code> generate不同的适配不同module的data model。以减少model重复定义，避免提高维护复杂度</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stackoverflow.com/a/2279729">domain service vs application service vs infrastructure service</a><br><a href="https://stackoverflow.com/a/16847409">uniquevalidation in DDD</a><br><a href="https://www.infoq.cn/article/star-driven-approaches">驱动方法不能改变任何事情</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC与DDD比较-2022-05-23&quot;&gt;&lt;a href=&quot;#MVC与DDD比较-2022-05-23&quot; class=&quot;headerlink&quot; title=&quot;MVC与DDD比较(2022.05.23)&quot;&gt;&lt;/a&gt;MVC与DDD比较(2022.05.23)&lt;/h1</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://edison-a-n.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Git commit 规范</title>
    <link href="https://edison-a-n.github.io/2022/02/13/commit-format-and-auto-changelog/"/>
    <id>https://edison-a-n.github.io/2022/02/13/commit-format-and-auto-changelog/</id>
    <published>2022-02-13T14:04:17.000Z</published>
    <updated>2025-09-20T05:45:32.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="commit-message-format"><a href="#commit-message-format" class="headerlink" title="commit message format"></a>commit message format</h3><h4 id="提交格式"><a href="#提交格式" class="headerlink" title="提交格式"></a>提交格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><ul><li><code>build</code>：对构建系统或者外部依赖项进行了修改</li><li><code>ci</code>：对CI配置文件或脚本进行了修改</li><li><code>feature</code>：增加新的特征，一般指的是大的变更</li><li><code>func</code>： 增加新的功能，一般指小的功能</li><li><code>fix</code>：修复bug</li><li><code>impr</code>: improvement，小的代码设计改进</li><li><code>conf</code>: 仅配置变化，Spring配置、properties文件</li><li><code>perf</code>：提高性能的代码更改</li><li><code>refactor</code>：既不是修复bug也不是添加特征的代码重构</li><li><code>docs</code>：对文档进行了修改</li><li><code>style</code>：不影响代码含义的修改，比如空格、格式化、缺失的分号等</li><li><code>typo</code>: 修复小的拼写错误</li><li><code>test</code>：增加确实的测试或者矫正已存在的测试</li><li><code>revert</code>: 回滚提交</li></ul><h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><p>选填，一般填写作用于哪个文件</p><h5 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h5><p>必填，变更的摘要</p><ul><li>使用动宾语句，仅讲变更的内容</li><li>现在时态：<code>change</code>不是<code>changing</code>也不是<code>changed</code></li><li>不要大写首字母</li><li>不在末尾添加句号</li></ul><h5 id="body"><a href="#body" class="headerlink" title="body"></a>body</h5><p>和主题设置类似，使用命令式、现在时态</p><p>应该包含修改的动机以及和之前行为的对比.</p><ul><li>回滚操作，需要添加本句：<code>This reverts commit hash: **********</code></li></ul><h5 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h5><ul><li><code>BREAKING CHANGE</code>: 不兼容的更新说明，比如public API的修改等</li><li><code>Closes</code>: 指针对哪个issue的修改，可以关联某个story或者bug</li></ul><h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><h4 id="为什么需要规范"><a href="#为什么需要规范" class="headerlink" title="为什么需要规范"></a>为什么需要规范</h4><p>git提交规范，有利于代码变动的稳定性监控。更大的价值是，后续跟进维护的同学可以通过commit查找变更的细节，以及了解某段代码引入的目的。</p><h4 id="中文or英文"><a href="#中文or英文" class="headerlink" title="中文or英文"></a>中文or英文</h4><p>在内部工程中，如果团队大多数都是中国人，建议还是使用中文描述。不准确的英文描述会影响后续对commit的阅读，也就无所谓理解了。当然，最好还是使用英文。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南 - 阮一峰</a><br><a href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">Angular提交信息规范</a><br><a href="https://cloud.tencent.com/developer/article/1762300">美团 GIT Commit Log规范</a><br><a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commits</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;commit-message-format&quot;&gt;&lt;a href=&quot;#commit-message-format&quot; class=&quot;headerlink&quot; title=&quot;commit message format&quot;&gt;&lt;/a&gt;commit message format&lt;/</summary>
      
    
    
    
    
    <category term="thinking" scheme="https://edison-a-n.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>思考与交流</title>
    <link href="https://edison-a-n.github.io/2022/02/03/tight-lipped/"/>
    <id>https://edison-a-n.github.io/2022/02/03/tight-lipped/</id>
    <published>2022-02-02T16:44:49.000Z</published>
    <updated>2025-09-20T05:45:32.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>想写这篇文章，是因为在某平台看某用户的一篇文章，想了解一下作者的背景，进而看到其在一些回答中与评论者争吵的情况。其实技术水平高低本身是受很多情况影响的，评价一个人也不是一维的。事实上，没有任何标准可以真正的评价一个人。技术讨论和技术辩论是受欢迎的，因为大家技术水平不在一个等级而无法正常的讨论进而主动拒绝讨论本身也是可以接受的。黑一门技术，则显得狭隘了。</p><p>为了调解自己的思想，再一次阅读了《黑客与画家》“守口如瓶”这一章，并分享一些感悟。</p><h3 id="自由的思考"><a href="#自由的思考" class="headerlink" title="自由的思考"></a>自由的思考</h3><p>自由的思考，强调的是，不要轻易的被各种论断影响。我们需要去思考一个论点的论证逻辑，了解其论据是否足够充分。信息时代，我们每天都会从各种渠道接受到各种各样的信息。当我们可以自由的思考的时候，我们可以让思考变得更加理性客观。所以我们要减少跟别人辩个明白的行为。辩论，是为了信息和思考进行交换，是为了让我们有更多的角度来思考，是为了更自由的思考。</p><p>思考一个话题的时候，该话题本身是没有正确与否的区别的，只有是否合逻辑，合情理。当然这些逻辑和情理也是预置的。所以我们需要交流，来持续拓展我们预先存储的对逻辑和情理的认识，让我们的思考更加自由和理性。</p><h3 id="选择可以交流的人"><a href="#选择可以交流的人" class="headerlink" title="选择可以交流的人"></a>选择可以交流的人</h3><p>很多时候，我们会遇到非要辩个明白的人。这其实已经算是一件幸事。至少他只是要强调他的观点是正确的，不一定会攻击我们。有时候，我们还会遇到，直接对自己进行攻击的人。</p><p>因为，我们跟别人讨论甚至辩论，是为了启发思考，是为了避免自己呆在一个井底。所以，我们要找可以交流的人。可以交流的人，是那些可以只对观点发表看法，并同时尊重你的观点，最重要的是不会因为观点不一致而气急败坏的人。</p><p>这样的人很多也很少。我们可以多跟不同的人交流，去试探他们是不是这样的人。如果一个人始终处于“不能交流”的状态，那么就要远离他。因为，一旦我们跟他辩论，我们的思考就很容易陷入偏颇，此时只想着辩赢，而不是自由的思考。</p><p>无论如何，我们一定要积极去结识，更多的结识可以交流的朋友，因为“观点不讨论，就什么观点也没有了。”</p><p>还有一种方法是看书，看书，就是与作者交流的过程。</p><h3 id="接受不一样的观点"><a href="#接受不一样的观点" class="headerlink" title="接受不一样的观点"></a>接受不一样的观点</h3><p>与可以交流的人交流，我们就可以兴平气和的讨论一个与自己原先理解不一样的观点。有时候，我们可能在讨论之后，仍然不认可该观点。但是，因为我们的交流，是为了自由的思考，所以，一个不一样的观点是可以被接受的。在未来与更多的人交流，自己思考的更多的时候，或许，会有更充分的论据和更严谨的论证，来说服自己不认可该观点，当然也可能让自己认可了该观点。</p><p>地心说，在提出的年代可能都不被认可，但是我们可以先存着，在后来的认知不断提高的过程，逐渐认可这个观点。如果我们只是去跟哥白尼“争论”，如果我们不能接受不一样的观点，那我们的思考也将不自由。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;/h3&gt;&lt;p&gt;想写这篇文章，是因为在某平台看某用户的一篇文章，想了解一下作者的背景，进而看到其在一些回答中与评论者争吵的情况。其实技术水平高低本身是受很多</summary>
      
    
    
    
    
    <category term="thinking" scheme="https://edison-a-n.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>知识掌握的广度与深度</title>
    <link href="https://edison-a-n.github.io/2022/01/30/knowledge-breath-and-depth/"/>
    <id>https://edison-a-n.github.io/2022/01/30/knowledge-breath-and-depth/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2025-09-20T05:45:32.528Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是广度与深度"><a href="#什么是广度与深度" class="headerlink" title="什么是广度与深度"></a>什么是广度与深度</h3><p>想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟hr交流的时候，或者跟领导、行业大佬交流的时候，也经常会听到这样的建议：“要做一名T&#x2F;π型人才”。</p><p>那么，广度要怎么理解，深度又要怎么理解呢。我们掌握了一些知识或者信息，需要达到一个什么程度，算是覆盖了广度，或是达到了深度。</p><p>我个人的感受是，当我们对知识、信息达到了，</p><ul><li><strong>能够理解其中的原理与逻辑，同时能够自己进行复述</strong>，则算是达到了广度的覆盖</li><li><strong>能够机遇已有的信息，思考其深层次的逻辑，举一反三的实践或思考总结，并能达到一定效果</strong>，则算是深度的掌握。</li></ul><p>我们每天会浏览五花八门的信息，会folloe各种博客阅读新的思想。多数时候，我们以为我们已经了解其中的相关内容，其实我们仅限于“知道“。我们没有能够梳理其中的逻辑，也更无可能无法复述其中的逻辑。<strong>但是没有关系，因为我们的时间有限，不可能对大多数信息都能完整了解。</strong> 对于我们需要去了解的领域，则需要做到”广度式“的了解。比如很多人打王者荣耀，有的人只是消磨时间，有的人则会去了解每个英雄的连招、出装、阵容搭配等等。前者算不得广度，即不能在相亲介绍中的兴趣爱好栏写打王者荣耀，顶多只能写无聊时打打王者。做到深度掌握打王者打同学，则要摸清楚某个英雄的各种细节，在各种场景中如何操作。</p><p>当然，具体要掌握到什么程度，取决于自己。比如我，就只是无聊时打打王者。</p><h3 id="如何达到广度与深度"><a href="#如何达到广度与深度" class="headerlink" title="如何达到广度与深度"></a>如何达到广度与深度</h3><p>我曾经咨询过一位架构师，聊“如何覆盖技术的广度与深度”。在我的工作内容中，甚少会接触大数据工程，也没有直接接触AI项目（两大当前热门“泡沫”领域），我如何让我的技术覆盖到那里呢。我收到的回答是：“当你需要的时候，你自然会去学习去了解。”</p><p>需要的时候，是一个很有趣的描述。什么是需要的时候，想“知道”一下，方便吹牛的时候扯扯专业名词；想“了解”一下，虽然用不到但是可以学一学原理；想“挖掘”一下，在某个项目中应用。还有其他的各种情况，都会成为需要的时候。</p><p>在当前的互联网时代，要达到知识掌握的广度，其实不难。要了解一个领域的知识，有各种各样的搜索引擎和问答社区，可以找到资料。无论是否正确，逻辑总能在一定程度上自洽。要找到不自洽的点，当然需要更深入的学习理解了。如同狼人杀发言，论述粗看一定有道理，至于是不是真的合理，就需要高级玩家才能分辨出来。</p><h3 id="有计划的拓展广度和深度"><a href="#有计划的拓展广度和深度" class="headerlink" title="有计划的拓展广度和深度"></a>有计划的拓展广度和深度</h3><p>虎年马上要到来，也是2022年的一月份，很多人都会给自己做计划，也有很多人没有什么特别的计划。计划的执行可能也都不一样。我十分建议，能够为自己的知识的广度与深度的拓展做足计划，且最好是有长时与短时计划。也许有的人不知道未来三五年自己会做什么，但是大家多少都有一个方向，或者有些兴趣点。</p><p>有计划的去拓展和达成，可以让自己持续的达到某些里程碑，从而持续对自己形成正向激励。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是广度与深度&quot;&gt;&lt;a href=&quot;#什么是广度与深度&quot; class=&quot;headerlink&quot; title=&quot;什么是广度与深度&quot;&gt;&lt;/a&gt;什么是广度与深度&lt;/h3&gt;&lt;p&gt;想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何撰写技术设计文档</title>
    <link href="https://edison-a-n.github.io/2021/12/16/software-design-doc/"/>
    <id>https://edison-a-n.github.io/2021/12/16/software-design-doc/</id>
    <published>2021-12-15T16:00:00.000Z</published>
    <updated>2025-09-20T05:45:32.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在解决的问题，以及方案的设计思路。</p><h3 id="为什么要写设计文档"><a href="#为什么要写设计文档" class="headerlink" title="为什么要写设计文档"></a>为什么要写设计文档</h3><ul><li>要解决的问题是什么需要用文档先介绍清楚</li><li>有些问题使用一份设计文档描述思路已经足够</li><li>解决方案的选择（decision）是权衡的结果，我们不仅需要了解结果，也需要知道结果产生的原因，即权衡的过程。只有记录下权衡的过程，在后续偿还技术债的时候，才可以更方便的理解产生的原因或初衷，并有更充分的执行架构演进的依据</li><li>让团队成员对问题和设计有一个共识</li></ul><h3 id="设计文档核心内容"><a href="#设计文档核心内容" class="headerlink" title="设计文档核心内容"></a>设计文档核心内容</h3><p>基于以上原因，我们也可以推论出，设计文档所需要具备的核心内容：</p><ul><li>问题的上下文。一个问题需要解决，自然需要关于该问题的上下文内容。</li><li>想要达成的目标是什么</li><li>哪些不是我们的目标<br>如果在讨论与设计过程中，发现一些可能会对设计带来干扰，但是明确不是当前要解决的目标，需要记录下来，以便团队对此形成共识</li><li>权衡的过程<ul><li>为什么选择某个方案</li><li>为什么不选择某个方案<br>如果对于某一个方案，有十分明确的不使用的原因，尤其是行业有充分的应用经验而设计的时候考虑不使用的时候，需要将其记录下来，作为权衡的参考，以避免后续团队演进设计的时候，朝着原先不选择的方案前进。</li><li>当前的一个或多个方案有什么条件限制或成本考虑</li><li>收益是如何的，创造的价值是什么</li></ul></li></ul><h3 id="什么时候写设计文档"><a href="#什么时候写设计文档" class="headerlink" title="什么时候写设计文档"></a>什么时候写设计文档</h3><p><strong>在着手实现之前，先完成设计文档的撰写与迭代。</strong></p><p>不要试图等到将功能实现之后在补充文档。开发者喜欢写代码甚于写文档。对于开发者来说，在文档中描述某种架构实现方案，不如实现一个demo来演示该方案。当开始写demo之后，很可能就会开始将demo做修修补补，最后完成一份可上线代码。当代码完成之后，除非有某种强制推力要求自己必须完成，或是为了向多个团队或个人介绍自己的方案而减少</p><p>在实现之前，完成设计文档的撰写与迭代，可以持续的思考自己的设计的缺陷，并记录下来</p><p>设计文档的基本写作步骤：<br>打草稿 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; …</p><ul><li>需求持续在变</li><li>有新的设计想法或方案</li><li>有新的condition或constraint出现，需要调整设计</li></ul><h3 id="写文档是一件有趣的事情"><a href="#写文档是一件有趣的事情" class="headerlink" title="写文档是一件有趣的事情"></a>写文档是一件有趣的事情</h3><p>写文档，犹如在将学习理解掌握的事情，再向其他人介绍与论述，以寻求与他人的共鸣。我们在白板前讨论的问题，在讨论完毕之后就会被擦除；我们编写的代码，会因为各种需求的变化而被调整（感谢svn让我们可以回顾第一行代码）。而文档，在未来的某一天，仍旧将有人会来翻阅，如同著书立说，言论可能会过时，但是却是在当下时代的最佳产物。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.industrialempathy.com/posts/design-docs-at-google/">Design Docs at Google</a></p><p><a href="https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/">Scaling Engineering Teams via RFCs: Writing Things Down</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>突破式创新的产品设计</title>
    <link href="https://edison-a-n.github.io/2021/11/21/breaking-creation-product/"/>
    <id>https://edison-a-n.github.io/2021/11/21/breaking-creation-product/</id>
    <published>2021-11-20T16:00:00.000Z</published>
    <updated>2025-09-20T05:45:32.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="10倍的产品改进"><a href="#10倍的产品改进" class="headerlink" title="10倍的产品改进"></a>10倍的产品改进</h3><p>《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如果产品所属的市场价值极大，2-3倍的改进会引来一大群竞争者轻易的介入，这将使得产品在后续的迭代中疲于与其他竞争者斡旋，而丢失了让产品变得更好的目标。如果产品的市场价值有限，那么产品能带来的收益也有限，投入的成本也将有限，并很难再继续做大。事实上，有相当一部分产品的推出，比原来的产品带来的改进少于其带来的麻烦。这样的产品，基本很难吸引到用户。俞军提出的产品价值公式可以很好诠释这一点，即<code>新产品价值 &gt; 旧产品价值 + 迁移成本</code>，这样的新产品才有可能成功。</p><p>一款产品想要在推出的时候，占领并持续垄断市场，需要十倍的产品改进。这里我们不细谈市场是否存在，假设已经经过足够的调研验证市场确实存在。如同我们使用微信，很难有新一款社交工具可以打败。</p><p>10倍的改进不只在于产品功能本身，还有其交互体验，产品性能与稳定。chrome关于其核心原则的介绍，可以很好的指导10倍的改进。</p><p>10倍的改进本身并不容易衡量。但是我们可以从以下几个点去判断：</p><ul><li>技术不可替代</li><li>交互更加简单</li><li>稳定性更佳</li><li>交互反应更加快速</li></ul><p>此外，安全性不在这里提出，但是也越来越重要，越来越成为一款产品是否“改进”的判断标准之一。</p><p>“MVP法则”本身并没有问题，但是很多人在定义minimum value的时候，往往只抓住了某个核心需求即快速的进行产品设计，开发者也只专注于实现核心功能而不考虑优化。当用户有多个价值需求的时候，技术不满足、产品没有完成设计，会让用户体验不佳而造成初始不良印象，甚至放弃使用该产品。而用户对产品的不良反馈将会严重打击产品迭代的积极性。除非产品经理与开发者能认识到自身的不足。更可惜的是，着急推出的可能可以创造改变但是设计不良的产品，无异于让竞争者快速入场并将自己打到。</p><p>一款“MVP”产品，应该在一开始就具备建立垄断的能力。Apple产品、Chrome、微信都是如此。即使后来的各种移动端设备、浏览器(包括app内建的浏览器如微信搜索)、社交工具，都无法撼动。Apple在近些年不断被挑战，也是因为其仅做的2-3倍的改进，让华为、小米等竞争者可以快速完成替代，并在其他方面创造竞争力。尽管不足以将Apple踢出竞争环境，但是也不断在蚕食其市场。而其他踢出竞争环境的产品包括Firefox、柯达等。</p><p>要做到10倍的改进行，需要深耕技术基础的工程师，准确理解用户需求的产品经理。</p><p>要做到看起来很难，事实也是如此。而最基本的方法是，每一次做技术设计或产品设计的时候，都问自己，</p><ul><li>有没有理解不到位的地方？</li><li>有没有更好的解决方法？</li><li>不调整设计减少的成本和收益比是否可以承受？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;10倍的产品改进&quot;&gt;&lt;a href=&quot;#10倍的产品改进&quot; class=&quot;headerlink&quot; title=&quot;10倍的产品改进&quot;&gt;&lt;/a&gt;10倍的产品改进&lt;/h3&gt;&lt;p&gt;《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DRF Exception Handle</title>
    <link href="https://edison-a-n.github.io/2021/07/15/parallel-and-asynchronous-python/"/>
    <id>https://edison-a-n.github.io/2021/07/15/parallel-and-asynchronous-python/</id>
    <published>2021-07-14T16:00:00.000Z</published>
    <updated>2025-09-20T05:45:32.529Z</updated>
    
    <content type="html"><![CDATA[<p>持续更新关于python并行计算与异步计算的包，后续再根据篇章拆分。</p><h3 id="Python-并行"><a href="#Python-并行" class="headerlink" title="Python 并行"></a>Python 并行</h3><h4 id="并行库"><a href="#并行库" class="headerlink" title="并行库"></a>并行库</h4><p><a href="https://docs.python.org/3/library/threading.html">threading</a><br><a href="https://docs.python.org/3/library/multiprocessing.html">multiprocessing</a></p><h4 id="multiprocessing-中的一些问题"><a href="#multiprocessing-中的一些问题" class="headerlink" title="multiprocessing 中的一些问题"></a>multiprocessing 中的一些问题</h4><h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul><li><a href="https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods">开启子进程的方法与问题</a><br>  spawn相比fork会更耗时，但是fork在处理一个多线程的进程时可能会陷入死锁等问题。这是由于<a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork本身的机制</a>造成的。这也使得在使用包的过程中常常遇到一些问题。</li><li>IO问题<br>  <a href="https://man7.org/linux/man-pages/man2/fork.2.html">fork本身会继承打开文件的描述符</a>，所以对于多进程的处理，要留意IO处理带来的不良影响<h5 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h5>由于使用多进程更多是因为，CPython本身的GIL造成无法使用多个CPU核，而使用多进程的方式进行处理。所以仅当处理多核计算任务的时候，我们使用multiprocessing，并且尽量让处理内容限定在计算而不包含IO。</li></ul><h3 id="Python-异步"><a href="#Python-异步" class="headerlink" title="Python 异步"></a>Python 异步</h3><h4 id="gunicorn-gevent"><a href="#gunicorn-gevent" class="headerlink" title="gunicorn + gevent"></a>gunicorn + gevent</h4><p><a href="https://docs.gunicorn.org/en/latest/design.html#async-workers">gunicorn async worker</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://en.wikipedia.org/wiki/Event_loop">Event Loop Wiki</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;持续更新关于python并行计算与异步计算的包，后续再根据篇章拆分。&lt;/p&gt;
&lt;h3 id=&quot;Python-并行&quot;&gt;&lt;a href=&quot;#Python-并行&quot; class=&quot;headerlink&quot; title=&quot;Python 并行&quot;&gt;&lt;/a&gt;Python 并行&lt;/h3&gt;&lt;h4</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>DRF Exception Handle</title>
    <link href="https://edison-a-n.github.io/2021/06/17/DRF-Exception/"/>
    <id>https://edison-a-n.github.io/2021/06/17/DRF-Exception/</id>
    <published>2021-06-16T16:00:00.000Z</published>
    <updated>2025-09-20T05:45:32.526Z</updated>
    
    <content type="html"><![CDATA[<h3 id="框架报错源码解析"><a href="#框架报错源码解析" class="headerlink" title="框架报错源码解析"></a>框架报错源码解析</h3><ul><li><p>exception 处理器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rest_framework.views 71-101</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">exception_handler</span>(<span class="params">exc, context</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Returns the response that should be used for any given exception.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    By default we handle the REST framework `APIException`, and also</span></span><br><span class="line"><span class="string">    Django&#x27;s built-in `Http404` and `PermissionDenied` exceptions.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Any unhandled exceptions may return `None`, which will cause a 500 error</span></span><br><span class="line"><span class="string">    to be raised.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, Http404):</span><br><span class="line">        exc = exceptions.NotFound()</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(exc, PermissionDenied):</span><br><span class="line">        exc = exceptions.PermissionDenied()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, exceptions.APIException):</span><br><span class="line">        headers = &#123;&#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">getattr</span>(exc, <span class="string">&#x27;auth_header&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            headers[<span class="string">&#x27;WWW-Authenticate&#x27;</span>] = exc.auth_header</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">getattr</span>(exc, <span class="string">&#x27;wait&#x27;</span>, <span class="literal">None</span>):</span><br><span class="line">            headers[<span class="string">&#x27;Retry-After&#x27;</span>] = <span class="string">&#x27;%d&#x27;</span> % exc.wait</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc.detail, (<span class="built_in">list</span>, <span class="built_in">dict</span>)):</span><br><span class="line">            data = exc.detail</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data = &#123;<span class="string">&#x27;detail&#x27;</span>: exc.detail&#125;</span><br><span class="line"></span><br><span class="line">        set_rollback()</span><br><span class="line">        <span class="keyword">return</span> Response(data, status=exc.status_code, headers=headers)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>从处理器源码可以看到，当抛出一个<code>str</code>的错误的时候，处理器会主动为其添加一个<code>detail</code>的<code>key</code>来包裹成可以被后续处理为<code>json</code>的格式，而对于<code>list</code>与<code>dict</code>的格式，则直接返回。</p></li><li><p>ValidationError 处理</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rest_framework.exceptions.ValidationError 140-158</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ValidationError</span>(<span class="title class_ inherited__">APIException</span>):</span><br><span class="line">    status_code = status.HTTP_400_BAD_REQUEST</span><br><span class="line">    default_detail = _(<span class="string">&#x27;Invalid input.&#x27;</span>)</span><br><span class="line">    default_code = <span class="string">&#x27;invalid&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, detail=<span class="literal">None</span>, code=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="keyword">if</span> detail <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            detail = self.default_detail</span><br><span class="line">        <span class="keyword">if</span> code <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            code = self.default_code</span><br><span class="line"></span><br><span class="line">        <span class="comment"># For validation failures, we may collect many errors together,</span></span><br><span class="line">        <span class="comment"># so the details should always be coerced to a list if not already.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(detail, <span class="built_in">tuple</span>):</span><br><span class="line">            detail = <span class="built_in">list</span>(detail)</span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(detail, <span class="built_in">dict</span>) <span class="keyword">and</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(detail, <span class="built_in">list</span>):</span><br><span class="line">            detail = [detail]</span><br><span class="line"></span><br><span class="line">        self.detail = _get_error_details(detail, code)</span><br></pre></td></tr></table></figure><p>对于<code>ValidationError</code>错误，会强制将最后的值转换为<code>list</code>类型，这是考虑到一个<code>field</code>可能有多条不同的错误需要累积。</p><ul><li>序列化报错处理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rest_framework.serializers 323-346</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">as_serializer_error</span>(<span class="params">exc</span>):</span><br><span class="line">    <span class="keyword">assert</span> <span class="built_in">isinstance</span>(exc, (ValidationError, DjangoValidationError))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(exc, DjangoValidationError):</span><br><span class="line">        detail = get_error_detail(exc)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        detail = exc.detail</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(detail, Mapping):</span><br><span class="line">        <span class="comment"># If errors may be a dict we use the standard &#123;key: list of values&#125;.</span></span><br><span class="line">        <span class="comment"># Here we ensure that all the values are *lists* of errors.</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            key: value <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, (<span class="built_in">list</span>, Mapping)) <span class="keyword">else</span> [value]</span><br><span class="line">            <span class="keyword">for</span> key, value <span class="keyword">in</span> detail.items()</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">elif</span> <span class="built_in">isinstance</span>(detail, <span class="built_in">list</span>):</span><br><span class="line">        <span class="comment"># Errors raised as a list are non-field errors.</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            api_settings.NON_FIELD_ERRORS_KEY: detail</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment"># Errors raised as a string are non-field errors.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        api_settings.NON_FIELD_ERRORS_KEY: [detail]</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>drf中的序列化器<code>serializers</code>，在运行<code>run_validation</code>序列化报错的过程中，会给没有列出具体字段错误的<code>detail</code>信息，即不是<code>dict</code>格式的信息，带上一个<code>non_field_errors</code>的key来标准化。</p><h3 id="推荐方案"><a href="#推荐方案" class="headerlink" title="推荐方案"></a>推荐方案</h3><ul><li>非400报错<br>对于403，404等错误码，直接获取<code>detail</code>下的值即可</li><li>400报错<br>对于ValidationError错误，需要做两种处理<ol><li>单独创建，报错如下，直接识别到错误的字段<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: [&quot;Not Unique&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>批量创建，报错如下，按顺序识别创建的条目的错误字段。如果为空，则说明无校验错误。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    &quot;id&quot;: [&quot;Not Unique&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;&#125;,</span><br><span class="line">  &#123;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>此外，关于返回值为数组，需要前端进行相应处理具有多个错误信息的报错。<h3 id="其他方案"><a href="#其他方案" class="headerlink" title="其他方案"></a>其他方案</h3>根据参考方案，按照团队习惯，可以自定义<code>exception_handler</code>，以定义团队使用的错误信息格式。<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><a href="https://www.django-rest-framework.org/api-guide/exceptions/#custom-exception-handling">drf-exception</a></li></ol></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;框架报错源码解析&quot;&gt;&lt;a href=&quot;#框架报错源码解析&quot; class=&quot;headerlink&quot; title=&quot;框架报错源码解析&quot;&gt;&lt;/a&gt;框架报错源码解析&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;exception 处理器&lt;/p&gt;
&lt;figure class=&quot;high</summary>
      
    
    
    
    
  </entry>
  
</feed>
