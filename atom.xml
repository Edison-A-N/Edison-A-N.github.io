<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Edison</title>
  
  
  <link href="https://edison-a-n.github.io/atom.xml" rel="self"/>
  
  <link href="https://edison-a-n.github.io/"/>
  <updated>2026-01-17T09:28:43.900Z</updated>
  <id>https://edison-a-n.github.io/</id>
  
  <author>
    <name>Edison</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>交易回撤控制指南：认知、守心与仓位管理</title>
    <link href="https://edison-a-n.github.io/2026/01/17/trading-drawdown-control-guide/"/>
    <id>https://edison-a-n.github.io/2026/01/17/trading-drawdown-control-guide/</id>
    <published>2026-01-16T16:00:00.000Z</published>
    <updated>2026-01-17T09:28:43.900Z</updated>
    
    <content type="html"><![CDATA[<p>回撤是每个交易者都必须面对的核心问题。有效控制回撤不仅关系到资金安全，更是交易系统长期稳定盈利的基石。本文从三个层面深入探讨如何科学地控制回撤。</p><hr><h2 id="一、控制回撤的核心：明确自己的交易模式的回撤范围"><a href="#一、控制回撤的核心：明确自己的交易模式的回撤范围" class="headerlink" title="一、控制回撤的核心：明确自己的交易模式的回撤范围"></a>一、控制回撤的核心：明确自己的交易模式的回撤范围</h2><h3 id="1-1-为什么要明确回撤范围？"><a href="#1-1-为什么要明确回撤范围？" class="headerlink" title="1.1 为什么要明确回撤范围？"></a>1.1 为什么要明确回撤范围？</h3><p>很多交易者在交易过程中感到焦虑和困惑，根本原因在于对自己交易模式的回撤特性缺乏清晰认知。不同的交易模式有着截然不同的回撤特征：</p><ul><li><strong>趋势跟踪策略</strong>：胜率相对较低（30-40%），但盈亏比高，可能会经历连续多次止损，单次回撤可能达到10-15%</li><li><strong>震荡交易策略</strong>：胜率相对较高（60-70%），但盈亏比较低，回撤相对平缓但频繁</li><li><strong>突破策略</strong>：假突破会导致连续亏损，回撤曲线呈阶梯状下降</li><li><strong>套利策略</strong>：大部分时间回撤很小，但黑天鹅事件可能导致单次巨大回撤</li></ul><h3 id="1-2-如何确定自己模式的回撤范围？"><a href="#1-2-如何确定自己模式的回撤范围？" class="headerlink" title="1.2 如何确定自己模式的回撤范围？"></a>1.2 如何确定自己模式的回撤范围？</h3><p><strong>1) 历史回测</strong></p><ul><li>至少使用3-5年的历史数据进行回测</li><li>记录最大回撤、平均回撤、回撤持续时间</li><li>分析回撤发生的市场环境（震荡市、趋势市、突发事件等）</li></ul><p><strong>2) 实盘追踪</strong></p><ul><li>前期小仓位实盘测试至少6个月</li><li>记录每一次回撤的原因、幅度和恢复时间</li><li>对比回测数据与实盘数据的差异</li></ul><p><strong>3) 蒙特卡洛模拟</strong></p><ul><li>基于历史交易序列进行随机排列</li><li>模拟1000次以上的交易序列</li><li>得出最大回撤的概率分布</li></ul><h3 id="1-3-建立回撤预期"><a href="#1-3-建立回撤预期" class="headerlink" title="1.3 建立回撤预期"></a>1.3 建立回撤预期</h3><p>明确以下关键指标：</p><ul><li><strong>最大可承受回撤</strong>：根据资金量和心理承受能力设定（建议15-25%）</li><li><strong>预警回撤线</strong>：达到此线需要审视交易执行（建议10-15%）</li><li><strong>正常回撤范围</strong>：模式内的正常波动（通常5-10%）</li><li><strong>回撤恢复周期</strong>：历史数据显示从最大回撤恢复到盈亏平衡的平均时间</li></ul><blockquote><p><strong>关键认知</strong>：只有清楚知道自己的交易模式在什么市场环境下会回撤、回撤多少、持续多久，才能在回撤来临时保持冷静，避免情绪化操作。</p></blockquote><hr><h2 id="二、控制回撤的关键：守心——遵循自己的模式"><a href="#二、控制回撤的关键：守心——遵循自己的模式" class="headerlink" title="二、控制回撤的关键：守心——遵循自己的模式"></a>二、控制回撤的关键：守心——遵循自己的模式</h2><h3 id="2-1-守心的真正含义"><a href="#2-1-守心的真正含义" class="headerlink" title="2.1 守心的真正含义"></a>2.1 守心的真正含义</h3><p>守心不是盲目坚持，而是：</p><ul><li><strong>认知内的坚持</strong>：在自己交易模式的正常回撤范围内，严格执行交易纪律</li><li><strong>认知外的停止</strong>：当回撤超出模式的历史范围，果断停止交易，重新审视</li></ul><h3 id="2-2-最危险的行为：因回撤而改变交易模式"><a href="#2-2-最危险的行为：因回撤而改变交易模式" class="headerlink" title="2.2 最危险的行为：因回撤而改变交易模式"></a>2.2 最危险的行为：因回撤而改变交易模式</h3><p>许多交易者在回撤时会犯以下错误：</p><p><strong>错误1：频繁切换策略</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">场景：趋势策略连续止损后，改用震荡策略</span><br><span class="line">问题：没有任何策略能适应所有市场环境</span><br><span class="line">结果：每个策略都在最不利的时候使用，回撤加剧</span><br></pre></td></tr></table></figure><p><strong>错误2：加大仓位”回本”</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">场景：账户回撤10%，想通过加大仓位快速回本</span><br><span class="line">问题：仓位与市场认知不匹配</span><br><span class="line">结果：一旦判断错误，回撤从10%扩大到20-30%</span><br></pre></td></tr></table></figure><p><strong>错误3：完全停止交易</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">场景：经历一次较大回撤后，长期不敢交易</span><br><span class="line">问题：错过模式内的盈利机会</span><br><span class="line">结果：资金曲线长期横盘，失去复利效应</span><br></pre></td></tr></table></figure><h3 id="2-3-如何做到守心？"><a href="#2-3-如何做到守心？" class="headerlink" title="2.3 如何做到守心？"></a>2.3 如何做到守心？</h3><p><strong>1) 建立交易日志系统</strong></p><ul><li>每笔交易记录：入场理由、是否符合模式、执行质量</li><li>每日复盘：今日交易是否在认知范围内</li><li>每周总结：本周回撤是否属于模式内正常回撤</li></ul><p><strong>2) 设立”模式偏离”警报</strong></p><p>创建一个检查清单：</p><ul><li><input disabled="" type="checkbox"> 本次交易是否符合我的入场规则？</li><li><input disabled="" type="checkbox"> 仓位是否符合我的资金管理规则？</li><li><input disabled="" type="checkbox"> 当前市场环境是否适合我的交易模式？</li><li><input disabled="" type="checkbox"> 我的操作是否受到情绪影响？</li></ul><p>任何一项回答”否”，立即停止交易。</p><p><strong>3) 心理训练</strong></p><ul><li><strong>接受回撤的必然性</strong>：将回撤视为交易成本，而非失败</li><li><strong>关注过程而非结果</strong>：每次完美执行交易计划，即使亏损也是成功</li><li><strong>长期视角</strong>：用年度收益率评估，而非每日盈亏</li></ul><h3 id="2-4-案例：守心的力量"><a href="#2-4-案例：守心的力量" class="headerlink" title="2.4 案例：守心的力量"></a>2.4 案例：守心的力量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">交易者A：趋势跟踪策略</span><br><span class="line">- 3月：连续5笔止损，回撤8%，严格执行计划</span><br><span class="line">- 4月：大趋势到来，单月盈利20%</span><br><span class="line">- 全年收益：35%</span><br><span class="line"></span><br><span class="line">交易者B：同样的策略</span><br><span class="line">- 3月：连续5笔止损后，认为策略失效</span><br><span class="line">- 改用短线策略，在震荡中又损失5%</span><br><span class="line">- 4月：观望，错过大趋势</span><br><span class="line">- 全年收益：-15%</span><br></pre></td></tr></table></figure><blockquote><p><strong>核心原则</strong>：在认知范围内的回撤，是模式的必然成本；超出认知范围的回撤，是需要警觉的信号。守心就是在这两者之间保持清醒的判断。</p></blockquote><hr><h2 id="三、控制回撤的本质：市场理解与仓位匹配"><a href="#三、控制回撤的本质：市场理解与仓位匹配" class="headerlink" title="三、控制回撤的本质：市场理解与仓位匹配"></a>三、控制回撤的本质：市场理解与仓位匹配</h2><h3 id="3-1-对市场的准确理解"><a href="#3-1-对市场的准确理解" class="headerlink" title="3.1 对市场的准确理解"></a>3.1 对市场的准确理解</h3><p>回撤的根本来源是<strong>认知与现实的偏差</strong>。减少这种偏差需要：</p><p><strong>1) 分辨市场状态</strong></p><p>市场主要有三种状态：</p><ul><li><strong>趋势市</strong>：方向明确，持续性强</li><li><strong>震荡市</strong>：区间波动，方向不明</li><li><strong>转换期</strong>：趋势与震荡之间的过渡</li></ul><p>每种状态都有相应的特征指标（波动率、成交量、技术形态等），学会识别当前市场处于哪种状态，是控制回撤的第一步。</p><p><strong>2) 了解自己的优势市场</strong></p><p>没有人能在所有市场中都盈利：</p><ul><li>你的策略在哪种市场状态下表现最好？</li><li>在哪种市场状态下应该减少交易或空仓？</li><li>哪些市场特征是你的危险信号？</li></ul><p><strong>3) 建立市场认知框架</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">高确定性交易（仓位70-100%）：</span><br><span class="line">- 多个信号共振</span><br><span class="line">- 市场状态与策略匹配度高</span><br><span class="line">- 风险收益比&gt;3:1</span><br><span class="line"></span><br><span class="line">中等确定性交易（仓位30-50%）：</span><br><span class="line">- 信号部分确认</span><br><span class="line">- 市场状态一般</span><br><span class="line">- 风险收益比2:1-3:1</span><br><span class="line"></span><br><span class="line">低确定性交易（仓位0-20%或不交易）：</span><br><span class="line">- 信号模糊</span><br><span class="line">- 市场状态不利</span><br><span class="line">- 风险收益比&lt;2:1</span><br></pre></td></tr></table></figure><h3 id="3-2-正确的仓位匹配"><a href="#3-2-正确的仓位匹配" class="headerlink" title="3.2 正确的仓位匹配"></a>3.2 正确的仓位匹配</h3><p>仓位管理是控制回撤最直接、最有效的工具。</p><p><strong>1) 固定比例法（适合新手）</strong></p><ul><li>每次交易固定使用总资金的2-5%</li><li>优点：简单、稳定</li><li>缺点：无法根据机会质量调整</li></ul><p><strong>2) 凯利公式（适合有统计数据的交易者）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最优仓位 = (胜率 × 平均盈利 - 失败率 × 平均亏损) / 平均盈利</span><br><span class="line"></span><br><span class="line">例如：胜率40%，盈亏比3:1</span><br><span class="line">最优仓位 = (0.4 × 3 - 0.6 × 1) / 3 = 0.2 = 20%</span><br><span class="line">实际使用：0.5 × 最优仓位 = 10%（保守）</span><br></pre></td></tr></table></figure><p><strong>3) 波动率调整法</strong></p><ul><li>市场波动率上升时减少仓位</li><li>市场波动率下降时可适当增加仓位</li><li>公式：仓位 &#x3D; 基准仓位 × (基准波动率 &#x2F; 当前波动率)</li></ul><p><strong>4) 分层仓位管理</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">总资金分配：</span><br><span class="line">- 40%：核心仓位（高确定性机会）</span><br><span class="line">- 30%：机动仓位（中等机会）</span><br><span class="line">- 20%：探索仓位（测试新策略、小仓位试错）</span><br><span class="line">- 10%：现金储备（应对突发机会或保证金追加）</span><br></pre></td></tr></table></figure><h3 id="3-3-仓位与回撤的关系"><a href="#3-3-仓位与回撤的关系" class="headerlink" title="3.3 仓位与回撤的关系"></a>3.3 仓位与回撤的关系</h3><p><strong>核心公式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">预期最大回撤 = 单次最大亏损 × 最大连续亏损次数 × 仓位比例</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">- 单次止损3%</span><br><span class="line">- 历史最大连续亏损5次</span><br><span class="line">- 满仓交易（100%）</span><br><span class="line">预期最大回撤 = 3% × 5 × 100% = 15%</span><br><span class="line"></span><br><span class="line">如果降低仓位到50%：</span><br><span class="line">预期最大回撤 = 3% × 5 × 50% = 7.5%</span><br></pre></td></tr></table></figure><h3 id="3-4-动态仓位调整机制"><a href="#3-4-动态仓位调整机制" class="headerlink" title="3.4 动态仓位调整机制"></a>3.4 动态仓位调整机制</h3><p><strong>根据账户状态调整</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">账户状态：盈利，净值曲线向上</span><br><span class="line">- 信号强度高：正常仓位或略增（不超过上限）</span><br><span class="line">- 信号强度中：正常仓位</span><br><span class="line">- 信号强度低：减半仓位</span><br><span class="line"></span><br><span class="line">账户状态：回撤5-10%</span><br><span class="line">- 信号强度高：正常仓位</span><br><span class="line">- 信号强度中：减半仓位</span><br><span class="line">- 信号强度低：暂停交易</span><br><span class="line"></span><br><span class="line">账户状态：回撤&gt;10%</span><br><span class="line">- 所有交易减半仓位</span><br><span class="line">- 重新评估策略有效性</span><br><span class="line"></span><br><span class="line">账户状态：回撤&gt;15%</span><br><span class="line">- 暂停交易</span><br><span class="line">- 全面复盘：是模式内正常回撤还是策略失效？</span><br></pre></td></tr></table></figure><h3 id="3-5-实战案例：市场理解与仓位匹配"><a href="#3-5-实战案例：市场理解与仓位匹配" class="headerlink" title="3.5 实战案例：市场理解与仓位匹配"></a>3.5 实战案例：市场理解与仓位匹配</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">场景：2023年某交易者的操作</span><br><span class="line"></span><br><span class="line">1月-3月：震荡市</span><br><span class="line">- 市场判断：区间震荡，波动率低</span><br><span class="line">- 策略选择：震荡交易策略</span><br><span class="line">- 仓位配置：单笔30%，最多持有2个仓位</span><br><span class="line">- 结果：小幅盈利5%</span><br><span class="line"></span><br><span class="line">4月：市场出现突破信号</span><br><span class="line">- 市场判断：可能转入趋势市</span><br><span class="line">- 策略切换：趋势跟踪策略</span><br><span class="line">- 仓位调整：初期仓位20%试探</span><br><span class="line">- 结果：突破成功，持续盈利</span><br><span class="line"></span><br><span class="line">5月-6月：趋势确立</span><br><span class="line">- 市场判断：强趋势，高确定性</span><br><span class="line">- 策略执行：严格趋势跟踪</span><br><span class="line">- 仓位配置：逐步加仓至单笔50%</span><br><span class="line">- 结果：持续盈利15%</span><br><span class="line"></span><br><span class="line">7月：趋势减弱信号</span><br><span class="line">- 市场判断：趋势可能转为震荡</span><br><span class="line">- 策略调整：减少交易频率</span><br><span class="line">- 仓位配置：降至单笔20%</span><br><span class="line">- 结果：避免了后续震荡市的大幅回撤</span><br><span class="line"></span><br><span class="line">全年收益：28%，最大回撤：6%</span><br></pre></td></tr></table></figure><hr><h2 id="四、综合应用：构建完整的回撤控制体系"><a href="#四、综合应用：构建完整的回撤控制体系" class="headerlink" title="四、综合应用：构建完整的回撤控制体系"></a>四、综合应用：构建完整的回撤控制体系</h2><h3 id="4-1-回撤控制的三层防护"><a href="#4-1-回撤控制的三层防护" class="headerlink" title="4.1 回撤控制的三层防护"></a>4.1 回撤控制的三层防护</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一层：认知层（核心）</span><br><span class="line">- 明确交易模式的回撤范围</span><br><span class="line">- 理解回撤的必然性</span><br><span class="line">- 建立回撤预期</span><br><span class="line"></span><br><span class="line">第二层：心理层（关键）</span><br><span class="line">- 严格遵循交易纪律</span><br><span class="line">- 不因回撤改变模式</span><br><span class="line">- 保持情绪稳定</span><br><span class="line"></span><br><span class="line">第三层：技术层（本质）</span><br><span class="line">- 准确判断市场状态</span><br><span class="line">- 匹配合理仓位</span><br><span class="line">- 动态风险管理</span><br></pre></td></tr></table></figure><h3 id="4-2-回撤控制检查清单"><a href="#4-2-回撤控制检查清单" class="headerlink" title="4.2 回撤控制检查清单"></a>4.2 回撤控制检查清单</h3><p><strong>交易前</strong>：</p><ul><li><input disabled="" type="checkbox"> 当前市场状态是否识别清楚？</li><li><input disabled="" type="checkbox"> 这个交易机会的确定性如何？</li><li><input disabled="" type="checkbox"> 仓位配置是否与确定性匹配？</li><li><input disabled="" type="checkbox"> 止损位置是否明确？</li><li><input disabled="" type="checkbox"> 这笔交易符合我的交易模式吗？</li></ul><p><strong>交易中</strong>：</p><ul><li><input disabled="" type="checkbox"> 市场状态是否发生变化？</li><li><input disabled="" type="checkbox"> 是否需要调整止损或仓位？</li><li><input disabled="" type="checkbox"> 当前操作是否受到情绪影响？</li></ul><p><strong>交易后</strong>：</p><ul><li><input disabled="" type="checkbox"> 这笔交易的执行质量如何？</li><li><input disabled="" type="checkbox"> 盈亏是否在预期范围内？</li><li><input disabled="" type="checkbox"> 有哪些可改进之处？</li></ul><p><strong>周度复盘</strong>：</p><ul><li><input disabled="" type="checkbox"> 本周回撤幅度是否在模式范围内？</li><li><input disabled="" type="checkbox"> 有没有违反交易纪律的情况？</li><li><input disabled="" type="checkbox"> 市场环境是否适合继续当前策略？</li></ul><p><strong>月度审视</strong>：</p><ul><li><input disabled="" type="checkbox"> 当月回撤是否超过预警线？</li><li><input disabled="" type="checkbox"> 策略有效性是否保持？</li><li><input disabled="" type="checkbox"> 是否需要调整仓位或策略参数？</li></ul><h3 id="4-3-长期视角：用正确的方式对待回撤"><a href="#4-3-长期视角：用正确的方式对待回撤" class="headerlink" title="4.3 长期视角：用正确的方式对待回撤"></a>4.3 长期视角：用正确的方式对待回撤</h3><p>交易是一场马拉松，不是百米冲刺。一个成熟的交易者理解：</p><ol><li><p><strong>回撤是成本，不是失败</strong></p><ul><li>就像商店要支付租金，交易者要承受回撤</li><li>关键是这个成本是否在可控范围内</li></ul></li><li><p><strong>平滑的资金曲线比高收益更重要</strong></p><ul><li>年化30%，最大回撤8% &gt; 年化50%，最大回撤30%</li><li>后者可能让你在最大回撤时离场，永远享受不到后面的收益</li></ul></li><li><p><strong>活下来才能复利</strong></p><ul><li>失去50%需要盈利100%才能回本</li><li>控制回撤就是保护复利的基础</li></ul></li></ol><hr><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>控制回撤的三个层次相互关联，缺一不可：</p><ol><li><p><strong>核心（认知层）</strong>：明确自己交易模式的回撤范围</p><ul><li>这是基础，不知道正常回撤是多少，就无法判断当前状态</li></ul></li><li><p><strong>关键（心理层）</strong>：守心，遵循自己的模式</p><ul><li>这是保障，知道但做不到，一切都是空谈</li></ul></li><li><p><strong>本质（技术层）</strong>：准确理解市场，匹配正确仓位</p><ul><li>这是根本，提高认知准确性才能从根本上减少回撤</li></ul></li></ol><p><strong>最后的建议</strong>：</p><ul><li>永远不要用自己承受不起的资金去交易</li><li>任何时候都保留东山再起的本金</li><li>记住：<strong>保护本金是第一要务，盈利是第二要务</strong></li></ul><blockquote><p>“在市场中生存，不是看你能赚多少，而是看你能亏多少。” —— 经典交易智慧</p></blockquote><hr><p><em>本文档旨在提供回撤控制的系统性思考框架，具体的交易策略和参数需要根据个人情况调整。</em></p>]]></content>
    
    
    <summary type="html">回撤是每个交易者都必须面对的核心问题。本文从认知层、心理层和技术层三个维度，深入探讨如何科学地控制回撤：明确交易模式的回撤范围、守心遵循自己的模式、准确理解市场并匹配正确仓位，构建完整的回撤控制体系。</summary>
    
    
    
    <category term="交易策略" scheme="https://edison-a-n.github.io/categories/%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5/"/>
    
    
    <category term="Trading" scheme="https://edison-a-n.github.io/tags/Trading/"/>
    
  </entry>
  
  <entry>
    <title>MCP 近期内容分享：从 Resources、Tools 到 Prompts 的实践探索</title>
    <link href="https://edison-a-n.github.io/2025/11/10/mcp-recent-sharing/"/>
    <id>https://edison-a-n.github.io/2025/11/10/mcp-recent-sharing/</id>
    <published>2025-11-09T16:00:00.000Z</published>
    <updated>2025-11-15T16:17:07.315Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由 AI 协助生成</div><h3 id="一、Resources、Tools-与-Prompts-的用户交互模型对比"><a href="#一、Resources、Tools-与-Prompts-的用户交互模型对比" class="headerlink" title="一、Resources、Tools 与 Prompts 的用户交互模型对比"></a>一、Resources、Tools 与 Prompts 的用户交互模型对比</h3><p>Model Context Protocol (MCP) 中的 Resources、Tools 和 Prompts 三种功能在设计理念和用户交互模型上存在显著差异。基于<a href="https://modelcontextprotocol.io/specification/2025-06-18/">MCP 官方文档</a>的规范，以下是三种功能的详细对比：</p><table><thead><tr><th>维度</th><th>Resources（资源）</th><th>Tools（工具）</th><th>Prompts（提示）</th></tr></thead><tbody><tr><td><strong>控制方式</strong></td><td>应用程序驱动（Application-driven）<br><a href="https://modelcontextprotocol.io/specification/2025-06-18/server/resources#user-interaction-model">参考文档</a></td><td>模型控制（Model-controlled）<br><a href="https://modelcontextprotocol.io/specification/2025-06-18/server/tools#user-interaction-model">参考文档</a></td><td>用户控制（User-controlled）<br><a href="https://modelcontextprotocol.io/specification/2025-06-18/server/prompts#user-interaction-model">参考文档</a></td></tr><tr><td><strong>用户交互模型描述</strong></td><td>资源设计为应用程序驱动，主机应用程序根据需要决定如何整合上下文。应用程序可以：<br>• 通过 UI 元素以树状或列表视图显式选择资源<br>• 允许用户搜索和过滤可用资源<br>• 基于启发式或 AI 模型的选择实现自动上下文包含</td><td>工具设计为模型控制，语言模型可以根据其上下文理解和用户的提示自动发现和调用工具。协议本身不强制任何特定的用户交互模型。</td><td>提示从服务器暴露给客户端，用户可以明确选择使用。通常通过用户界面中的用户发起命令触发，允许用户自然地发现和调用可用的提示。</td></tr><tr><td><strong>典型交互方式</strong></td><td>• 树状或列表视图选择<br>• 搜索和过滤<br>• 自动上下文包含</td><td>• 模型自动发现和调用<br>• 基于上下文理解自动执行</td><td>• 用户发起的命令（如斜杠命令）<br>• 明确的用户选择<br>• 自然发现和调用</td></tr><tr><td><strong>控制权归属</strong></td><td>应用程序决定如何整合和使用资源</td><td>AI 模型自动发现和调用，但需要人工确认</td><td>用户完全控制何时使用</td></tr><tr><td><strong>交互主动性</strong></td><td>被动提供，由应用程序主动选择</td><td>主动执行，由模型根据上下文自动调用</td><td>被动等待，由用户主动触发</td></tr><tr><td><strong>安全机制</strong></td><td>通过 URI 验证和访问控制保障安全<br>• 服务器必须验证所有资源 URI<br>• 对敏感资源实施访问控制</td><td>必须有人工确认环节，防止恶意或意外操作<br>• 提供清晰的工具暴露 UI<br>• 工具调用时插入视觉指示器<br>• 对操作提供确认提示</td><td>用户完全控制何时使用提示，风险相对较低</td></tr></tbody></table><h4 id="设计理念的启示"><a href="#设计理念的启示" class="headerlink" title="设计理念的启示"></a>设计理念的启示</h4><p>这三种不同的交互模型反映了 MCP 协议在不同场景下的设计考量：</p><ul><li><strong>Resources</strong> 强调应用程序的灵活性和上下文管理能力</li><li><strong>Tools</strong> 强调 AI 模型的自主性和执行能力，但必须保证安全可控</li><li><strong>Prompts</strong> 强调用户的主动性和控制权</li></ul><p>这种分层设计使得 MCP 能够同时支持自动化 AI 代理和人工辅助的交互模式，为不同类型的应用场景提供了灵活的实现方案。</p><h3 id="二、Code-Execution-with-MCP：协议应用的子集与限制"><a href="#二、Code-Execution-with-MCP：协议应用的子集与限制" class="headerlink" title="二、Code Execution with MCP：协议应用的子集与限制"></a>二、Code Execution with MCP：协议应用的子集与限制</h3><p>在实际应用中，<code>code-execution-with-mcp</code> 这类实践可以视为 MCP 协议应用的一个<strong>子集</strong>，它在某些场景下会呈现出与标准 MCP 协议不同的特征和限制。参考 <a href="https://www.anthropic.com/engineering/code-execution-with-mcp">Anthropic 的 Code Execution with MCP 实践</a>。</p><h4 id="子集特性：类似-RESTful-的请求处理"><a href="#子集特性：类似-RESTful-的请求处理" class="headerlink" title="子集特性：类似 RESTful 的请求处理"></a>子集特性：类似 RESTful 的请求处理</h4><p><code>code-execution-with-mcp</code> 的实现往往更倾向于处理类似 RESTful API 的请求模式：</p><ul><li><strong>请求-响应模式</strong>：主要关注工具调用的请求和响应，而非完整的 MCP 协议能力</li><li><strong>简化的交互</strong>：可能只实现了 MCP 协议中的部分功能，特别是 Tools 相关的功能</li><li><strong>API 化倾向</strong>：将 MCP 工具调用抽象为类似 RESTful 接口的调用方式</li></ul><p>这种实现方式虽然能够满足代码执行等特定场景的需求，但可能会丢失 MCP 协议的一些核心优势。</p><h4 id="meta-能力的潜在丢失"><a href="#meta-能力的潜在丢失" class="headerlink" title="_meta 能力的潜在丢失"></a><code>_meta</code> 能力的潜在丢失</h4><p>根据 <a href="https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#_meta">MCP 协议规范</a>，<code>_meta</code> 属性允许客户端和服务器在交互中附加额外的元数据：</p><ul><li><strong>协议级元数据</strong>：某些键名被 MCP 保留用于协议级元数据</li><li><strong>自定义元数据</strong>：实现可以添加特定用途的元数据，遵循命名规范</li><li><strong>扩展性</strong>：<code>_meta</code> 机制为协议提供了良好的扩展能力</li></ul><p>在 <code>code-execution-with-mcp</code> 这类子集实现中，<code>_meta</code> 的能力可能会丢失，原因包括：</p><ol><li><strong>简化实现</strong>：为了快速实现代码执行功能，可能跳过了 <code>_meta</code> 的支持</li><li><strong>协议理解不足</strong>：对 MCP 协议的完整理解不够深入，只关注核心功能</li><li><strong>工具链限制</strong>：使用的工具链或框架可能不支持 <code>_meta</code> 的传递和处理</li></ol><h4 id="meta-在实际应用中的丰富用途"><a href="#meta-在实际应用中的丰富用途" class="headerlink" title="_meta 在实际应用中的丰富用途"></a><code>_meta</code> 在实际应用中的丰富用途</h4><p><code>_meta</code> 不仅仅是简单的元数据容器，在实际生产环境中承载着重要的功能配置。以 <a href="https://developers.openai.com/apps-sdk/build/mcp-server#describe-your-tools">OpenAI Apps SDK</a> 为例，<code>_meta</code> 被广泛用于：</p><ul><li><strong>UI 组件关联</strong>：<code>_meta[&quot;openai/outputTemplate&quot;]</code> 将工具与 HTML UI 模板关联，实现富交互界面</li><li><strong>组件工具访问控制</strong>：<code>_meta[&quot;openai/widgetAccessible&quot;]</code> 允许组件内部发起工具调用</li><li><strong>安全策略配置</strong>：<code>_meta[&quot;openai/widgetCSP&quot;]</code> 定义内容安全策略，控制组件的外部资源访问</li><li><strong>用户体验优化</strong>：<code>_meta[&quot;openai/toolInvocation/invoking&quot;]</code> 和 <code>_meta[&quot;openai/toolInvocation/invoked&quot;]</code> 提供工具调用时的状态提示</li><li><strong>本地化支持</strong>：<code>_meta[&quot;openai/locale&quot;]</code> 支持多语言和区域化内容</li><li><strong>客户端上下文</strong>：<code>_meta[&quot;openai/userAgent&quot;]</code> 和 <code>_meta[&quot;openai/userLocation&quot;]</code> 提供客户端环境信息</li><li><strong>组件描述</strong>：<code>_meta[&quot;openai/widgetDescription&quot;]</code> 帮助模型理解组件功能，避免冗余响应</li></ul><p>这些 <code>_meta</code> 字段在实际应用中发挥着关键作用，但在 <code>code-execution-with-mcp</code> 这类简化实现中，这些高级功能往往被忽略，导致：</p><ul><li><strong>UI 交互能力受限</strong>：无法实现丰富的组件化界面</li><li><strong>安全策略缺失</strong>：缺少细粒度的安全控制机制</li><li><strong>用户体验下降</strong>：缺少状态提示和本地化支持</li><li><strong>功能扩展困难</strong>：无法利用 <code>_meta</code> 的扩展性实现定制化功能</li></ul><h4 id="实践建议"><a href="#实践建议" class="headerlink" title="实践建议"></a>实践建议</h4><p>在使用 <code>code-execution-with-mcp</code> 这类实现时，需要注意：</p><ul><li><strong>明确使用场景</strong>：理解这是 MCP 协议的子集应用，而非完整实现</li><li><strong>评估功能损失</strong>：评估丢失 <code>_meta</code> 等能力对实际应用的影响</li><li><strong>主动检查能力</strong>：需要主动检查 MCP server 的能力声明，甚至 tool 的 <code>_meta</code> 信息等，确认该 tool 是否适合按照 <code>code-execution-with-mcp</code> 的实现方式执行。并非所有 tool 都适合这种简化的执行模式</li><li><strong>保留原有方案</strong>：原本的大模型 call tool 的方案很可能还需要继续保留，作为 fallback 或用于处理不适合 <code>code-execution-with-mcp</code> 模式的 tool</li><li><strong>考虑升级路径</strong>：如果未来需要更完整的 MCP 能力，考虑向标准实现迁移</li></ul><p>这种子集实现虽然有其适用场景，但在设计系统架构时，应该充分理解其与完整 MCP 协议的差异，以便做出合适的技术选择。在实际应用中，可能需要同时支持两种执行模式，根据 tool 的特性和能力声明动态选择合适的执行方式。</p><h3 id="三、OpenAI-Apps-SDK：Resource-meta-实现-UI-组件渲染"><a href="#三、OpenAI-Apps-SDK：Resource-meta-实现-UI-组件渲染" class="headerlink" title="三、OpenAI Apps SDK：Resource + _meta 实现 UI 组件渲染"></a>三、OpenAI Apps SDK：Resource + <code>_meta</code> 实现 UI 组件渲染</h3><p><a href="https://developers.openai.com/apps-sdk/build/mcp-server#describe-your-tools">OpenAI Apps SDK</a> 通过 <strong>Resource + <code>_meta</code></strong> 的组合方式，实现了在 ChatGPT 应用中渲染 MCP server 提供的 UI 组件。这种设计巧妙地利用了 MCP 的 Resource 机制来承载 UI 组件，通过 <code>_meta</code> 来配置组件的行为和属性。</p><h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><ol><li><p><strong>注册 UI 模板资源</strong>：MCP server 通过 <code>registerResource</code> 注册一个 HTML 资源，其 <code>mimeType</code> 为 <code>text/html+skybridge</code>，资源 URI（如 <code>ui://widget/kanban-board.html</code>）成为组件的唯一标识符</p></li><li><p><strong>工具关联模板</strong>：在 tool 的 descriptor 中，通过 <code>_meta[&quot;openai/outputTemplate&quot;]</code> 将工具与资源 URI 关联，告诉 ChatGPT 当该工具被调用时应该渲染哪个 UI 组件</p></li><li><p><strong>数据注入</strong>：工具返回的 <code>structuredContent</code> 会被 ChatGPT 注入到 iframe 中，作为 <code>window.openai.toolOutput</code> 供组件使用</p></li><li><p><strong>元数据配置</strong>：通过 <code>_meta</code> 配置组件的各种属性：</p><ul><li><code>openai/widgetCSP</code>：定义内容安全策略</li><li><code>openai/widgetDomain</code>：配置组件子域名</li><li><code>openai/widgetAccessible</code>：允许组件内部发起工具调用</li><li><code>openai/widgetDescription</code>：帮助模型理解组件功能</li></ul></li></ol><h4 id="补充阅读"><a href="#补充阅读" class="headerlink" title="补充阅读"></a>补充阅读</h4><p><strong>MCP 协议的分裂风险</strong></p><p><a href="https://grapeot.me/mcp-revisited.html">grapeot 的文章</a>从另一个角度讨论了<strong>协议分裂的风险</strong>：<a href="https://developers.openai.com/apps-sdk">OpenAI Apps SDK</a> 通过 <code>_meta</code> 域创建了私有扩展（<code>openai/*</code> 命名空间），这可能导致 MCP 协议出现类似 SQL dialect 的分裂。</p><p><strong>MCP 忽视 40 年 RPC 最佳实践的风险</strong></p><p><a href="https://julsimon.medium.com/why-mcps-disregard-for-40-years-of-rpc-best-practices-will-burn-enterprises-8ef85ce5bc9b">Julien Simon 的文章</a>深入分析了 MCP 协议在企业级应用中的潜在风险。文章指出，虽然 MCP 的简洁性加速了采用，但它系统性地忽视了分布式系统领域 40 年来的经验教训，包括类型安全、分布式追踪、服务发现、版本管理等关键能力。这些缺失可能导致企业在生产环境中面临调试困难、成本归因危机、安全漏洞等严重问题。文章强调，MCP 需要从 UNIX RPC、CORBA、REST、SOAP、gRPC 等历史协议中学习，才能真正满足企业级部署的需求。</p><p><strong>MCP 联合创建者的深度访谈</strong></p><p><a href="https://a16z.com/podcast/mcp-co-creator-on-the-next-wave-of-llm-innovation/">a16z 的播客访谈</a>邀请了 Anthropic 的 David Soria Parra（MCP 联合创建者之一）深入探讨了 MCP 项目的起源、设计理念和未来发展。访谈揭示了 MCP 诞生的背景故事：为了解决在不同 AI 应用（如 Claude Desktop 和代码编辑器）之间共享工作流的 M×N 问题，David 与 Justin Spahr-Summers 共同创建了这个协议。访谈还讨论了 MCP 如何通过标准化的接口实现类似 API 生态系统的效果，让开发者能够构建一次 MCP 服务器，在多个客户端（Cursor、Claude Desktop、Goose 等）中复用，从而大大降低了集成成本。这对于理解 MCP 的设计初衷和未来发展方向具有重要参考价值。</p>]]></content>
    
    
    <summary type="html">本文是对近期接触 Model Context Protocol (MCP) 相关知识的分享，涵盖了 Resources、Tools、Prompts 等核心功能的设计理念、用户交互模型对比，以及在实际应用中的思考与实践。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="MCP" scheme="https://edison-a-n.github.io/tags/MCP/"/>
    
  </entry>
  
  <entry>
    <title>Tool Args Documentation Format Comparison Analysis</title>
    <link href="https://edison-a-n.github.io/2025/10/28/args_doc_format_comparison/"/>
    <id>https://edison-a-n.github.io/2025/10/28/args_doc_format_comparison/</id>
    <published>2025-10-27T16:00:00.000Z</published>
    <updated>2025-11-03T14:51:35.152Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tool-Args-Documentation-Format-Comparison-Analysis"><a href="#Tool-Args-Documentation-Format-Comparison-Analysis" class="headerlink" title="Tool Args Documentation Format Comparison Analysis"></a>Tool Args Documentation Format Comparison Analysis</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文档对比分析了 <a href="https://github.com/huggingface/smolagents">smolagents</a> 项目中两种不同的 <code>to_code_prompt</code> 方法中 <code>args_doc</code> 组织形式的优劣势。这两种格式分别实现在以下分支中：</p><ul><li><strong>Indent 格式</strong>: <a href="https://github.com/Edison-A-N/smolagents/tree/feature/nested-args-formatting">feature&#x2F;nested-args-formatting</a></li><li><strong>JSON 格式</strong>: <a href="https://github.com/Edison-A-N/smolagents/tree/feature/json-input-schema-formatting">feature&#x2F;json-input-schema-formatting</a></li></ul><h2 id="两种格式对比"><a href="#两种格式对比" class="headerlink" title="两种格式对比"></a>两种格式对比</h2><h3 id="1-Indent-格式-feature-x2F-nested-args-formatting"><a href="#1-Indent-格式-feature-x2F-nested-args-formatting" class="headerlink" title="1. Indent 格式 (feature&#x2F;nested-args-formatting)"></a>1. Indent 格式 (<a href="https://github.com/Edison-A-N/smolagents/tree/feature/nested-args-formatting">feature&#x2F;nested-args-formatting</a>)</h3><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>使用递归函数 <code>format_nested_args</code> 格式化嵌套参数</li><li>采用缩进层级显示参数结构</li><li><strong>智能深度限制</strong>：最大深度固定为 3 层，这是经过深思熟虑的设计决策</li><li>简洁的描述性文本格式</li></ul><p><strong>深度限制的设计理念</strong>：</p><ul><li><strong>LLM 理解优化</strong>：超过 3 层的嵌套结构会使 LLM 难以理解和准确配置参数</li><li><strong>实用性平衡</strong>：3 层深度已覆盖绝大多数实际使用场景</li><li><strong>性能考虑</strong>：避免过深的嵌套导致信息过载，影响 LLM 的决策质量</li><li><strong>可扩展性</strong>：如需要更深嵌套，可在未来版本中讨论和改进</li></ul><h4 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_items_v1_item_search</span>(<span class="params">page: integer, page_size: integer, <span class="built_in">filter</span>: <span class="built_in">object</span>, sort: array</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Search items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Important: This tool returns structured output! Use the JSON schema below to directly access fields like result[&#x27;field_name&#x27;]. NO print() statements needed to inspect the output!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        page: Page number</span></span><br><span class="line"><span class="string">        page_size: Page size</span></span><br><span class="line"><span class="string">        filter: 查询项目的请求参数</span></span><br><span class="line"><span class="string">            project_id: Project ID</span></span><br><span class="line"><span class="string">            id__in: Item ID to include, split by comma</span></span><br><span class="line"><span class="string">            tags__in: Tags name to include, split by comma</span></span><br><span class="line"><span class="string">            # ... 更多嵌套参数</span></span><br><span class="line"><span class="string">        sort (array): see tool description</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>Token 效率高</strong>：内容简洁，token 消耗少</li><li><strong>可读性强</strong>：层级结构清晰，人类容易理解</li><li><strong>简洁明了</strong>：只显示关键信息（参数名和描述）</li><li><strong>智能嵌套处理</strong>：通过 3 层深度限制，平衡了复杂性和可理解性</li><li><strong>LLM 优化设计</strong>：专门针对 LLM 的理解能力进行优化，避免信息过载</li><li><strong>实用性导向</strong>：覆盖绝大多数实际使用场景，避免过度复杂化</li></ol><h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol><li><strong>信息不完整</strong>：缺少详细的类型约束、枚举值、默认值等</li><li><strong>结构化程度低</strong>：不是标准化的 JSON Schema 格式</li><li><strong>验证信息缺失</strong>：缺少 <code>required</code>、<code>minLength</code>、<code>maxLength</code> 等验证规则</li></ol><h3 id="2-JSON-格式-feature-x2F-json-input-schema-formatting"><a href="#2-JSON-格式-feature-x2F-json-input-schema-formatting" class="headerlink" title="2. JSON 格式 (feature&#x2F;json-input-schema-formatting)"></a>2. JSON 格式 (<a href="https://github.com/Edison-A-N/smolagents/tree/feature/json-input-schema-formatting">feature&#x2F;json-input-schema-formatting</a>)</h3><h4 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>直接使用 <code>json.dumps()</code> 序列化完整的 <code>inputs</code> 字典</li><li>保持完整的 JSON Schema 结构</li><li>包含所有类型信息和约束条件</li></ul><h4 id="示例输出-1"><a href="#示例输出-1" class="headerlink" title="示例输出"></a>示例输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">search_items_v1_item_search</span>(<span class="params">page: integer, page_size: integer, <span class="built_in">filter</span>: <span class="built_in">object</span>, sort: array</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Search items</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Important: This tool returns structured output! Use the JSON schema below to directly access fields like result[&#x27;field_name&#x27;]. NO print() statements needed to inspect the output!</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        dict (input schema): This tool expects arguments that strictly adhere to the following JSON schema:</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;page&quot;: &#123;</span></span><br><span class="line"><span class="string">                    &quot;type&quot;: &quot;integer&quot;,</span></span><br><span class="line"><span class="string">                    &quot;minimum&quot;: 1.0,</span></span><br><span class="line"><span class="string">                    &quot;title&quot;: &quot;Page&quot;,</span></span><br><span class="line"><span class="string">                    &quot;description&quot;: &quot;Page number&quot;,</span></span><br><span class="line"><span class="string">                    &quot;default&quot;: 1</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                &quot;page_size&quot;: &#123;</span></span><br><span class="line"><span class="string">                    &quot;type&quot;: &quot;integer&quot;,</span></span><br><span class="line"><span class="string">                    &quot;maximum&quot;: 10000.0,</span></span><br><span class="line"><span class="string">                    &quot;minimum&quot;: 1.0,</span></span><br><span class="line"><span class="string">                    &quot;title&quot;: &quot;Page Size&quot;,</span></span><br><span class="line"><span class="string">                    &quot;description&quot;: &quot;Page size&quot;,</span></span><br><span class="line"><span class="string">                    &quot;default&quot;: 25</span></span><br><span class="line"><span class="string">                &#125;,</span></span><br><span class="line"><span class="string">                # ... 完整的 JSON Schema</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol><li><strong>信息完整</strong>：包含完整的 JSON Schema 信息</li><li><strong>标准化</strong>：符合 JSON Schema 标准，便于程序化处理</li><li><strong>详细约束</strong>：包含类型、枚举、默认值、验证规则等</li><li><strong>精确匹配</strong>：提供精确的参数结构定义</li><li><strong>未来扩展性</strong>：易于添加新的 Schema 属性</li></ol><h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol><li><strong>Token 消耗大</strong>：内容冗长，token 消耗多</li><li><strong>可读性差</strong>：对 LLM 来说，大量 JSON 结构可能造成信息过载</li><li><strong>解析复杂</strong>：LLM 需要从大量 JSON 中提取关键信息</li><li><strong>冗余信息</strong>：包含很多 LLM 可能不需要的详细约束</li></ol><h2 id="性能对比分析"><a href="#性能对比分析" class="headerlink" title="性能对比分析"></a>性能对比分析</h2><blockquote><p><strong>重要说明</strong>：以下性能数据基于前述方法的单一测试用例，仅作为定性示例展示两种格式的差异趋势，不应用于定量判断或生产环境的性能评估。实际性能可能因具体使用场景、模型类型、参数复杂度等因素而有所差异。</p></blockquote><h3 id="Token-使用量对比"><a href="#Token-使用量对比" class="headerlink" title="Token 使用量对比"></a>Token 使用量对比</h3><table><thead><tr><th>格式</th><th>Step 1 Tokens</th><th>Step 2 Tokens</th><th>总 Tokens</th><th>相对差异</th></tr></thead><tbody><tr><td>Indent 格式</td><td>53,953</td><td>108,123</td><td>162,076</td><td>基准</td></tr><tr><td>JSON 格式</td><td>76,436</td><td>153,135</td><td>229,571</td><td>+42%</td></tr></tbody></table><p><strong>结论</strong>：JSON 格式比 Indent 格式多消耗约 42% 的 tokens</p><h3 id="参数内容长度对比"><a href="#参数内容长度对比" class="headerlink" title="参数内容长度对比"></a>参数内容长度对比</h3><table><thead><tr><th>格式</th><th>输出行数</th><th>相对差异</th></tr></thead><tbody><tr><td>Indent 格式</td><td>874 行</td><td>基准</td></tr><tr><td>JSON 格式</td><td>1,269 行</td><td>+45%</td></tr></tbody></table><p><strong>结论</strong>：JSON 格式比 Indent 格式多约 45% 的内容</p><h2 id="准确性对比"><a href="#准确性对比" class="headerlink" title="准确性对比"></a>准确性对比</h2><h3 id="参数匹配准确性"><a href="#参数匹配准确性" class="headerlink" title="参数匹配准确性"></a>参数匹配准确性</h3><ul><li><strong>Indent 格式</strong>：✅ 能正确识别和匹配复杂参数</li><li><strong>JSON 格式</strong>：✅ 能正确识别和匹配复杂参数</li><li><strong>结论</strong>：两种格式的参数匹配准确性基本相同</li></ul><h3 id="任务执行结果"><a href="#任务执行结果" class="headerlink" title="任务执行结果"></a>任务执行结果</h3><ul><li><strong>Indent 格式</strong>：✅ 成功执行任务，返回正确结果 (291)</li><li><strong>JSON 格式</strong>：✅ 成功执行任务，返回正确结果 (291)</li><li><strong>结论</strong>：两种格式都能正确完成任务</li></ul><h2 id="综合评估"><a href="#综合评估" class="headerlink" title="综合评估"></a>综合评估</h2><h3 id="推荐方案：Indent-格式"><a href="#推荐方案：Indent-格式" class="headerlink" title="推荐方案：Indent 格式"></a>推荐方案：Indent 格式</h3><p>基于全面的分析，<strong>推荐使用 Indent 格式</strong>，理由如下：</p><ol><li><strong>成本效益最优</strong>：Token 消耗减少 42%，成本显著降低</li><li><strong>准确性相当</strong>：两种格式的参数匹配准确性基本相同</li><li><strong>LLM 友好</strong>：简洁的格式更适合 LLM 理解和处理</li><li><strong>实用性更强</strong>：对于大多数用例，LLM 只需要知道参数名和基本描述</li></ol><h3 id="可能的改进建议"><a href="#可能的改进建议" class="headerlink" title="可能的改进建议"></a>可能的改进建议</h3><ol><li><strong>混合方案</strong>：可以考虑在 Indent 格式基础上，为关键参数添加类型信息</li><li><strong>关键约束保留</strong>：对于重要的验证规则（如 <code>required</code>），可以在描述中体现</li><li><strong>分层显示</strong>：简单参数用 Indent 格式，复杂嵌套参数可选择 JSON 格式</li></ol><h3 id="使用场景建议"><a href="#使用场景建议" class="headerlink" title="使用场景建议"></a>使用场景建议</h3><h4 id="推荐使用-Indent-格式的场景："><a href="#推荐使用-Indent-格式的场景：" class="headerlink" title="推荐使用 Indent 格式的场景："></a>推荐使用 Indent 格式的场景：</h4><ul><li>大多数常规工具调用场景</li><li>成本敏感的应用</li><li>需要快速响应的应用</li><li>参数结构相对简单的工具</li></ul><h4 id="可考虑使用-JSON-格式的场景："><a href="#可考虑使用-JSON-格式的场景：" class="headerlink" title="可考虑使用 JSON 格式的场景："></a>可考虑使用 JSON 格式的场景：</h4><ul><li>需要严格参数验证的场景</li><li>参数结构极其复杂的工具</li><li>需要程序化处理 Schema 的场景</li><li>对成本不敏感的应用</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>基于单一测试用例的对比分析，虽然 JSON 格式提供了更完整的信息，但在测试场景中，<strong>Indent 格式在保持相同准确性的同时，显著降低了成本</strong>。更重要的是，Indent 格式的设计体现了对 LLM 认知特性的深度理解：</p><blockquote><p><strong>测试局限性说明</strong>：本分析基于特定的测试用例，实际效果可能因具体应用场景而异。建议在生产环境中进行更全面的测试验证。</p></blockquote><ol><li><strong>成本效益最优</strong>：在保持功能完整性的前提下，最大化成本效益</li><li><strong>用户体验导向</strong>：优先考虑 LLM 的理解能力和开发者的使用体验</li></ol><p><strong>最终建议</strong>：采用 Indent 格式作为默认方案，其设计哲学体现了对技术细节的深度思考。同时保留 JSON 格式作为可选的高级配置选项，以满足特殊场景的需求。这种设计既保证了实用性，又为未来的优化和改进留下了空间。</p><hr><p><em>基于分支：<a href="https://github.com/Edison-A-N/smolagents/tree/feature/nested-args-formatting">feature&#x2F;nested-args-formatting</a> vs <a href="https://github.com/Edison-A-N/smolagents/tree/feature/json-input-schema-formatting">feature&#x2F;json-input-schema-formatting</a></em></p>]]></content>
    
    
    <summary type="html">本文对比分析了 smolagents 项目中两种不同的 args_doc 组织形式（Indent 格式 vs JSON 格式），评估了它们在 Token 消耗、可读性、LLM 理解能力等方面的优劣势，并提出了推荐方案和使用场景建议。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="Tool Format" scheme="https://edison-a-n.github.io/tags/Tool-Format/"/>
    
  </entry>
  
  <entry>
    <title>ASGI Lifespan 完整指南</title>
    <link href="https://edison-a-n.github.io/2025/10/27/asgi_lifespan_complete_guide/"/>
    <id>https://edison-a-n.github.io/2025/10/27/asgi_lifespan_complete_guide/</id>
    <published>2025-10-26T16:00:00.000Z</published>
    <updated>2025-11-03T14:51:35.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#asgi-lifespan-%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0">ASGI Lifespan 协议概述</a></li><li><a href="#%E5%8D%8F%E8%AE%AE%E8%A7%84%E8%8C%83%E8%AF%A6%E8%A7%A3">协议规范详解</a></li><li><a href="#uvicorn-%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90">Uvicorn 实现分析</a></li><li><a href="#starlette-%E9%9B%86%E6%88%90%E6%9C%BA%E5%88%B6">Starlette 集成机制</a></li><li><a href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B">实际应用示例</a></li><li><a href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">最佳实践</a></li></ol><h2 id="ASGI-Lifespan-协议概述"><a href="#ASGI-Lifespan-协议概述" class="headerlink" title="ASGI Lifespan 协议概述"></a>ASGI Lifespan 协议概述</h2><h3 id="什么是-Lifespan-协议？"><a href="#什么是-Lifespan-协议？" class="headerlink" title="什么是 Lifespan 协议？"></a>什么是 Lifespan 协议？</h3><p>ASGI Lifespan 协议是 ASGI 规范的一个子协议，用于管理应用程序的启动和关闭生命周期。它允许应用程序在服务器启动时执行初始化操作（如连接数据库），在服务器关闭时执行清理操作（如关闭连接）。</p><h3 id="核心设计原则"><a href="#核心设计原则" class="headerlink" title="核心设计原则"></a>核心设计原则</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI 官方文档</a>：</p><ol><li><p><strong>单一连接模式</strong>：整个应用生命周期使用一个持久的连接</p><blockquote><p>Lifespans should be executed once per event loop that will be processing requests</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Protocol</a></p></blockquote></li><li><p><strong>事件驱动</strong>：通过特定事件类型触发启动和关闭逻辑</p></li><li><p><strong>状态管理</strong>：支持在应用状态中持久化数据</p><blockquote><p>The <code>scope[&quot;state&quot;]</code> namespace provides a place to store these sorts of things. The server will ensure that a <em>shallow copy</em> of the namespace is passed into each subsequent request&#x2F;response call into the application.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#lifespan-state">ASGI Lifespan State</a></p></blockquote></li><li><p><strong>异常安全</strong>：提供完整的错误处理机制</p><blockquote><p>If an exception is raised when calling the application callable with a <code>lifespan.startup</code> message or a <code>scope</code> with type <code>lifespan</code>, the server must continue but not send any lifespan events.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI Lifespan Scope</a></p></blockquote></li></ol><h2 id="协议规范详解"><a href="#协议规范详解" class="headerlink" title="协议规范详解"></a>协议规范详解</h2><h3 id="Scope-结构"><a href="#Scope-结构" class="headerlink" title="Scope 结构"></a>Scope 结构</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI Lifespan Scope 规范</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ASGI Lifespan Scope 结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan&quot;</span>,                    <span class="comment"># 固定值</span></span><br><span class="line">    <span class="string">&quot;asgi&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;version&quot;</span>: <span class="string">&quot;3.0&quot;</span>,                 <span class="comment"># ASGI 版本</span></span><br><span class="line">        <span class="string">&quot;spec_version&quot;</span>: <span class="string">&quot;2.0&quot;</span>             <span class="comment"># Lifespan 协议版本</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: &#123;&#125;                           <span class="comment"># 应用状态字典（可选）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>The lifespan scope exists for the duration of the event loop. The scope information passed in <code>scope</code> contains basic metadata:</p><ul><li><code>type</code> (<em>Unicode string</em>) – <code>&quot;lifespan&quot;</code></li><li><code>asgi[&quot;version&quot;]</code> (<em>Unicode string</em>) – The version of the ASGI spec</li><li><code>asgi[&quot;spec_version&quot;]</code> (<em>Unicode string</em>) – The version of this spec being used. Optional; if missing defaults to <code>&quot;1.0&quot;</code></li><li><code>state</code> Optional(<em>dict[Unicode string, Any]</em>) – An empty namespace where the application can persist state to be used when handling subsequent requests</li></ul><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html#scope">ASGI Lifespan Scope</a></p></blockquote><h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan 事件规范</a>：</p><h4 id="接收事件（receive）"><a href="#接收事件（receive）" class="headerlink" title="接收事件（receive）"></a>接收事件（receive）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭事件</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Startup - receive event</strong>: Sent to the application when the server is ready to startup and receive connections, but before it has started to do so.</p><p><strong>Shutdown - receive event</strong>: Sent to the application when the server has stopped accepting connections and closed all active connections.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Events</a></p></blockquote><h4 id="发送事件（send）"><a href="#发送事件（send）" class="headerlink" title="发送事件（send）"></a>发送事件（send）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动完成</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.complete&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动失败</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.failed&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;错误信息&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭完成</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.complete&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭失败</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.failed&quot;</span>,</span><br><span class="line">    <span class="string">&quot;message&quot;</span>: <span class="string">&quot;错误信息&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>Startup Complete - send event</strong>: Sent by the application when it has completed its startup. A server must wait for this message before it starts processing connections.</p><p><strong>Startup Failed - send event</strong>: Sent by the application when it has failed to complete its startup. If a server sees this it should log&#x2F;print the message provided and then exit.</p><p><strong>Shutdown Complete - send event</strong>: Sent by the application when it has completed its cleanup. A server must wait for this message before terminating.</p><p><strong>Shutdown Failed - send event</strong>: Sent by the application when it has failed to complete its cleanup. If a server sees this it should log&#x2F;print the message provided and then terminate.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Events</a></p></blockquote><h3 id="标准应用实现"><a href="#标准应用实现" class="headerlink" title="标准应用实现"></a>标准应用实现</h3><p>根据 <a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan 协议示例</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">app</span>(<span class="params">scope, receive, send</span>):</span><br><span class="line">    <span class="keyword">if</span> scope[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;lifespan&#x27;</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            message = <span class="keyword">await</span> receive()</span><br><span class="line">            <span class="keyword">if</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;lifespan.startup&#x27;</span>:</span><br><span class="line">                <span class="comment"># 执行启动逻辑</span></span><br><span class="line">                <span class="keyword">await</span> send(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;lifespan.startup.complete&#x27;</span>&#125;)</span><br><span class="line">            <span class="keyword">elif</span> message[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;lifespan.shutdown&#x27;</span>:</span><br><span class="line">                <span class="comment"># 执行关闭逻辑</span></span><br><span class="line">                <span class="keyword">await</span> send(&#123;<span class="string">&#x27;type&#x27;</span>: <span class="string">&#x27;lifespan.shutdown.complete&#x27;</span>&#125;)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理其他类型的请求</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>A possible implementation of this protocol is given below:</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Protocol</a></p></blockquote><h2 id="Uvicorn-实现分析"><a href="#Uvicorn-实现分析" class="headerlink" title="Uvicorn 实现分析"></a>Uvicorn 实现分析</h2><p>基于 <a href="https://github.com/encode/uvicorn">Uvicorn 源码</a> 的分析：</p><h3 id="核心实现类"><a href="#核心实现类" class="headerlink" title="核心实现类"></a>核心实现类</h3><h4 id="LifespanOn-类"><a href="#LifespanOn-类" class="headerlink" title="LifespanOn 类"></a>LifespanOn 类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uvicorn/lifespan/on.py</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LifespanOn</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, config: Config</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> config.loaded:</span><br><span class="line">            config.load()</span><br><span class="line">        </span><br><span class="line">        self.config = config</span><br><span class="line">        self.logger = logging.getLogger(<span class="string">&quot;uvicorn.error&quot;</span>)</span><br><span class="line">        self.startup_event = asyncio.Event()</span><br><span class="line">        self.shutdown_event = asyncio.Event()</span><br><span class="line">        self.receive_queue: Queue[LifespanReceiveMessage] = asyncio.Queue()</span><br><span class="line">        self.error_occured = <span class="literal">False</span></span><br><span class="line">        self.startup_failed = <span class="literal">False</span></span><br><span class="line">        self.shutdown_failed = <span class="literal">False</span></span><br><span class="line">        self.should_exit = <span class="literal">False</span></span><br><span class="line">        self.state: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="type">Any</span>] = &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">startup</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    self.logger.info(<span class="string">&quot;Waiting for application startup.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建 lifespan 主任务</span></span><br><span class="line">    loop = asyncio.get_event_loop()</span><br><span class="line">    main_lifespan_task = loop.create_task(self.main())</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送 startup 事件</span></span><br><span class="line">    startup_event: LifespanStartupEvent = &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">await</span> self.receive_queue.put(startup_event)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待应用完成启动</span></span><br><span class="line">    <span class="keyword">await</span> self.startup_event.wait()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查启动结果</span></span><br><span class="line">    <span class="keyword">if</span> self.startup_failed <span class="keyword">or</span> (self.error_occured <span class="keyword">and</span> self.config.lifespan == <span class="string">&quot;on&quot;</span>):</span><br><span class="line">        self.logger.error(<span class="string">&quot;Application startup failed. Exiting.&quot;</span>)</span><br><span class="line">        self.should_exit = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;Application startup complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="关闭流程"><a href="#关闭流程" class="headerlink" title="关闭流程"></a>关闭流程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">shutdown</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">if</span> self.error_occured:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    self.logger.info(<span class="string">&quot;Waiting for application shutdown.&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 发送 shutdown 事件</span></span><br><span class="line">    shutdown_event: LifespanShutdownEvent = &#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">await</span> self.receive_queue.put(shutdown_event)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 等待应用完成关闭</span></span><br><span class="line">    <span class="keyword">await</span> self.shutdown_event.wait()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 检查关闭结果</span></span><br><span class="line">    <span class="keyword">if</span> self.shutdown_failed <span class="keyword">or</span> (self.error_occured <span class="keyword">and</span> self.config.lifespan == <span class="string">&quot;on&quot;</span>):</span><br><span class="line">        self.logger.error(<span class="string">&quot;Application shutdown failed. Exiting.&quot;</span>)</span><br><span class="line">        self.should_exit = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        self.logger.info(<span class="string">&quot;Application shutdown complete.&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="核心通信机制"><a href="#核心通信机制" class="headerlink" title="核心通信机制"></a>核心通信机制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        app = self.config.loaded_app</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 创建 lifespan scope</span></span><br><span class="line">        scope: LifespanScope = &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan&quot;</span>,</span><br><span class="line">            <span class="string">&quot;asgi&quot;</span>: &#123;<span class="string">&quot;version&quot;</span>: self.config.asgi_version, <span class="string">&quot;spec_version&quot;</span>: <span class="string">&quot;2.0&quot;</span>&#125;,</span><br><span class="line">            <span class="string">&quot;state&quot;</span>: self.state,</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 调用应用的 lifespan 处理器</span></span><br><span class="line">        <span class="keyword">await</span> app(scope, self.receive, self.send)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> BaseException <span class="keyword">as</span> exc:</span><br><span class="line">        self.asgi = <span class="literal">None</span></span><br><span class="line">        self.error_occured = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> self.startup_failed <span class="keyword">or</span> self.shutdown_failed:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> self.config.lifespan == <span class="string">&quot;auto&quot;</span>:</span><br><span class="line">            msg = <span class="string">&quot;ASGI &#x27;lifespan&#x27; protocol appears unsupported.&quot;</span></span><br><span class="line">            self.logger.info(msg)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            msg = <span class="string">&quot;Exception in &#x27;lifespan&#x27; protocol\n&quot;</span></span><br><span class="line">            self.logger.error(msg, exc_info=exc)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.startup_event.<span class="built_in">set</span>()</span><br><span class="line">        self.shutdown_event.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><h4 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">send</span>(<span class="params">self, message: LifespanSendMessage</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">assert</span> message[<span class="string">&quot;type&quot;</span>] <span class="keyword">in</span> (</span><br><span class="line">        <span class="string">&quot;lifespan.startup.complete&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lifespan.startup.failed&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lifespan.shutdown.complete&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lifespan.shutdown.failed&quot;</span>,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.startup.complete&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.startup_event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.startup.failed&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.startup_event.<span class="built_in">set</span>()</span><br><span class="line">        self.startup_failed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&quot;message&quot;</span>):</span><br><span class="line">            self.logger.error(message[<span class="string">&quot;message&quot;</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.shutdown.complete&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.shutdown_event.<span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> message[<span class="string">&quot;type&quot;</span>] == <span class="string">&quot;lifespan.shutdown.failed&quot;</span>:</span><br><span class="line">        <span class="keyword">assert</span> self.startup_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        <span class="keyword">assert</span> <span class="keyword">not</span> self.shutdown_event.is_set(), STATE_TRANSITION_ERROR</span><br><span class="line">        self.shutdown_event.<span class="built_in">set</span>()</span><br><span class="line">        self.shutdown_failed = <span class="literal">True</span></span><br><span class="line">        <span class="keyword">if</span> message.get(<span class="string">&quot;message&quot;</span>):</span><br><span class="line">            self.logger.error(message[<span class="string">&quot;message&quot;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">receive</span>(<span class="params">self</span>) -&gt; LifespanReceiveMessage:</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> self.receive_queue.get()</span><br></pre></td></tr></table></figure><h3 id="配置选择机制"><a href="#配置选择机制" class="headerlink" title="配置选择机制"></a>配置选择机制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># uvicorn/config.py</span></span><br><span class="line">LIFESPAN: <span class="built_in">dict</span>[<span class="built_in">str</span>, <span class="built_in">str</span>] = &#123;</span><br><span class="line">    <span class="string">&quot;auto&quot;</span>: <span class="string">&quot;uvicorn.lifespan.on:LifespanOn&quot;</span>,    <span class="comment"># 自动检测</span></span><br><span class="line">    <span class="string">&quot;on&quot;</span>: <span class="string">&quot;uvicorn.lifespan.on:LifespanOn&quot;</span>,      <span class="comment"># 强制启用</span></span><br><span class="line">    <span class="string">&quot;off&quot;</span>: <span class="string">&quot;uvicorn.lifespan.off:LifespanOff&quot;</span>,   <span class="comment"># 禁用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Starlette-集成机制"><a href="#Starlette-集成机制" class="headerlink" title="Starlette 集成机制"></a>Starlette 集成机制</h2><p>基于 <a href="https://github.com/encode/starlette">Starlette 源码</a> 的分析：</p><h3 id="事件路由"><a href="#事件路由" class="headerlink" title="事件路由"></a>事件路由</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Starlette Application.__call__</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">__call__</span>(<span class="params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    scope[<span class="string">&quot;app&quot;</span>] = self</span><br><span class="line">    <span class="keyword">if</span> self.middleware_stack <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        self.middleware_stack = self.build_middleware_stack()</span><br><span class="line">    <span class="keyword">await</span> self.middleware_stack(scope, receive, send)</span><br></pre></td></tr></table></figure><h3 id="Lifespan-处理"><a href="#Lifespan-处理" class="headerlink" title="Lifespan 处理"></a>Lifespan 处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">lifespan</span>(<span class="params">self, scope: Scope, receive: Receive, send: Send</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Handle ASGI lifespan messages, which allows us to manage application</span></span><br><span class="line"><span class="string">    startup and shutdown events.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    started = <span class="literal">False</span></span><br><span class="line">    app: <span class="type">Any</span> = scope.get(<span class="string">&quot;app&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> receive()  <span class="comment"># 接收第一个 lifespan.startup 事件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> self.lifespan_context(app) <span class="keyword">as</span> maybe_state:</span><br><span class="line">            <span class="keyword">if</span> maybe_state <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> <span class="string">&quot;state&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> scope:</span><br><span class="line">                    <span class="keyword">raise</span> RuntimeError(<span class="string">&#x27;The server does not support &quot;state&quot; in the lifespan scope.&#x27;</span>)</span><br><span class="line">                scope[<span class="string">&quot;state&quot;</span>].update(maybe_state)</span><br><span class="line">            <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.complete&quot;</span>&#125;)</span><br><span class="line">            started = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">await</span> receive()  <span class="comment"># 等待 lifespan.shutdown 事件</span></span><br><span class="line">    <span class="keyword">except</span> BaseException:</span><br><span class="line">        exc_text = traceback.format_exc()</span><br><span class="line">        <span class="keyword">if</span> started:</span><br><span class="line">            <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.failed&quot;</span>, <span class="string">&quot;message&quot;</span>: exc_text&#125;)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.startup.failed&quot;</span>, <span class="string">&quot;message&quot;</span>: exc_text&#125;)</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">await</span> send(&#123;<span class="string">&quot;type&quot;</span>: <span class="string">&quot;lifespan.shutdown.complete&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="关键设计特点"><a href="#关键设计特点" class="headerlink" title="关键设计特点"></a>关键设计特点</h3><p>根据 <a href="https://github.com/encode/starlette/blob/master/starlette/routing.py">Starlette Lifespan 实现</a>：</p><ol><li><strong>一次性处理</strong>：<code>lifespan</code> 方法执行一次，处理整个应用生命周期</li><li><strong>阻塞等待</strong>：通过两次 <code>await receive()</code> 分别处理 startup 和 shutdown 事件</li><li><strong>异常安全</strong>：完整的错误处理和状态管理</li><li><strong>状态传递</strong>：支持将 lifespan 结果传递给应用状态</li></ol><blockquote><p>The lifespan protocol runs as a sibling task alongside your main application, allowing both to execute concurrently.</p><p>来源：<a href="https://www.starlette.io/lifespan/">Starlette Lifespan 文档</a></p></blockquote><h2 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h2><h3 id="基础应用"><a href="#基础应用" class="headerlink" title="基础应用"></a>基础应用</h3><p>基于 <a href="https://fastapi.tiangolo.com/advanced/events/">FastAPI Lifespan 指南</a>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> asynccontextmanager</span><br><span class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库连接</span></span><br><span class="line">db_connection = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="comment"># 启动时执行</span></span><br><span class="line">    <span class="keyword">global</span> db_connection</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Connecting to database...&quot;</span>)</span><br><span class="line">    db_connection = <span class="keyword">await</span> connect_database()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> &#123;<span class="string">&quot;database&quot;</span>: db_connection&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 关闭时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Closing database connection...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> db_connection.close()</span><br><span class="line"></span><br><span class="line">app = FastAPI(lifespan=lifespan)</span><br></pre></td></tr></table></figure><blockquote><p>You can define lifespan events (startup and shutdown) with FastAPI using a <code>lifespan</code> parameter in the <code>FastAPI</code> app.</p><p>来源：<a href="https://fastapi.tiangolo.com/advanced/events/">FastAPI Lifespan 指南</a></p></blockquote><h3 id="复杂资源管理"><a href="#复杂资源管理" class="headerlink" title="复杂资源管理"></a>复杂资源管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> AsyncExitStack</span><br><span class="line"></span><br><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">complex_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> AsyncExitStack() <span class="keyword">as</span> stack:</span><br><span class="line">        <span class="comment"># 动态管理多个资源</span></span><br><span class="line">        db = <span class="keyword">await</span> stack.enter_async_context(connect_database())</span><br><span class="line">        cache = <span class="keyword">await</span> stack.enter_async_context(connect_redis())</span><br><span class="line">        session_pool = <span class="keyword">await</span> stack.enter_async_context(create_session_pool())</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 注册清理回调</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">cleanup_logs</span>():</span><br><span class="line">            cleanup_log_files()</span><br><span class="line">        stack.callback(cleanup_logs)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">&quot;database&quot;</span>: db,</span><br><span class="line">            <span class="string">&quot;cache&quot;</span>: cache,</span><br><span class="line">            <span class="string">&quot;sessions&quot;</span>: session_pool</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># 所有资源会自动按相反顺序清理</span></span><br></pre></td></tr></table></figure><h3 id="FastMCP-集成示例"><a href="#FastMCP-集成示例" class="headerlink" title="FastMCP 集成示例"></a>FastMCP 集成示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> fastmcp <span class="keyword">import</span> FastMCP</span><br><span class="line"></span><br><span class="line">mcp = FastMCP(<span class="string">&quot;MyServer&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@mcp.lifespan</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">my_lifespan</span>(<span class="params">server</span>):</span><br><span class="line">    <span class="comment"># 启动时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Initializing MCP server...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> server.setup_tools()</span><br><span class="line">    <span class="keyword">await</span> server.connect_to_database()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> &#123;<span class="string">&quot;server&quot;</span>: server&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 关闭时执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Shutting down MCP server...&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> server.cleanup_tools()</span><br><span class="line">    <span class="keyword">await</span> server.close_database()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建应用</span></span><br><span class="line">app = mcp.create_app()</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><h3 id="1-资源管理"><a href="#1-资源管理" class="headerlink" title="1. 资源管理"></a>1. 资源管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">proper_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    resources = &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 初始化资源</span></span><br><span class="line">        resources[<span class="string">&quot;db&quot;</span>] = <span class="keyword">await</span> connect_database()</span><br><span class="line">        resources[<span class="string">&quot;cache&quot;</span>] = <span class="keyword">await</span> connect_redis()</span><br><span class="line">        resources[<span class="string">&quot;http_client&quot;</span>] = aiohttp.ClientSession()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> resources</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 确保资源被正确清理</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;http_client&quot;</span> <span class="keyword">in</span> resources:</span><br><span class="line">            <span class="keyword">await</span> resources[<span class="string">&quot;http_client&quot;</span>].close()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;cache&quot;</span> <span class="keyword">in</span> resources:</span><br><span class="line">            <span class="keyword">await</span> resources[<span class="string">&quot;cache&quot;</span>].close()</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;db&quot;</span> <span class="keyword">in</span> resources:</span><br><span class="line">            <span class="keyword">await</span> resources[<span class="string">&quot;db&quot;</span>].close()</span><br></pre></td></tr></table></figure><h3 id="2-错误处理"><a href="#2-错误处理" class="headerlink" title="2. 错误处理"></a>2. 错误处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">robust_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 启动逻辑</span></span><br><span class="line">        db = <span class="keyword">await</span> connect_database()</span><br><span class="line">        <span class="keyword">yield</span> &#123;<span class="string">&quot;database&quot;</span>: db&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="comment"># 记录错误但不阻止应用启动</span></span><br><span class="line">        logger.error(<span class="string">f&quot;Failed to initialize database: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">yield</span> &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 清理逻辑</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&#x27;db&#x27;</span> <span class="keyword">in</span> <span class="built_in">locals</span>():</span><br><span class="line">                <span class="keyword">await</span> db.close()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            logger.error(<span class="string">f&quot;Failed to close database: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="3-状态管理"><a href="#3-状态管理" class="headerlink" title="3. 状态管理"></a>3. 状态管理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">stateful_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    <span class="comment"># 初始化应用状态</span></span><br><span class="line">    app_state = &#123;</span><br><span class="line">        <span class="string">&quot;startup_time&quot;</span>: time.time(),</span><br><span class="line">        <span class="string">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">        <span class="string">&quot;environment&quot;</span>: os.getenv(<span class="string">&quot;ENV&quot;</span>, <span class="string">&quot;development&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 连接数据库</span></span><br><span class="line">    db = <span class="keyword">await</span> connect_database()</span><br><span class="line">    app_state[<span class="string">&quot;database&quot;</span>] = db</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置全局配置</span></span><br><span class="line">    app.state.config = app_state</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">yield</span> app_state</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清理</span></span><br><span class="line">    <span class="keyword">await</span> db.close()</span><br></pre></td></tr></table></figure><h3 id="4-性能监控"><a href="#4-性能监控" class="headerlink" title="4. 性能监控"></a>4. 性能监控</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asynccontextmanager</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">monitored_lifespan</span>(<span class="params">app: FastAPI</span>):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 启动监控</span></span><br><span class="line">        metrics = <span class="keyword">await</span> setup_metrics_collection()</span><br><span class="line">        <span class="keyword">yield</span> &#123;<span class="string">&quot;metrics&quot;</span>: metrics&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="comment"># 记录运行时间</span></span><br><span class="line">        runtime = time.time() - start_time</span><br><span class="line">        logger.info(<span class="string">f&quot;Application ran for <span class="subst">&#123;runtime:<span class="number">.2</span>f&#125;</span> seconds&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ASGI Lifespan 协议是现代异步 Python Web 应用的核心组件，它提供了：</p><ol><li><strong>标准化的生命周期管理</strong>：统一的启动和关闭流程</li><li><strong>异常安全保证</strong>：确保资源正确清理</li><li><strong>状态管理</strong>：支持应用状态持久化</li><li><strong>协议兼容性</strong>：与所有 ASGI 服务器兼容</li></ol><blockquote><p>The lifespan messages allow for an application to initialise and shutdown in the context of a running event loop. An example of this would be creating a connection pool and subsequently closing the connection pool to release the connections.</p><p>来源：<a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan Protocol</a></p></blockquote><p>通过合理使用 Lifespan 协议，可以构建更加健壮和可维护的异步 Web 应用。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li><a href="https://asgi.readthedocs.io/en/latest/specs/lifespan.html">ASGI Lifespan 协议规范</a></li><li><a href="https://github.com/encode/uvicorn">Uvicorn 源码</a></li><li><a href="https://www.starlette.io/lifespan/">Starlette 文档</a></li><li><a href="https://fastapi.tiangolo.com/advanced/events/">FastAPI Lifespan 指南</a></li></ul>]]></content>
    
    
    <summary type="html">本文详细介绍了ASGI Lifespan协议的规范、Uvicorn实现、Starlette集成机制，并提供了实际应用示例和最佳实践。</summary>
    
    
    
    
    <category term="ASGI, Python, FastAPI" scheme="https://edison-a-n.github.io/tags/ASGI-Python-FastAPI/"/>
    
  </entry>
  
  <entry>
    <title>MCP Output Schema：数据验证与结构化输出的技术实现</title>
    <link href="https://edison-a-n.github.io/2025/09/29/mcp-output-schema/"/>
    <id>https://edison-a-n.github.io/2025/09/29/mcp-output-schema/</id>
    <published>2025-09-28T16:00:00.000Z</published>
    <updated>2025-11-03T14:51:35.153Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由AI生成</div><h3 id="MCP-Output-Schema的核心价值与应用场景"><a href="#MCP-Output-Schema的核心价值与应用场景" class="headerlink" title="MCP Output Schema的核心价值与应用场景"></a>MCP Output Schema的核心价值与应用场景</h3><p>Model Context Protocol (MCP) 的output schema机制在复杂的数据交互场景中发挥着关键作用。基于<a href="https://modelcontextprotocol.io/specification/2025-06-18/server/tools#output-schema">MCP官方文档</a>的定义，output schema能够”验证工具结果的结构，并在验证后对包含的值进行更明智的检查”。</p><h4 id="1-数据验证与安全保障"><a href="#1-数据验证与安全保障" class="headerlink" title="1. 数据验证与安全保障"></a>1. 数据验证与安全保障</h4><p>MCP output schema的首要价值体现在数据验证层面。这一功能在与不可信服务器交互时尤为重要，它确保了：</p><ul><li><strong>结构完整性保障</strong>：服务端返回的数据必须符合预定义的schema结构</li><li><strong>异常处理机制</strong>：当数据校验失败时，服务端能够及时识别并处理异常</li><li>**<a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">安全增强</a>**：提升了与第三方服务交互时的数据安全性</li></ul><h4 id="2-结构化数据在编程环境中的直接应用"><a href="#2-结构化数据在编程环境中的直接应用" class="headerlink" title="2. 结构化数据在编程环境中的直接应用"></a>2. 结构化数据在编程环境中的直接应用</h4><p>在 <a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">PR</a> 还提到，”Making tool results available as structured data in coding environments.”这一应用场景具有极高的实用价值。参考HuggingFace的 <a href="https://www.linkedin.com/pulse/huggingface-smolagents-fast-lightweight-llm-agents-powered-mishra-v5sxc/">SmolAgents</a> 项目，我们可以看到结构化输出的重要意义：</p><ul><li><strong>直接数据使用</strong>：LLM代理能够直接消费结构化数据，无需复杂的文本解析</li><li><strong>效率提升</strong>：避免了LLM对复杂JSON结构的理解和转换过程</li><li><strong>准确性增强</strong>：减少了因解析错误导致的代码执行问题</li></ul><h3 id="LLM处理结构化数据的局限性"><a href="#LLM处理结构化数据的局限性" class="headerlink" title="LLM处理结构化数据的局限性"></a>LLM处理结构化数据的局限性</h3><h4 id="解析复杂度的挑战"><a href="#解析复杂度的挑战" class="headerlink" title="解析复杂度的挑战"></a>解析复杂度的挑战</h4><p><strong>LLM极不擅长解析结构数据</strong>，这一观点在MCP tool设计中至关重要：</p><ul><li><strong>解析复杂度</strong>：对于嵌套层次深、字段众多的JSON对象，LLM容易出现解析错误，复杂结构交给LLM解析是不合适的</li><li><strong>认知负担</strong>：复杂的数据结构会显著增加LLM的理解负担，影响响应质量和可靠性</li><li><strong>提示工程需求</strong>：需要额外的提示工程来指导LLM正确处理结构化输出，增加了使用复杂度</li></ul><h4 id="单一职责原则的重要性"><a href="#单一职责原则的重要性" class="headerlink" title="单一职责原则的重要性"></a>单一职责原则的重要性</h4><p>基于上述局限性，<strong>Tool的input和output应该尽量简单</strong>，Single Responsibility Principle在MCP tool设计中越来越显现价值：</p><ul><li><strong>职责单一化</strong>：每个tool应该专注于单一功能，避免处理过于复杂的输入输出</li><li><strong>接口简洁性</strong>：保持输入输出参数的简洁性，降低LLM的理解难度</li><li><strong>可组合性</strong>：通过简单tool的组合来实现复杂功能，而不是设计复杂的单体tool</li></ul><h3 id="Schema设计原则"><a href="#Schema设计原则" class="headerlink" title="Schema设计原则"></a>Schema设计原则</h3><p>基于Tool输入输出应该尽量简单的原则：</p><ul><li><strong>保持输出结构的简洁性和一致性</strong>，避免过度复杂</li><li><strong>避免过度嵌套和字段冗余</strong>，降低LLM解析难度</li><li><strong>提供清晰的文档说明和示例</strong>，帮助LLM正确理解</li></ul><h3 id="技术实现考量"><a href="#技术实现考量" class="headerlink" title="技术实现考量"></a>技术实现考量</h3><h4 id="数据验证机制"><a href="#数据验证机制" class="headerlink" title="数据验证机制"></a>数据验证机制</h4><p>MCP output schema通过以下机制确保数据质量：</p><ol><li><strong>结构验证</strong>：检查返回数据是否符合预定义的JSON schema</li><li><strong>类型检查</strong>：验证数据类型是否匹配预期</li><li><strong>必填字段验证</strong>：确保关键字段不为空</li><li><strong>格式验证</strong>：检查字符串格式、数值范围等</li></ol><h4 id="错误处理策略"><a href="#错误处理策略" class="headerlink" title="错误处理策略"></a>错误处理策略</h4><p>当schema验证失败时，系统应该：</p><ul><li><strong>提供清晰的错误信息</strong>，说明具体哪个字段验证失败</li><li><strong>记录详细的日志</strong>，便于调试和问题排查</li><li><strong>优雅降级</strong>，在验证失败时提供默认值或跳过该字段</li><li><strong>重试机制</strong>，对于临时性错误提供重试机会</li></ul><h3 id="最佳实践建议"><a href="#最佳实践建议" class="headerlink" title="最佳实践建议"></a>最佳实践建议</h3><h4 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1. 设计原则"></a>1. 设计原则</h4><ul><li><strong>保持简单</strong>：避免过度复杂的嵌套结构</li><li><strong>一致性</strong>：在整个系统中保持schema的一致性</li><li><strong>文档化</strong>：为每个字段提供清晰的说明和示例</li><li><strong>版本控制</strong>：考虑schema的向后兼容性</li></ul><h4 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h4><ul><li><strong>缓存机制</strong>：对频繁调用的schema进行缓存</li><li><strong>批量处理</strong>：支持批量数据验证</li><li><strong>异步处理</strong>：对于复杂验证使用异步处理</li><li><strong>监控指标</strong>：监控验证成功率和性能指标</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>MCP Output Schema通过结构验证确保数据完整性和安全性，结构化输出减少了LLM的解析负担，统一的schema设计提高了系统的可维护性。</p><p>通过合理应用MCP Output Schema，遵循单一职责原则，优化schema结构，我们可以构建更加可靠、高效的AI代理系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://github.com/modelcontextprotocol/modelcontextprotocol/pull/371">MCP Output Schema Proposal</a></li><li><a href="https://www.linkedin.com/pulse/huggingface-smolagents-fast-lightweight-llm-agents-powered-mishra-v5sxc/">HuggingFace SmolAgents</a></li><li><a href="https://modelcontextprotocol.io/">MCP Official Documentation</a></li></ol>]]></content>
    
    
    <summary type="html">本文深入探讨了MCP Output Schema在数据验证、安全保障和结构化输出方面的核心价值，分析了LLM处理结构化数据的局限性，并提出了基于单一职责原则的Schema设计最佳实践，为构建可靠的AI代理系统提供技术指导。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="MCP" scheme="https://edison-a-n.github.io/tags/MCP/"/>
    
  </entry>
  
  <entry>
    <title>停止转换REST API到MCP：设计AI原生接口的正确方式</title>
    <link href="https://edison-a-n.github.io/2025/09/29/stop-converting-rest-api-to-mcp/"/>
    <id>https://edison-a-n.github.io/2025/09/29/stop-converting-rest-api-to-mcp/</id>
    <published>2025-09-28T16:00:00.000Z</published>
    <updated>2025-11-03T14:51:35.153Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由AI生成</div><h3 id="为什么开发者想要转换REST-API到MCP"><a href="#为什么开发者想要转换REST-API到MCP" class="headerlink" title="为什么开发者想要转换REST API到MCP"></a>为什么开发者想要转换REST API到MCP</h3><p>随着AI代理的兴起，许多开发者面临一个现实需求：如何让现有的REST API能够被LLM直接使用。这催生了各种自动转换工具，如 <a href="https://github.com/tadata-org/fastapi_mcp">fastapi_mcp</a> 和 <a href="https://gofastmcp.com/integrations/fastapi#mounting-an-mcp-server">FastMCP 的 <code>from_openapi()</code> 功能</a>，它们基于 OpenAPI 规范自动将 Web API 转换为符合 MCP Tool 规范的接口。</p><p>这种转换看似便利，但实际上存在根本性问题。</p><h3 id="自动转换的陷阱"><a href="#自动转换的陷阱" class="headerlink" title="自动转换的陷阱"></a>自动转换的陷阱</h3><p>正如 Jeremiah Lowin 在 <a href="https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp">Stop Converting Your REST APIs to MCP</a> 一文中指出的，”为人类构建的 API 会毒害你的 AI 代理”。自动转换工具虽然方便，但存在以下根本性问题：</p><h4 id="1-上下文污染"><a href="#1-上下文污染" class="headerlink" title="1. 上下文污染"></a>1. 上下文污染</h4><ul><li><strong>Token成本</strong>：LLM 必须处理每个工具的名称、描述和参数，每个端点都是需要支付token和延迟成本的税</li><li><strong>认知负担</strong>：过多的工具选择会淹没LLM的决策能力</li><li><strong>无关内容干扰</strong>：人类开发者擅长发现并忽略无关内容，但LLM会被过多的选择淹没</li></ul><h4 id="2-原子性反模式"><a href="#2-原子性反模式" class="headerlink" title="2. 原子性反模式"></a>2. 原子性反模式</h4><ul><li><strong>昂贵往返</strong>：每个工具调用都是昂贵的往返过程</li><li><strong>链式调用问题</strong>：强制代理链式调用多个原子调用既缓慢又容易出错</li><li><strong>状态管理复杂</strong>：多个原子操作之间的状态同步变得困难</li></ul><h4 id="3-选择过载"><a href="#3-选择过载" class="headerlink" title="3. 选择过载"></a>3. 选择过载</h4><ul><li><strong>决策瘫痪</strong>：过多的工具选择导致LLM难以做出最优决策</li><li><strong>性能下降</strong>：选择过载会显著影响响应时间和准确性</li><li><strong>维护困难</strong>：复杂的工具集合难以维护和调试</li></ul><h3 id="传统API设计与AI原生接口的根本差异"><a href="#传统API设计与AI原生接口的根本差异" class="headerlink" title="传统API设计与AI原生接口的根本差异"></a>传统API设计与AI原生接口的根本差异</h3><h4 id="设计理念的差异"><a href="#设计理念的差异" class="headerlink" title="设计理念的差异"></a>设计理念的差异</h4><p><strong>传统REST API设计</strong>：</p><ul><li>面向人类开发者</li><li>强调资源导向</li><li>支持复杂的查询和过滤</li><li>提供丰富的元数据</li></ul><p><strong>AI原生MCP接口设计</strong>：</p><ul><li>面向LLM代理</li><li>强调任务导向</li><li>简化输入输出</li><li>最小化认知负担</li></ul><h4 id="交互模式的差异"><a href="#交互模式的差异" class="headerlink" title="交互模式的差异"></a>交互模式的差异</h4><p><strong>人类交互模式</strong>：</p><ul><li>可以处理复杂的UI交互</li><li>能够理解上下文和隐含信息</li><li>可以处理多步骤的复杂流程</li><li>能够从错误中学习和调整</li></ul><p><strong>AI交互模式</strong>：</p><ul><li>需要明确的指令和参数</li><li>依赖结构化的输入输出</li><li>难以处理复杂的多步骤流程</li><li>对错误和异常处理要求更高</li></ul><h3 id="存量API适配的现实挑战"><a href="#存量API适配的现实挑战" class="headerlink" title="存量API适配的现实挑战"></a>存量API适配的现实挑战</h3><h4 id="1-处理逻辑依赖前端交互"><a href="#1-处理逻辑依赖前端交互" class="headerlink" title="1. 处理逻辑依赖前端交互"></a>1. 处理逻辑依赖前端交互</h4><p>大多数传统API设计面向客户端交互，具有以下特点：</p><ul><li><strong>业务逻辑耦合</strong>：处理逻辑严重依赖前端交互模式，不适合 LLM 直接使用</li><li><strong>客户端集成复杂</strong>：客户端集成复杂度极高，难以直接交给 LLM 思考并使用</li><li><strong>缺乏清晰映射</strong>：缺乏清晰的资源-行为映射关系，增加了 LLM 的理解复杂度</li></ul><h4 id="2-RESTful设计的一致性问题"><a href="#2-RESTful设计的一致性问题" class="headerlink" title="2. RESTful设计的一致性问题"></a>2. RESTful设计的一致性问题</h4><p>即使是公开API，如果无法保证：</p><ul><li><strong>资源行为分离</strong>：资源(resource)和行为(action)的清晰分离</li><li><strong>URI设计一致性</strong>：比如 resource&#x2F;<id>&#x2F;action与action&#x2F;resource混用，即使是细微差别也会提高LLM的理解复杂度</li><li><strong>统一错误处理</strong>：统一的错误处理和状态码机制</li></ul><p>都会显著增加LLM理解和使用API的难度，进而造成call API错误。</p><h3 id="正确的设计方式：从代理故事-Agent-Story-开始"><a href="#正确的设计方式：从代理故事-Agent-Story-开始" class="headerlink" title="正确的设计方式：从代理故事(Agent Story)开始"></a>正确的设计方式：从代理故事(Agent Story)开始</h3><h4 id="1-引导而非部署"><a href="#1-引导而非部署" class="headerlink" title="1. 引导而非部署"></a>1. 引导而非部署</h4><p>基于 Jeremiah Lowin 的观点，自动转换工具应该遵循以下原则：</p><ul><li><strong>快速探索</strong>：使用自动转换功能进行快速探索和内部演示</li><li><strong>不要部署到生产</strong>：避免将转换后的API直接部署到生产环境</li><li><strong>学习工具</strong>：将转换作为学习和理解现有API的工具</li></ul><h4 id="2-积极策划"><a href="#2-积极策划" class="headerlink" title="2. 积极策划"></a>2. 积极策划</h4><p>将策划作为构建代理的核心部分：</p><ul><li><strong>创建新版本</strong>：使用转换功能创建新的LLM友好版本</li><li><strong>重新设计</strong>：基于AI代理的需求重新设计接口</li><li><strong>优化体验</strong>：专注于提升AI代理的使用体验</li></ul><h4 id="3-从代理故事开始"><a href="#3-从代理故事开始" class="headerlink" title="3. 从代理故事开始"></a>3. 从代理故事开始</h4><p>为关键工作流构建新的最小化MCP服务器：</p><ul><li><strong>需求驱动</strong>：从代理需求出发而非API规范</li><li><strong>任务导向</strong>：围绕具体任务设计接口</li><li><strong>简化设计</strong>：避免过度复杂的功能设计</li></ul><h3 id="设计AI原生MCP接口的最佳实践"><a href="#设计AI原生MCP接口的最佳实践" class="headerlink" title="设计AI原生MCP接口的最佳实践"></a>设计AI原生MCP接口的最佳实践</h3><h4 id="1-直接构建MCP原生服务"><a href="#1-直接构建MCP原生服务" class="headerlink" title="1. 直接构建MCP原生服务"></a>1. 直接构建MCP原生服务</h4><ul><li><strong>避免中间层</strong>：直接构建符合MCP规范的HTTP服务，避免搭建web API再套壳</li><li><strong>协议层面考虑</strong>：从协议层面考虑LLM的使用模式</li><li><strong>AI代理优化</strong>：建立专门为AI代理优化的接口设计</li></ul><h4 id="2-持续优化"><a href="#2-持续优化" class="headerlink" title="2. 持续优化"></a>2. 持续优化</h4><ul><li><strong>性能监控</strong>：监控接口的使用性能和成功率</li><li><strong>用户反馈</strong>：收集AI代理使用过程中的反馈</li><li><strong>迭代改进</strong>：基于使用情况持续优化接口设计</li></ul><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>AI代理的承诺不仅仅是让现有软件变得”健谈”，而是设计更简洁、更有意图、以机器为先的接口的机会。</p><p><strong>停止转换你的REST API，开始策划它们</strong>：从代理故事(Agent Story)开始，直接构建AI原生的MCP接口，而不是简单地将人类设计的API强加给AI系统。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="https://www.jlowin.dev/blog/stop-converting-rest-apis-to-mcp">Stop Converting Your REST APIs to MCP</a></li><li><a href="https://gofastmcp.com/integrations/fastapi#mounting-an-mcp-server">FastMCP FastAPI Integration</a></li><li><a href="https://github.com/tadata-org/fastapi_mcp">fastapi_mcp</a></li><li><a href="https://modelcontextprotocol.io/">MCP Official Documentation</a></li></ol>]]></content>
    
    
    <summary type="html">本文分析了自动转换REST API到MCP的陷阱和问题，探讨了传统API设计与AI原生接口的根本差异，提出了从代理故事开始设计、遵循单一职责原则等最佳实践，为构建真正适合AI代理的接口提供设计指导。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
    <category term="MCP" scheme="https://edison-a-n.github.io/tags/MCP/"/>
    
    <category term="API Design" scheme="https://edison-a-n.github.io/tags/API-Design/"/>
    
  </entry>
  
  <entry>
    <title>大型语言模型在处理大批量数据时的一致性挑战与解决方案</title>
    <link href="https://edison-a-n.github.io/2025/09/20/llm-consistency-challenges-large-data-processing/"/>
    <id>https://edison-a-n.github.io/2025/09/20/llm-consistency-challenges-large-data-processing/</id>
    <published>2025-09-20T09:12:33.000Z</published>
    <updated>2025-11-03T14:51:35.153Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #666; font-style: italic; font-size: 0.9em; margin-bottom: 1em;">本文内容由AI生成</div><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大型语言模型（LLM）在处理大批量数据时面临着显著的一致性挑战。这些挑战主要源于LLM的注意力机制和上下文窗口的限制，导致在处理复杂数据任务时可能出现不一致、幻觉等问题。本文将深入探讨这些挑战及其解决方案。</p><h2 id="LLM的一致性挑战"><a href="#LLM的一致性挑战" class="headerlink" title="LLM的一致性挑战"></a>LLM的一致性挑战</h2><h3 id="1-🌀-前后不一致性"><a href="#1-🌀-前后不一致性" class="headerlink" title="1. 🌀 前后不一致性"></a>1. 🌀 前后不一致性</h3><p>LLM在处理过程中可能忘记之前的操作，导致结果不连贯。这种问题在处理需要多步推理或长期记忆的任务时尤为明显。</p><h3 id="2-🎭-幻觉问题"><a href="#2-🎭-幻觉问题" class="headerlink" title="2. 🎭 幻觉问题"></a>2. 🎭 幻觉问题</h3><p>模型可能生成与实际数据不符的内容，产生所谓的”幻觉”现象。这在数据密集型应用中可能导致严重的错误。</p><h3 id="3-📏-上下文溢出"><a href="#3-📏-上下文溢出" class="headerlink" title="3. 📏 上下文溢出"></a>3. 📏 上下文溢出</h3><p>当输入数据超过模型的上下文窗口时，模型无法有效处理全部信息，导致数据被截断或忽略。</p><h3 id="4-🧠-无状态性"><a href="#4-🧠-无状态性" class="headerlink" title="4. 🧠 无状态性"></a>4. 🧠 无状态性</h3><p>LLM缺乏内置的记忆机制，无法追踪已处理的数据项或状态，这使得持续性的数据处理任务变得困难。</p><h2 id="解决方案与策略"><a href="#解决方案与策略" class="headerlink" title="解决方案与策略"></a>解决方案与策略</h2><h3 id="1-🤝-LLM与外部工具结合"><a href="#1-🤝-LLM与外部工具结合" class="headerlink" title="1. 🤝 LLM与外部工具结合"></a>1. 🤝 LLM与外部工具结合</h3><p>让LLM负责决策和流程控制，而将具体的数据操作交由专门的完成。这种分工明确的架构能够充分发挥各自的优势。</p><h3 id="2-📚-使用索引系统管理数据"><a href="#2-📚-使用索引系统管理数据" class="headerlink" title="2. 📚 使用索引系统管理数据"></a>2. 📚 使用索引系统管理数据</h3><p>将大批量数据存储并索引化，LLM通过引用索引来访问数据，而不直接处理数据内容。这种方法有效解决了上下文窗口的限制问题。</p><h3 id="3-🔄-采用工作流（Workflow）模式"><a href="#3-🔄-采用工作流（Workflow）模式" class="headerlink" title="3. 🔄 采用工作流（Workflow）模式"></a>3. 🔄 采用工作流（Workflow）模式</h3><p>LLM生成操作指令或代码片段，由外部环境执行，并将结果反馈给LLM。这种迭代式的处理方式确保了数据处理的准确性和一致性。</p><h3 id="4-📊-优化元数据设计"><a href="#4-📊-优化元数据设计" class="headerlink" title="4. 📊 优化元数据设计"></a>4. 📊 优化元数据设计</h3><p>精心设计数据的metadata结构，包括数据类型、关系描述、时间戳、来源信息等。良好的元数据不仅帮助LLM更好地理解数据，还能提高检索效率和准确性，减少幻觉和不一致问题的发生。</p><h2 id="实践案例"><a href="#实践案例" class="headerlink" title="实践案例"></a>实践案例</h2><h3 id="🦙-LlamaIndex"><a href="#🦙-LlamaIndex" class="headerlink" title="🦙 LlamaIndex"></a>🦙 LlamaIndex</h3><p>该项目将文档或数据索引化，LLM负责查询计划与任务调度，数据的读写由外部工具完成。这种架构设计有效分离了逻辑控制和数据操作。</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/run-llama/llama_index">https://github.com/run-llama/llama_index</a></li></ul><h3 id="🤖-AutoGPT"><a href="#🤖-AutoGPT" class="headerlink" title="🤖 AutoGPT"></a>🤖 AutoGPT</h3><p>LLM作为”指挥官”，调用外部工具（如文件系统、API、数据库）完成任务，避免直接操作数据。这种模式在处理复杂任务时表现出色。</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/Significant-Gravitas/AutoGPT">https://github.com/Significant-Gravitas/AutoGPT</a></li></ul><h3 id="🐍-smolagent"><a href="#🐍-smolagent" class="headerlink" title="🐍 smolagent"></a>🐍 smolagent</h3><p>LLM生成Python脚本，由沙箱环境执行，LLM仅负责逻辑控制。这种方法确保了数据处理的准确性和安全性。</p><ul><li><strong>GitHub</strong>: <a href="https://github.com/microsoft/smolagent">https://github.com/microsoft/smolagent</a></li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过将LLM与外部工具结合、使用索引系统管理数据以及采用工作流模式，我们可以有效提升LLM在处理大批量数据时的一致性和可靠性。这些解决方案不仅解决了LLM的内在限制，还为构建更强大、更可靠的AI系统提供了可行的路径。</p><p>未来，随着技术的不断发展，我们期待看到更多创新的方法来进一步优化LLM在数据处理方面的表现，推动人工智能技术在各个领域的深入应用。</p>]]></content>
    
    
    <summary type="html">本文探讨了LLM在处理大批量数据时面临的前后不一致性、幻觉问题、上下文溢出和无状态性等挑战，并提出了LLM与外部工具结合、使用索引系统管理数据、采用工作流模式等解决方案。</summary>
    
    
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/categories/AI-Agent/"/>
    
    
    <category term="LLM" scheme="https://edison-a-n.github.io/tags/LLM/"/>
    
    <category term="AI Agent" scheme="https://edison-a-n.github.io/tags/AI-Agent/"/>
    
  </entry>
  
  <entry>
    <title>nextjs-pagination</title>
    <link href="https://edison-a-n.github.io/2024/02/01/nextjs-pagination/"/>
    <id>https://edison-a-n.github.io/2024/02/01/nextjs-pagination/</id>
    <published>2024-02-01T09:11:31.000Z</published>
    <updated>2025-09-26T13:39:44.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node: v20.11.0</span><br><span class="line">npm: 10.2.4</span><br><span class="line">next: 14.1.0</span><br></pre></td></tr></table></figure><h2 id="初始化应用"><a href="#初始化应用" class="headerlink" title="初始化应用"></a>初始化应用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-next-app</span><br></pre></td></tr></table></figure><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a><a href="https://nextjs.org/docs/app/building-your-application/rendering/client-components">客户端渲染</a></h2><ul><li>客户端渲染要求自身及子组件都是客户端渲染，即都需要上声明 <code>&#39;use client&#39;</code></li><li><code>state</code> 触发整个 DOM 重新渲染，所以使用必须是客户端渲染</li><li>客户端重新渲染，页面内容也要更新，所以描述页面的 DOM 也被当作客户端渲染组件，也需要声明 <code>&#39;use client&#39;</code>; 所以该组件不能以 <a href="https://react.dev/learn/passing-props-to-a-component">children</a> 组件传入。</li></ul><p>理解了客户端渲染的方式，就可以很容易的实现分页了。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/page.tsx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; cache &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">PaginatedData</span>, <span class="title class_">Pagination</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./pagination&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getData = <span class="title function_">cache</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">data</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="string">&#x27;a&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">name</span>: <span class="string">&#x27;b&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">name</span>: <span class="string">&#x27;c&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">4</span>, <span class="attr">name</span>: <span class="string">&#x27;d&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">5</span>, <span class="attr">name</span>: <span class="string">&#x27;e&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">6</span>, <span class="attr">name</span>: <span class="string">&#x27;f&#x27;</span> &#125;,</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="title function_">getData</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Pagination</span> <span class="attr">data</span>=<span class="string">&#123;data.data&#125;</span> <span class="attr">itemsPerPage</span>=<span class="string">&#123;2&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">paginationEle</span>=<span class="string">&#123;PaginatedData&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/pagination.tsx</span></span><br><span class="line"><span class="comment">// 由 GPT-4 自动生成</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;use client&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">Pagination</span>(<span class="params">&#123; data, itemsPerPage, paginationEle &#125;: &#123;</span></span><br><span class="line"><span class="params">    data: <span class="built_in">any</span>[]</span></span><br><span class="line"><span class="params">    itemsPerPage: <span class="built_in">number</span></span></span><br><span class="line"><span class="params">    paginationEle: (data: <span class="built_in">any</span>[]) =&gt; JSX.Element</span></span><br><span class="line"><span class="params">&#125;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> [currentPage, setCurrentPage] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> maxPage = <span class="title class_">Math</span>.<span class="title function_">ceil</span>(data.<span class="property">length</span> / itemsPerPage) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> start = currentPage * itemsPerPage</span><br><span class="line">    <span class="keyword">const</span> end = start + itemsPerPage</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;paginationEle(data.slice(start, end))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;flex justify-between my-4 space-x-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">disabled</span>=<span class="string">&#123;currentPage</span> === <span class="string">0&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentPage(currentPage - 1)&#125;</span></span><br><span class="line"><span class="language-xml">                    className=&#123;`px-4 py-2 rounded shadow $&#123;currentPage === 0 ? &#x27;bg-gray-300&#x27; : &#x27;bg-gray-500 hover:bg-gray-700&#x27;&#125; text-white`&#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                    Previous</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">disabled</span>=<span class="string">&#123;currentPage</span> === <span class="string">maxPage&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setCurrentPage(currentPage + 1)&#125;</span></span><br><span class="line"><span class="language-xml">                    className=&#123;`px-4 py-2 rounded shadow $&#123;currentPage === maxPage ? &#x27;bg-gray-300&#x27; : &#x27;bg-gray-500 hover:bg-gray-700&#x27;&#125; text-white`&#125;</span></span><br><span class="line"><span class="language-xml">                &gt;</span></span><br><span class="line"><span class="language-xml">                    Next</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">PaginatedData</span>(<span class="params">data: <span class="built_in">any</span>[]</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;data.map((item) =&gt; (</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span>&#123;item.id&#125;: &#123;item.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>smart-contract-demo</title>
    <link href="https://edison-a-n.github.io/2023/09/20/smart-contract-demo/"/>
    <id>https://edison-a-n.github.io/2023/09/20/smart-contract-demo/</id>
    <published>2023-09-20T05:43:19.000Z</published>
    <updated>2023-12-27T13:38:42.484Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构建一个DAPP的demo"><a href="#构建一个DAPP的demo" class="headerlink" title="构建一个DAPP的demo"></a>构建一个DAPP的demo</h1><hr><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.dappuniversity.com/articles/how-to-build-a-blockchain-app">How To Build A Blockchain App with Ethereum, Web3.js &amp; Solidity Smart Contracts</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;构建一个DAPP的demo&quot;&gt;&lt;a href=&quot;#构建一个DAPP的demo&quot; class=&quot;headerlink&quot; title=&quot;构建一个DAPP的demo&quot;&gt;&lt;/a&gt;构建一个DAPP的demo&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多租户应用与架构设计关注点</title>
    <link href="https://edison-a-n.github.io/2023/08/30/multi-tenant/"/>
    <id>https://edison-a-n.github.io/2023/08/30/multi-tenant/</id>
    <published>2023-08-29T23:12:32.000Z</published>
    <updated>2023-12-27T13:38:42.484Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇是关于多租户应用与架构设计关注点的一些自己的思考。本篇强调多租户本质是支持共享与隔离。同时提到应用架构可能的形式以及多租户集成的设计。核心的关注点强调了对业务未来长期的判断决定了隔离粒度，最终决定了业务应用的产品架构与技术架构设计。 本篇更多是提供一些启发，供商业规划、业务负责人、技术解决方案提供方在做多租户集成时，进行参考。本篇不作为多租户服务提供者的设计建议。</p></blockquote><h1 id="什么是多租户"><a href="#什么是多租户" class="headerlink" title="什么是多租户"></a>什么是多租户</h1><p>多租户是一种实现资源共享与隔离的架构。</p><h2 id="一、共享"><a href="#一、共享" class="headerlink" title="一、共享"></a>一、共享</h2><p><strong>用户不可直接触达的资源必然是共享。</strong></p><ul><li>共享是为降本增效，最重要还是为了增效。</li><li>计算资源有效运行时间</li><li>存储空间有效利用</li><li>降低应用维护、多集群维护、观测系统搭建、维护人员投入等成本</li></ul><p>有的服务可能不允许共享</p><ul><li>数据安全考虑，要求强隔离，比如独立的存储、独立的数据库、独立的计算集群、网络访问限制只允许在一个孤岛中计算</li><li>私有化部署，所有组件都在自己的运行环境中 这种情况下，多租户的解决方案要解决的问题并不存在。</li></ul><blockquote><p><strong>可以这么说，如果没有共享资源的需求和架构设计，完全不需要应用多租户。</strong></p></blockquote><h2 id="二、隔离"><a href="#二、隔离" class="headerlink" title="二、隔离"></a>二、隔离</h2><p><strong>共享架构下，用户访问需要一个逻辑隔离的环境。</strong></p><ul><li>计算资源隔离：集群配额，计算资源使用优先级，独占集群，用户自主提供的集群</li><li>存储资源隔离：逻辑路径(Unix路径)&#x2F;逻辑库&#x2F;逻辑服务，存储服务使用不互相干扰（某个租户大量请求造成存储服务触及峰值不影响其他租户使用），</li><li>网络资源隔离：带宽使用</li></ul><h1 id="核心关注点"><a href="#核心关注点" class="headerlink" title="核心关注点"></a>核心关注点</h1><h2 id="一、SAAS-尽早做多租户设计规划"><a href="#一、SAAS-尽早做多租户设计规划" class="headerlink" title="一、SAAS 尽早做多租户设计规划"></a>一、SAAS 尽早做多租户设计规划</h2><p>越早规划，越早预留扩展能力。</p><p>一旦自研服务设计不合适，业务逻辑耦合了应用内部的用户和权限，后期只能被当做第三方服务接入。这种情形下隔离和共享难支持，可能会被迫为每个租户提供单独的部署与维护支持。</p><h2 id="二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定"><a href="#二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定" class="headerlink" title="二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定"></a>二、隔离粒度是一个复杂点，跟业务发展息息相关，由业务预估和方向判断决定</h2><p>隔离粒度决定了用户看到的资源是什么样的。</p><p>举例来讲，一个果园由多个人承包，按地隔离，拥有者就会盯着土地划界；按拥有多少果树隔离，拥有者就会算着自己的果树；按产出的斤两隔离，拥有者只会盯着最后的果实。</p><p>所以隔离粒度，是业务决定的，是商业模式销售模式决定的，最终由技术架构实现支持。 技术架构往往落地之后会运行相当一段时间。隔离粒度的决策，需要对长期的业务发展方向进行评估。</p><h2 id="三、Access-层是核心处理多租户信息的组件，Business-层是对多租户的实现"><a href="#三、Access-层是核心处理多租户信息的组件，Business-层是对多租户的实现" class="headerlink" title="三、Access 层是核心处理多租户信息的组件，Business 层是对多租户的实现"></a>三、Access 层是核心处理多租户信息的组件，Business 层是对多租户的实现</h2><p>当你已经意识到并且早早地开始做多租户设计，当你已经对隔离粒度有一个比较明确的方向判断，就要开始对分层做设计和实现了。 最基本的设计是两层，</p><ul><li>Access 层负责支持验证和访问控制，生成 tenant 的 info 信息。</li><li>Business 层只依赖 tenant_id，不做其他的耦合。</li></ul><p><img src="/../images/tenant.png" alt="示例图"></p><h1 id="补充关注点"><a href="#补充关注点" class="headerlink" title="补充关注点"></a>补充关注点</h1><h2 id="一、微服务架构下，访问各个服务与资源的方式"><a href="#一、微服务架构下，访问各个服务与资源的方式" class="headerlink" title="一、微服务架构下，访问各个服务与资源的方式"></a>一、微服务架构下，访问各个服务与资源的方式</h2><ol><li><p>直接访问</p></li><li><p>Access 层会申请访问需要的资源的 <code>access_token</code></p></li><li><p>租户会分配到一个 <code>tenant_id</code> 并携带一些 metadata 信息, <code>OIDC</code> 协议的 <code>token</code> 可以解析出来</p></li><li><p>代理租户访问资源与服务</p></li></ol><p>这种模式相当于有一个agent，负责带着租户去访问各种资源，本质上还是租户自己在访问。同时，这种模式要求 agent 有自己的认证与访问控制判断实现，并且可以联通租户管理系统执行租户的验证。</p><ul><li><p>agent由于取得了资源代理人的资格，得到了服务提供者的信任，也拥有足够的权限，可以直接访问一部分资源，减少一些鉴权工作。</p></li><li><p>对于部分安全要求高的资源访问，仍然需要校验租户的权限，形式可能从<code>access_token</code>中解析，也可能拿着 <code>tenant_id</code> 去租户中心校验</p></li><li><p>租户只是一个标签</p><ul><li>强化 agent 的能力，弱化 tenant 的能力。</li><li>agent 相当于拿着一个 tenant_id 标识走一遍整个服务，并对资源访问做标签操作。 这时候的 agent 可以不理会 tenant 的任何实现。</li><li>要求 agent 对 tenant 有极高的信任；</li><li>要求访问的服务支持 agent 访问</li></ul></li></ul><h2 id="二、多租户服务提供者可能需要提供什么"><a href="#二、多租户服务提供者可能需要提供什么" class="headerlink" title="二、多租户服务提供者可能需要提供什么"></a>二、多租户服务提供者可能需要提供什么</h2><ol><li>用户、用户组多级管理</li><li>支持虚拟用户、用户灵活分组。</li><li>支持将组当做一个租户</li><li>支持一个真实用户可以拥有多个不同的租户身份</li><li>强大的配置能力 支持业务应用将各类权限数据灵活的配置到多租户服务提供者上</li></ol><p>所以在做选型的时候，需要一并评估业务对多租户服务提供者长周期扩展能力的需求，以最终决定选用什么服务。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本篇是关于多租户应用与架构设计关注点的一些自己的思考。本篇强调多租户本质是支持共享与隔离。同时提到应用架构可能的形式以及多租户集成的设计。核心的关注点强调了对业务未来长期的判断决定了隔离粒度，最终决定了业务应用的产品架构与技术架构设计。 本篇更多是</summary>
      
    
    
    
    
    <category term="multi-tenant" scheme="https://edison-a-n.github.io/tags/multi-tenant/"/>
    
  </entry>
  
  <entry>
    <title>go-ddd</title>
    <link href="https://edison-a-n.github.io/2022/12/13/go-ddd/"/>
    <id>https://edison-a-n.github.io/2022/12/13/go-ddd/</id>
    <published>2022-12-13T06:43:04.000Z</published>
    <updated>2023-08-29T15:32:43.973Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于-internal-规划工程目录"><a href="#基于-internal-规划工程目录" class="headerlink" title="基于 internal 规划工程目录"></a>基于 <code>internal</code> 规划工程目录</h1><p><a href="https://docs.google.com/document/d/1e8kOo3r51b2BWtTs_1uADIA5djfXhPT36s6eHVRIvaU/edit">Go internal package design</a>介绍了设计的原因</p><blockquote><p>Go encourages structuring a program as a collection of packages interacting using exported APIs. However, all packages can be imported. This creates a tension when implementing a library or command: it may grow large enough to structure as multiple packages, but splitting it would export the API used in those additional packages to the world. Being able to create packages with restricted visibility would eliminate this tension.</p></blockquote><p>一个大的 <code>GO</code> 工程自然会含有大量的模块，我们会从拆分不同的 <code>.go</code> 文件到拆分不同的 <code>package</code>。一旦拆多个 <code>package</code> 就会遇到不得不把一些 <code>API</code> 和 <code>struct</code> 暴露出去的需求。<code>internal</code> 很好的解决了必须拆分 <code>package</code> 但是又希望相关的 <code>package</code> 只在当前工程中应用的问题。</p><p>基于这样的设计，我们可以将一个 <code>Domain Context</code> 目录设计成如下的样子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- module</span><br><span class="line">|- internal</span><br><span class="line">   |- domain</span><br><span class="line">      |- entity</span><br><span class="line">      |- value_obj</span><br><span class="line">      |- repo</span><br><span class="line">      |- service</span><br><span class="line">|- facade</span><br><span class="line">|- app</span><br><span class="line">|- utils</span><br><span class="line">|- ...</span><br></pre></td></tr></table></figure><h2 id="app"><a href="#app" class="headerlink" title="app"></a><strong>app</strong></h2><p><code>app</code> 即<code>应用服务</code>，在 <code>DDD</code> 中是编排<code>领域对象</code>和<code>领域服务</code>的模块。在实现中，通常是负责实现 <code>HTTP框架</code> 的对应 <code>Handler</code></p><h1 id="DTO、PO-与-Entity"><a href="#DTO、PO-与-Entity" class="headerlink" title="DTO、PO 与 Entity"></a>DTO、PO 与 Entity</h1><h2 id="DTO"><a href="#DTO" class="headerlink" title="DTO"></a><strong>DTO</strong></h2><p><code>DTO</code> 通常指的是请求传入 <code>app</code> 的数据，在<a href="https://tech.meituan.com/2015/02/26/serialization-vs-deserialization.html">序列化反序列化 - 美团</a>中介绍了分层与实现。在 <code>WEB API</code> 中通常使用 <code>Rest</code> 风格，配合使用的是 <code>json</code> 进行序列化。而 <code>RPC</code> 风格的 <code>API</code> 则除了 <code>json</code> 外，也会使用 <code>protobuf</code> 等进行序列化。</p><h2 id="PO"><a href="#PO" class="headerlink" title="PO"></a><strong>PO</strong></h2><p><code>PO</code> 也是 <code>MVC</code> 常遇到的数据对象，英文是 <code>Persistent Object</code>。一般是在与数据库（MySQL 或者 MongoDB）交互的数据对象，会作为数据库模型的数据映射。</p><p>数据映射，一般有两种形式：</p><ul><li><strong><a href="https://en.wikipedia.org/wiki/Active_record_pattern">Active Record</a></strong>: 包含了数据和数据处理方法</li><li><strong><a href="https://en.wikipedia.org/wiki/Data_mapper_pattern">Data Mapper</a></strong>: 仅取出数据，并在内存模型中存储数据</li></ul><p><strong>本质上是将数据序列化封装在<code>ORM</code>库中</strong></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><ul><li>通常，<code>DTO</code> 需要重新定义 <code>struct</code>，对于使用 <code>json</code> 进行序列化的实现，则需在实现 <code>Request</code> 来做请求数据的 binding 与 validation。对于使用 <code>protobuf</code> 进行序列化的实现，则代码生成工具会帮助生成对应的对象。</li><li><code>Entity</code> 是领域中流转的对象，需要尽可能保持自身的独立。</li><li><code>PO</code> 一般仅在 <code>Repo</code> 中使用，根据 <code>Repo</code> 使用的 <code>ORM</code> 做设计。对于直接由 <code>Entity</code> 映射的数据模型，则可以使用 <em>结构体组合(此时，<code>Entity</code> 通常也需要定义一些 <code>ORM</code> 需要的 <code>tag</code>)</em> 。复杂的 <code>PO</code> 需要重新定义并转化。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基于-internal-规划工程目录&quot;&gt;&lt;a href=&quot;#基于-internal-规划工程目录&quot; class=&quot;headerlink&quot; title=&quot;基于 internal 规划工程目录&quot;&gt;&lt;/a&gt;基于 &lt;code&gt;internal&lt;/code&gt; 规划工程目录&lt;</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://edison-a-n.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>使用 `git pull --rebase`</title>
    <link href="https://edison-a-n.github.io/2022/12/07/git-rebase/"/>
    <id>https://edison-a-n.github.io/2022/12/07/git-rebase/</id>
    <published>2022-12-07T02:45:07.000Z</published>
    <updated>2023-08-29T15:32:43.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git-rebase"></a>git-rebase</h3><p>使用 <code>git pull</code> 的时候，要加上 <code>--rebase</code>，减少merge，保持 <code>log</code> 整洁</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://stackoverflow.com/a/3357174">git rebase</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;git-rebase&quot;&gt;&lt;a href=&quot;#git-rebase&quot; class=&quot;headerlink&quot; title=&quot;git-rebase&quot;&gt;&lt;/a&gt;git-rebase&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;git pull&lt;/code&gt; 的时候，要加上 &lt;code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>opnetelemetry-jaeger</title>
    <link href="https://edison-a-n.github.io/2022/12/03/opentelemetry-jaeger/"/>
    <id>https://edison-a-n.github.io/2022/12/03/opentelemetry-jaeger/</id>
    <published>2022-12-03T07:43:31.000Z</published>
    <updated>2023-08-29T15:32:43.973Z</updated>
    
    <content type="html"><![CDATA[<p>在调研中，持续更新本篇 …</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><hr><h2 id="Tracing"><a href="#Tracing" class="headerlink" title="Tracing"></a>Tracing</h2><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p>此处只介绍使用中会遇到的概念，具体细节请查阅<a href="https://opentelemetry.io/docs/reference/specification/trace/">文档</a></p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ul><li><p><strong><a href="https://opentelemetry.io/docs/reference/specification/trace/api/#tracerprovider">TracerProvider</a></strong> 提供访问 Tracer 的入口。作为一个池子放置和管理 <code>Tracer</code>s</p></li><li><p><strong><a href="https://opentelemetry.io/docs/reference/specification/trace/sdk/#span-exporter">Span Exporter</a></strong> 定义一系列接口，执行 telemetry data 的序列化与反序列化，以将数据提交到不同的 backend。</p></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><hr><h2 id="Tracing-1"><a href="#Tracing-1" class="headerlink" title="Tracing"></a>Tracing</h2><p>根据其架构设计，所有的应用都可以实现为：</p><ol><li>定义 Resource</li><li>创建 Provider</li><li>设置全局 Provider (option)</li><li>设置 Exporter (option)</li><li>server 中使用 Tracing</li></ol><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a><strong>Python</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> opentelemetry <span class="keyword">import</span> trace</span><br><span class="line"><span class="keyword">from</span> opentelemetry.exporter.jaeger.thrift <span class="keyword">import</span> JaegerExporter</span><br><span class="line"><span class="keyword">from</span> opentelemetry.sdk.resources <span class="keyword">import</span> SERVICE_NAME, Resource</span><br><span class="line"><span class="keyword">from</span> opentelemetry.sdk.trace <span class="keyword">import</span> TracerProvider</span><br><span class="line"><span class="keyword">from</span> opentelemetry.sdk.trace.export <span class="keyword">import</span> BatchSpanProcessor</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> opentelemetry.propagate <span class="keyword">import</span> set_global_textmap</span><br><span class="line"><span class="keyword">from</span> opentelemetry.propagators.jaeger <span class="keyword">import</span> JaegerPropagator</span><br><span class="line"></span><br><span class="line">APP_NAME = <span class="string">&quot;app&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    init_provider()</span><br><span class="line"></span><br><span class="line">    set_global_textmap(JaegerPropagator())</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init_provider</span>():</span><br><span class="line"></span><br><span class="line">    trace.set_tracer_provider(</span><br><span class="line">        TracerProvider(</span><br><span class="line">            resource=Resource.create(&#123;SERVICE_NAME: APP_NAME&#125;)</span><br><span class="line">        )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    jaeger_exporter = JaegerExporter()</span><br><span class="line">    trace.get_tracer_provider().add_span_processor(</span><br><span class="line">        BatchSpanProcessor(jaeger_exporter)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>常用的 package 如 <code>Flask</code>, <code>Django</code>, <code>FastAPI</code>, <code>psycopg2</code> 等都有提供 <code>instrument</code>, 实现基于AOP的注入。</p><p><strong>Golang</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;go.opentelemetry.io/otel&quot;</span></span><br><span class="line">    <span class="string">&quot;go.opentelemetry.io/otel/exporters/jaeger&quot;</span></span><br><span class="line">    <span class="string">&quot;go.opentelemetry.io/otel/sdk/resource&quot;</span></span><br><span class="line">    sdktrace <span class="string">&quot;go.opentelemetry.io/otel/sdk/trace&quot;</span></span><br><span class="line">    semconv <span class="string">&quot;go.opentelemetry.io/otel/semconv/v1.10.0&quot;</span></span><br><span class="line">    jaegerpropagator <span class="string">&quot;go.opentelemetry.io/contrib/propagators/jaeger&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> APP_NAME := <span class="string">&quot;app&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGlobalProvider</span><span class="params">()</span></span> *sdktrace.TracerProvider &#123;</span><br><span class="line">    p, e := tracerProvider()</span><br><span class="line">    <span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    otel.SetTracerProvider(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tracerProvider</span><span class="params">(url <span class="type">string</span>)</span></span> (*sdktrace.TracerProvider, <span class="type">error</span>) &#123;</span><br><span class="line">    serviceName := APP_NAME</span><br><span class="line"></span><br><span class="line">    exp, err := jaeger.New(jaeger.WithAgentEndpoint())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tp := sdktrace.NewTracerProvider(</span><br><span class="line">        <span class="comment">// Always be sure to batch in production.</span></span><br><span class="line">        sdktrace.WithBatcher(exp),</span><br><span class="line">        <span class="comment">// Record information about this application in a Resource.</span></span><br><span class="line">        sdktrace.WithResource(resource.NewWithAttributes(</span><br><span class="line">            semconv.SchemaURL,</span><br><span class="line">            semconv.ServiceNameKey.String(serviceName),</span><br><span class="line">        )),</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> tp, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitGlobalPropagator</span><span class="params">()</span></span> propagation.TextMapPropagator &#123;</span><br><span class="line">    otel.SetTextMapPropagator(jaegerpropagator.Jaeger&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr><p><a href="https://peter.bourgon.org/blog/2017/02/21/metrics-tracing-and-logging.html">Metrics, tracing, and logging</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在调研中，持续更新本篇 …&lt;/p&gt;
&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;Tracing&quot;&gt;&lt;a href=&quot;#Tracing&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="可观测性" scheme="https://edison-a-n.github.io/tags/%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7/"/>
    
    <category term="opentelemetry" scheme="https://edison-a-n.github.io/tags/opentelemetry/"/>
    
  </entry>
  
  <entry>
    <title>ddd-thinking</title>
    <link href="https://edison-a-n.github.io/2022/06/09/ddd-thinking/"/>
    <id>https://edison-a-n.github.io/2022/06/09/ddd-thinking/</id>
    <published>2022-06-09T04:26:18.000Z</published>
    <updated>2022-06-13T15:37:38.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DDD-关键概念"><a href="#DDD-关键概念" class="headerlink" title="DDD 关键概念"></a>DDD 关键概念</h3><h4 id="Domain-中的概念"><a href="#Domain-中的概念" class="headerlink" title="Domain 中的概念"></a>Domain 中的概念</h4><h5 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h5><p>一个Domain独占一个Context。在Context中完成下述的一系列逻辑。在应用DDD中，最难的一步是，划定Context。将不同Domain的边界准确的描述清楚，对于抽象能力、业务理解准确性与未来预期的判断能力要求极高。边界划定的不好，也将难以保障内聚与耦合的合理性。</p><h5 id="Aggregate、Entity、Value-Object"><a href="#Aggregate、Entity、Value-Object" class="headerlink" title="Aggregate、Entity、Value Object"></a>Aggregate、Entity、Value Object</h5><p>将三者放在一起，是因为三者是一个包含关系，并对上层提供引用。在这些model中，会提供独占的attribute以及对应的对attribute的访问方法。</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>对于一些无法由一个model完成执行的方法逻辑，可以通过service进行包装。service的设计取舍比较复杂，在<a href="#%E5%85%B3%E4%BA%8Edomain-service">后续章节中详说</a></p><h5 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h5><p>将Domain Event提前到这个位置提出，是因为，Event Driven模式在越来越的复杂应用中，会被使用。（不复杂的应用，也不建议使用DDD进行建模，增加了过多的实体反而提高了理解成本）。Domain Event主要应用于异步驱动其他Domain执行一些业务处理，其中也会涉及到复杂的事务处理与资源竞争访问的问题。相关话题与Event Driven模式相关，在这里不详述。</p><h5 id="Factory方法"><a href="#Factory方法" class="headerlink" title="Factory方法"></a>Factory方法</h5><p><code>Factory</code>方法用于创建一个对应的model（可能是一个Aggregate、Entity或者Value Object），并执行一些复杂的初始化操作。**<code>Factory</code>不用于从<code>Repository</code>重建model，重建应该将<code>Factory</code>创建的model的引用，作为参数传入<code>Repository</code>接口中，执行重建**</p><h5 id="Repository"><a href="#Repository" class="headerlink" title="Repository"></a>Repository</h5><p><code>Repository</code>用于将model写入到数据存储中以及从数据存储中重建model。数据存储可以是sql数据库或nosql数据库以及具有存储能力的MQ以及磁盘系统。<code>Repository</code>提供一系列interface来访问数据存储。</p><ul><li>写入和重建<br>创建、更新、重建model，都会将model传入<code>Repository</code>的<code>interface</code>中，<strong>这是因为，<code>Repository</code>也是属于Domain，属于Context，所以，Repository需要理解同一个Context中的model包含什么attribute，并将其映射写入到存储中或从存储中重建model。</strong></li><li>其他访问数据的方法<br>list是一个在DDD中没有提到，在实际业务中经常使用的数据访问形式，这一系列扩展的数据访问方法，可以通过扩展<code>Repository</code>的<code>interface</code>支持Domain的数据访问。</li></ul><h4 id="跨Domain的访问"><a href="#跨Domain的访问" class="headerlink" title="跨Domain的访问"></a>跨Domain的访问</h4><h5 id="Facade接口"><a href="#Facade接口" class="headerlink" title="Facade接口"></a>Facade接口</h5><p>使用Facade模式来避免跨Context直接调用内部方法，便于底层model的持续重构。</p><h3 id="关于domain-service"><a href="#关于domain-service" class="headerlink" title="关于domain service"></a>关于domain service</h3><p>什么样的业务逻辑会放在领域服务中，在DDD中没有具体说，这可能也受限于DDD提出的时代背景。后续的实践者，包括我自己，也只能通过举例来说明。我个人的理解是，对于Web应用中，pagination、validator、permission、serializer等模块，都可以使用service来进行处理。也就是说，service是一个大的package，其中会根据不同domain需求再做复杂的service拆分。这些service通常也是interface模式，传入model的引用执行一些数据处理或校验，并按需返回数据。</p><h3 id="DDD-在不同领域的应用"><a href="#DDD-在不同领域的应用" class="headerlink" title="DDD 在不同领域的应用"></a>DDD 在不同领域的应用</h3><p>DDD的提出，是为了解决Web应用开发中出现的大量贫血模型。在前后端分离架构中，后端越来越专注与数据模型与数据处理逻辑的设计与开发，并最终交付Rest API。客户端渲染模式交由前端完成。随着后端数据模型复杂度的提高，原有的M+V模式割裂了数据处理逻辑与数据模型，不利于持续维护和迭代开发。DDD的设计可以将数据与数据处理很好的融合起来，实现了高内聚低耦合。</p><p>高内聚低耦合在复杂度高的软件开发中是十分必要的，对于保障软件整体的可维护性与稳定可用有很大价值。<strong>DDD的设计则可用应用在这一系列软件设计中。</strong> 比如，通过对Context-Aggregate-Entity-ValueObj的模型层次设计，让数据模型更好理解，通过Factory方法来维护唯一创建入口让初始化更简单易理解。跨domain使用facade模式进行interface设计，也让模型之间的访问不会产生复杂的耦合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;DDD-关键概念&quot;&gt;&lt;a href=&quot;#DDD-关键概念&quot; class=&quot;headerlink&quot; title=&quot;DDD 关键概念&quot;&gt;&lt;/a&gt;DDD 关键概念&lt;/h3&gt;&lt;h4 id=&quot;Domain-中的概念&quot;&gt;&lt;a href=&quot;#Domain-中的概念&quot; class</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://edison-a-n.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>mvc-and-ddd</title>
    <link href="https://edison-a-n.github.io/2022/05/23/mvc-and-ddd/"/>
    <id>https://edison-a-n.github.io/2022/05/23/mvc-and-ddd/</id>
    <published>2022-05-23T05:10:03.000Z</published>
    <updated>2022-06-13T15:37:38.501Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVC与DDD比较-2022-05-23"><a href="#MVC与DDD比较-2022-05-23" class="headerlink" title="MVC与DDD比较(2022.05.23)"></a>MVC与DDD比较(2022.05.23)</h1><p>MVC与DDD其实并不是对立的。在MVC中，我们会在controller中执行一些校验逻辑，包含可能的鉴权、参数校验等。我们也会在view里面实现service，包含各种validator与serializer以及data transfer。</p><p>DDD拆解并丰富了MVC中的M，将一些在V中执行的逻辑迁移到M中，由domain model执行model内的业务处理，同时将DTO从M中剥离出来放到infrastructure中，借由其他的设计模式如repository或者CQRS等进行处理。</p><p>同时，DDD中依然会有一些业务操作无法在model中完成，这时候，借由domain service和application service来进行处理。其中，domain service执行数据间的判断与操作，application service则负责完整执行需要service与model与infrastructure协同的操作。application service面向client提供完整功能，domain service仅处理model无法承担的业务功能。</p><p>其实这两种方式都是对web服务处理业务逻辑的一种抽象，而DDD只是提供我们另一种抽象方式，协助我们更紧凑的封装data model。当然，其代价就是由于严格的分层，造成同样属性的模型重复在request与response序列化、domain model处理以及repository处理中实现。借鉴<a href="https://www.django-rest-framework.org/">Django Rest Framework</a>中对serializer的设计，我们可以实现通用的从某一个<code>domain model Entity and ValueObj</code> generate不同的适配不同module的data model。以减少model重复定义，避免提高维护复杂度</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://stackoverflow.com/a/2279729">domain service vs application service vs infrastructure service</a><br><a href="https://stackoverflow.com/a/16847409">uniquevalidation in DDD</a><br><a href="https://www.infoq.cn/article/star-driven-approaches">驱动方法不能改变任何事情</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVC与DDD比较-2022-05-23&quot;&gt;&lt;a href=&quot;#MVC与DDD比较-2022-05-23&quot; class=&quot;headerlink&quot; title=&quot;MVC与DDD比较(2022.05.23)&quot;&gt;&lt;/a&gt;MVC与DDD比较(2022.05.23)&lt;/h1</summary>
      
    
    
    
    
    <category term="DDD" scheme="https://edison-a-n.github.io/tags/DDD/"/>
    
  </entry>
  
  <entry>
    <title>Git commit 规范</title>
    <link href="https://edison-a-n.github.io/2022/02/13/commit-format-and-auto-changelog/"/>
    <id>https://edison-a-n.github.io/2022/02/13/commit-format-and-auto-changelog/</id>
    <published>2022-02-13T14:04:17.000Z</published>
    <updated>2023-08-29T15:32:43.973Z</updated>
    
    <content type="html"><![CDATA[<h3 id="commit-message-format"><a href="#commit-message-format" class="headerlink" title="commit message format"></a>commit message format</h3><h4 id="提交格式"><a href="#提交格式" class="headerlink" title="提交格式"></a>提交格式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;BLANK LINE&gt;</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><ul><li><code>build</code>：对构建系统或者外部依赖项进行了修改</li><li><code>ci</code>：对CI配置文件或脚本进行了修改</li><li><code>feature</code>：增加新的特征，一般指的是大的变更</li><li><code>func</code>： 增加新的功能，一般指小的功能</li><li><code>fix</code>：修复bug</li><li><code>impr</code>: improvement，小的代码设计改进</li><li><code>conf</code>: 仅配置变化，Spring配置、properties文件</li><li><code>perf</code>：提高性能的代码更改</li><li><code>refactor</code>：既不是修复bug也不是添加特征的代码重构</li><li><code>docs</code>：对文档进行了修改</li><li><code>style</code>：不影响代码含义的修改，比如空格、格式化、缺失的分号等</li><li><code>typo</code>: 修复小的拼写错误</li><li><code>test</code>：增加确实的测试或者矫正已存在的测试</li><li><code>revert</code>: 回滚提交</li></ul><h5 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h5><p>选填，一般填写作用于哪个文件</p><h5 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h5><p>必填，变更的摘要</p><ul><li>使用动宾语句，仅讲变更的内容</li><li>现在时态：<code>change</code>不是<code>changing</code>也不是<code>changed</code></li><li>不要大写首字母</li><li>不在末尾添加句号</li></ul><h5 id="body"><a href="#body" class="headerlink" title="body"></a>body</h5><p>和主题设置类似，使用命令式、现在时态</p><p>应该包含修改的动机以及和之前行为的对比.</p><ul><li>回滚操作，需要添加本句：<code>This reverts commit hash: **********</code></li></ul><h5 id="footer"><a href="#footer" class="headerlink" title="footer"></a>footer</h5><ul><li><code>BREAKING CHANGE</code>: 不兼容的更新说明，比如public API的修改等</li><li><code>Closes</code>: 指针对哪个issue的修改，可以关联某个story或者bug</li></ul><h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><h4 id="为什么需要规范"><a href="#为什么需要规范" class="headerlink" title="为什么需要规范"></a>为什么需要规范</h4><p>git提交规范，有利于代码变动的稳定性监控。更大的价值是，后续跟进维护的同学可以通过commit查找变更的细节，以及了解某段代码引入的目的。</p><h4 id="中文or英文"><a href="#中文or英文" class="headerlink" title="中文or英文"></a>中文or英文</h4><p>在内部工程中，如果团队大多数都是中国人，建议还是使用中文描述。不准确的英文描述会影响后续对commit的阅读，也就无所谓理解了。当然，最好还是使用英文。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南 - 阮一峰</a><br><a href="https://zj-git-guide.readthedocs.io/zh_CN/latest/message/Angular%E6%8F%90%E4%BA%A4%E4%BF%A1%E6%81%AF%E8%A7%84%E8%8C%83/">Angular提交信息规范</a><br><a href="https://cloud.tencent.com/developer/article/1762300">美团 GIT Commit Log规范</a><br><a href="https://www.conventionalcommits.org/en/v1.0.0/">conventional commits</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;commit-message-format&quot;&gt;&lt;a href=&quot;#commit-message-format&quot; class=&quot;headerlink&quot; title=&quot;commit message format&quot;&gt;&lt;/a&gt;commit message format&lt;/</summary>
      
    
    
    
    
    <category term="thinking" scheme="https://edison-a-n.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>思考与交流</title>
    <link href="https://edison-a-n.github.io/2022/02/03/tight-lipped/"/>
    <id>https://edison-a-n.github.io/2022/02/03/tight-lipped/</id>
    <published>2022-02-02T16:44:49.000Z</published>
    <updated>2022-06-13T15:37:38.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题记"><a href="#题记" class="headerlink" title="题记"></a>题记</h3><p>想写这篇文章，是因为在某平台看某用户的一篇文章，想了解一下作者的背景，进而看到其在一些回答中与评论者争吵的情况。其实技术水平高低本身是受很多情况影响的，评价一个人也不是一维的。事实上，没有任何标准可以真正的评价一个人。技术讨论和技术辩论是受欢迎的，因为大家技术水平不在一个等级而无法正常的讨论进而主动拒绝讨论本身也是可以接受的。黑一门技术，则显得狭隘了。</p><p>为了调解自己的思想，再一次阅读了《黑客与画家》“守口如瓶”这一章，并分享一些感悟。</p><h3 id="自由的思考"><a href="#自由的思考" class="headerlink" title="自由的思考"></a>自由的思考</h3><p>自由的思考，强调的是，不要轻易的被各种论断影响。我们需要去思考一个论点的论证逻辑，了解其论据是否足够充分。信息时代，我们每天都会从各种渠道接受到各种各样的信息。当我们可以自由的思考的时候，我们可以让思考变得更加理性客观。所以我们要减少跟别人辩个明白的行为。辩论，是为了信息和思考进行交换，是为了让我们有更多的角度来思考，是为了更自由的思考。</p><p>思考一个话题的时候，该话题本身是没有正确与否的区别的，只有是否合逻辑，合情理。当然这些逻辑和情理也是预置的。所以我们需要交流，来持续拓展我们预先存储的对逻辑和情理的认识，让我们的思考更加自由和理性。</p><h3 id="选择可以交流的人"><a href="#选择可以交流的人" class="headerlink" title="选择可以交流的人"></a>选择可以交流的人</h3><p>很多时候，我们会遇到非要辩个明白的人。这其实已经算是一件幸事。至少他只是要强调他的观点是正确的，不一定会攻击我们。有时候，我们还会遇到，直接对自己进行攻击的人。</p><p>因为，我们跟别人讨论甚至辩论，是为了启发思考，是为了避免自己呆在一个井底。所以，我们要找可以交流的人。可以交流的人，是那些可以只对观点发表看法，并同时尊重你的观点，最重要的是不会因为观点不一致而气急败坏的人。</p><p>这样的人很多也很少。我们可以多跟不同的人交流，去试探他们是不是这样的人。如果一个人始终处于“不能交流”的状态，那么就要远离他。因为，一旦我们跟他辩论，我们的思考就很容易陷入偏颇，此时只想着辩赢，而不是自由的思考。</p><p>无论如何，我们一定要积极去结识，更多的结识可以交流的朋友，因为“观点不讨论，就什么观点也没有了。”</p><p>还有一种方法是看书，看书，就是与作者交流的过程。</p><h3 id="接受不一样的观点"><a href="#接受不一样的观点" class="headerlink" title="接受不一样的观点"></a>接受不一样的观点</h3><p>与可以交流的人交流，我们就可以兴平气和的讨论一个与自己原先理解不一样的观点。有时候，我们可能在讨论之后，仍然不认可该观点。但是，因为我们的交流，是为了自由的思考，所以，一个不一样的观点是可以被接受的。在未来与更多的人交流，自己思考的更多的时候，或许，会有更充分的论据和更严谨的论证，来说服自己不认可该观点，当然也可能让自己认可了该观点。</p><p>地心说，在提出的年代可能都不被认可，但是我们可以先存着，在后来的认知不断提高的过程，逐渐认可这个观点。如果我们只是去跟哥白尼“争论”，如果我们不能接受不一样的观点，那我们的思考也将不自由。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;题记&quot;&gt;&lt;a href=&quot;#题记&quot; class=&quot;headerlink&quot; title=&quot;题记&quot;&gt;&lt;/a&gt;题记&lt;/h3&gt;&lt;p&gt;想写这篇文章，是因为在某平台看某用户的一篇文章，想了解一下作者的背景，进而看到其在一些回答中与评论者争吵的情况。其实技术水平高低本身是受很多</summary>
      
    
    
    
    
    <category term="thinking" scheme="https://edison-a-n.github.io/tags/thinking/"/>
    
  </entry>
  
  <entry>
    <title>知识掌握的广度与深度</title>
    <link href="https://edison-a-n.github.io/2022/01/30/knowledge-breath-and-depth/"/>
    <id>https://edison-a-n.github.io/2022/01/30/knowledge-breath-and-depth/</id>
    <published>2022-01-29T16:00:00.000Z</published>
    <updated>2022-06-13T15:37:38.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是广度与深度"><a href="#什么是广度与深度" class="headerlink" title="什么是广度与深度"></a>什么是广度与深度</h3><p>想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟hr交流的时候，或者跟领导、行业大佬交流的时候，也经常会听到这样的建议：“要做一名T&#x2F;π型人才”。</p><p>那么，广度要怎么理解，深度又要怎么理解呢。我们掌握了一些知识或者信息，需要达到一个什么程度，算是覆盖了广度，或是达到了深度。</p><p>我个人的感受是，当我们对知识、信息达到了，</p><ul><li><strong>能够理解其中的原理与逻辑，同时能够自己进行复述</strong>，则算是达到了广度的覆盖</li><li><strong>能够机遇已有的信息，思考其深层次的逻辑，举一反三的实践或思考总结，并能达到一定效果</strong>，则算是深度的掌握。</li></ul><p>我们每天会浏览五花八门的信息，会folloe各种博客阅读新的思想。多数时候，我们以为我们已经了解其中的相关内容，其实我们仅限于“知道“。我们没有能够梳理其中的逻辑，也更无可能无法复述其中的逻辑。<strong>但是没有关系，因为我们的时间有限，不可能对大多数信息都能完整了解。</strong> 对于我们需要去了解的领域，则需要做到”广度式“的了解。比如很多人打王者荣耀，有的人只是消磨时间，有的人则会去了解每个英雄的连招、出装、阵容搭配等等。前者算不得广度，即不能在相亲介绍中的兴趣爱好栏写打王者荣耀，顶多只能写无聊时打打王者。做到深度掌握打王者打同学，则要摸清楚某个英雄的各种细节，在各种场景中如何操作。</p><p>当然，具体要掌握到什么程度，取决于自己。比如我，就只是无聊时打打王者。</p><h3 id="如何达到广度与深度"><a href="#如何达到广度与深度" class="headerlink" title="如何达到广度与深度"></a>如何达到广度与深度</h3><p>我曾经咨询过一位架构师，聊“如何覆盖技术的广度与深度”。在我的工作内容中，甚少会接触大数据工程，也没有直接接触AI项目（两大当前热门“泡沫”领域），我如何让我的技术覆盖到那里呢。我收到的回答是：“当你需要的时候，你自然会去学习去了解。”</p><p>需要的时候，是一个很有趣的描述。什么是需要的时候，想“知道”一下，方便吹牛的时候扯扯专业名词；想“了解”一下，虽然用不到但是可以学一学原理；想“挖掘”一下，在某个项目中应用。还有其他的各种情况，都会成为需要的时候。</p><p>在当前的互联网时代，要达到知识掌握的广度，其实不难。要了解一个领域的知识，有各种各样的搜索引擎和问答社区，可以找到资料。无论是否正确，逻辑总能在一定程度上自洽。要找到不自洽的点，当然需要更深入的学习理解了。如同狼人杀发言，论述粗看一定有道理，至于是不是真的合理，就需要高级玩家才能分辨出来。</p><h3 id="有计划的拓展广度和深度"><a href="#有计划的拓展广度和深度" class="headerlink" title="有计划的拓展广度和深度"></a>有计划的拓展广度和深度</h3><p>虎年马上要到来，也是2022年的一月份，很多人都会给自己做计划，也有很多人没有什么特别的计划。计划的执行可能也都不一样。我十分建议，能够为自己的知识的广度与深度的拓展做足计划，且最好是有长时与短时计划。也许有的人不知道未来三五年自己会做什么，但是大家多少都有一个方向，或者有些兴趣点。</p><p>有计划的去拓展和达成，可以让自己持续的达到某些里程碑，从而持续对自己形成正向激励。 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是广度与深度&quot;&gt;&lt;a href=&quot;#什么是广度与深度&quot; class=&quot;headerlink&quot; title=&quot;什么是广度与深度&quot;&gt;&lt;/a&gt;什么是广度与深度&lt;/h3&gt;&lt;p&gt;想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何撰写技术设计文档</title>
    <link href="https://edison-a-n.github.io/2021/12/16/software-design-doc/"/>
    <id>https://edison-a-n.github.io/2021/12/16/software-design-doc/</id>
    <published>2021-12-15T16:00:00.000Z</published>
    <updated>2022-06-13T15:37:38.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在解决的问题，以及方案的设计思路。</p><h3 id="为什么要写设计文档"><a href="#为什么要写设计文档" class="headerlink" title="为什么要写设计文档"></a>为什么要写设计文档</h3><ul><li>要解决的问题是什么需要用文档先介绍清楚</li><li>有些问题使用一份设计文档描述思路已经足够</li><li>解决方案的选择（decision）是权衡的结果，我们不仅需要了解结果，也需要知道结果产生的原因，即权衡的过程。只有记录下权衡的过程，在后续偿还技术债的时候，才可以更方便的理解产生的原因或初衷，并有更充分的执行架构演进的依据</li><li>让团队成员对问题和设计有一个共识</li></ul><h3 id="设计文档核心内容"><a href="#设计文档核心内容" class="headerlink" title="设计文档核心内容"></a>设计文档核心内容</h3><p>基于以上原因，我们也可以推论出，设计文档所需要具备的核心内容：</p><ul><li>问题的上下文。一个问题需要解决，自然需要关于该问题的上下文内容。</li><li>想要达成的目标是什么</li><li>哪些不是我们的目标<br>如果在讨论与设计过程中，发现一些可能会对设计带来干扰，但是明确不是当前要解决的目标，需要记录下来，以便团队对此形成共识</li><li>权衡的过程<ul><li>为什么选择某个方案</li><li>为什么不选择某个方案<br>如果对于某一个方案，有十分明确的不使用的原因，尤其是行业有充分的应用经验而设计的时候考虑不使用的时候，需要将其记录下来，作为权衡的参考，以避免后续团队演进设计的时候，朝着原先不选择的方案前进。</li><li>当前的一个或多个方案有什么条件限制或成本考虑</li><li>收益是如何的，创造的价值是什么</li></ul></li></ul><h3 id="什么时候写设计文档"><a href="#什么时候写设计文档" class="headerlink" title="什么时候写设计文档"></a>什么时候写设计文档</h3><p><strong>在着手实现之前，先完成设计文档的撰写与迭代。</strong></p><p>不要试图等到将功能实现之后在补充文档。开发者喜欢写代码甚于写文档。对于开发者来说，在文档中描述某种架构实现方案，不如实现一个demo来演示该方案。当开始写demo之后，很可能就会开始将demo做修修补补，最后完成一份可上线代码。当代码完成之后，除非有某种强制推力要求自己必须完成，或是为了向多个团队或个人介绍自己的方案而减少</p><p>在实现之前，完成设计文档的撰写与迭代，可以持续的思考自己的设计的缺陷，并记录下来</p><p>设计文档的基本写作步骤：<br>打草稿 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; …</p><ul><li>需求持续在变</li><li>有新的设计想法或方案</li><li>有新的condition或constraint出现，需要调整设计</li></ul><h3 id="写文档是一件有趣的事情"><a href="#写文档是一件有趣的事情" class="headerlink" title="写文档是一件有趣的事情"></a>写文档是一件有趣的事情</h3><p>写文档，犹如在将学习理解掌握的事情，再向其他人介绍与论述，以寻求与他人的共鸣。我们在白板前讨论的问题，在讨论完毕之后就会被擦除；我们编写的代码，会因为各种需求的变化而被调整（感谢svn让我们可以回顾第一行代码）。而文档，在未来的某一天，仍旧将有人会来翻阅，如同著书立说，言论可能会过时，但是却是在当下时代的最佳产物。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.industrialempathy.com/posts/design-docs-at-google/">Design Docs at Google</a></p><p><a href="https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/">Scaling Engineering Teams via RFCs: Writing Things Down</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>突破式创新的产品设计</title>
    <link href="https://edison-a-n.github.io/2021/11/21/breaking-creation-product/"/>
    <id>https://edison-a-n.github.io/2021/11/21/breaking-creation-product/</id>
    <published>2021-11-20T16:00:00.000Z</published>
    <updated>2022-06-13T15:37:38.501Z</updated>
    
    <content type="html"><![CDATA[<h3 id="10倍的产品改进"><a href="#10倍的产品改进" class="headerlink" title="10倍的产品改进"></a>10倍的产品改进</h3><p>《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如果产品所属的市场价值极大，2-3倍的改进会引来一大群竞争者轻易的介入，这将使得产品在后续的迭代中疲于与其他竞争者斡旋，而丢失了让产品变得更好的目标。如果产品的市场价值有限，那么产品能带来的收益也有限，投入的成本也将有限，并很难再继续做大。事实上，有相当一部分产品的推出，比原来的产品带来的改进少于其带来的麻烦。这样的产品，基本很难吸引到用户。俞军提出的产品价值公式可以很好诠释这一点，即<code>新产品价值 &gt; 旧产品价值 + 迁移成本</code>，这样的新产品才有可能成功。</p><p>一款产品想要在推出的时候，占领并持续垄断市场，需要十倍的产品改进。这里我们不细谈市场是否存在，假设已经经过足够的调研验证市场确实存在。如同我们使用微信，很难有新一款社交工具可以打败。</p><p>10倍的改进不只在于产品功能本身，还有其交互体验，产品性能与稳定。chrome关于其核心原则的介绍，可以很好的指导10倍的改进。</p><p>10倍的改进本身并不容易衡量。但是我们可以从以下几个点去判断：</p><ul><li>技术不可替代</li><li>交互更加简单</li><li>稳定性更佳</li><li>交互反应更加快速</li></ul><p>此外，安全性不在这里提出，但是也越来越重要，越来越成为一款产品是否“改进”的判断标准之一。</p><p>“MVP法则”本身并没有问题，但是很多人在定义minimum value的时候，往往只抓住了某个核心需求即快速的进行产品设计，开发者也只专注于实现核心功能而不考虑优化。当用户有多个价值需求的时候，技术不满足、产品没有完成设计，会让用户体验不佳而造成初始不良印象，甚至放弃使用该产品。而用户对产品的不良反馈将会严重打击产品迭代的积极性。除非产品经理与开发者能认识到自身的不足。更可惜的是，着急推出的可能可以创造改变但是设计不良的产品，无异于让竞争者快速入场并将自己打到。</p><p>一款“MVP”产品，应该在一开始就具备建立垄断的能力。Apple产品、Chrome、微信都是如此。即使后来的各种移动端设备、浏览器(包括app内建的浏览器如微信搜索)、社交工具，都无法撼动。Apple在近些年不断被挑战，也是因为其仅做的2-3倍的改进，让华为、小米等竞争者可以快速完成替代，并在其他方面创造竞争力。尽管不足以将Apple踢出竞争环境，但是也不断在蚕食其市场。而其他踢出竞争环境的产品包括Firefox、柯达等。</p><p>要做到10倍的改进行，需要深耕技术基础的工程师，准确理解用户需求的产品经理。</p><p>要做到看起来很难，事实也是如此。而最基本的方法是，每一次做技术设计或产品设计的时候，都问自己，</p><ul><li>有没有理解不到位的地方？</li><li>有没有更好的解决方法？</li><li>不调整设计减少的成本和收益比是否可以承受？</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;10倍的产品改进&quot;&gt;&lt;a href=&quot;#10倍的产品改进&quot; class=&quot;headerlink&quot; title=&quot;10倍的产品改进&quot;&gt;&lt;/a&gt;10倍的产品改进&lt;/h3&gt;&lt;p&gt;《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如</summary>
      
    
    
    
    
  </entry>
  
</feed>
