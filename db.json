{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/archer/source/assets/algolia_logo.svg","path":"assets/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/beian.png","path":"assets/beian.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/example_qr.png","path":"assets/example_qr.png","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/favicon.ico","path":"assets/favicon.ico","modified":0,"renderable":1},{"_id":"themes/archer/source/assets/loading.svg","path":"assets/loading.svg","modified":0,"renderable":1},{"_id":"themes/archer/source/avatar/Misaka.jpg","path":"avatar/Misaka.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css","path":"css/dark.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/dark.css.map","path":"css/dark.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css","path":"css/mobile.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/mobile.css.map","path":"css/mobile.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css","path":"css/style.css","modified":0,"renderable":1},{"_id":"themes/archer/source/css/style.css.map","path":"css/style.css.map","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","path":"font/Oswald-Regular.ttf","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff","path":"font/Source Sans Pro.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","path":"font/Source Sans Pro.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","path":"font/SourceCodePro-Regular.ttf.woff","modified":0,"renderable":1},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","path":"font/SourceCodePro-Regular.ttf.woff2","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/404-bg.jpg","path":"intro/404-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/about-bg.jpg","path":"intro/about-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/index-bg.jpg","path":"intro/index-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/intro/post-bg.jpg","path":"intro/post-bg.jpg","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/jquery.min.js","path":"lib/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/lib/webfontloader.min.js","path":"lib/webfontloader.min.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js","path":"scripts/customFontLoader.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","path":"scripts/customFontLoader.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js","path":"scripts/dark.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js","path":"scripts/main.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/dark.js.map","path":"scripts/dark.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","path":"scripts/main.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/main.js.map","path":"scripts/main.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js","path":"scripts/search.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.map","path":"scripts/search.js.map","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","path":"scripts/search.js.LICENSE.txt","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js","path":"scripts/share.js","modified":0,"renderable":1},{"_id":"themes/archer/source/scripts/share.js.map","path":"scripts/share.js.map","modified":0,"renderable":1},{"_id":"source/avatar/avatar.jpg","path":"avatar/avatar.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1643556389245},{"_id":"themes/archer/layout/_partial/comment/custom.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1643556536170},{"_id":"themes/archer/.babelrc","hash":"078678843ebb6992f0cc44304faa6f1cb082bd4a","modified":1643556536150},{"_id":"themes/archer/.editorconfig","hash":"3a7f38d9586f73ed1c46cfbc9839b3465ec57d7c","modified":1643556536150},{"_id":"themes/archer/.eslintrc.json","hash":"352a07b94efa124a5658b502bf973683be09fd00","modified":1643556536150},{"_id":"themes/archer/.gitattributes","hash":"82c1a621642d5b620275ae1ed59845c3f7015a64","modified":1643556536150},{"_id":"themes/archer/.gitignore","hash":"b5de96e5158df11ad8c49d149f45ec014e18971a","modified":1643556536150},{"_id":"themes/archer/.prettierignore","hash":"41abb32fef2d4686421aff0f29b796fef29dcc18","modified":1643556536150},{"_id":"themes/archer/.prettierrc.js","hash":"bae1d8dab7bf8b68207386f366e092778940540c","modified":1643556536150},{"_id":"themes/archer/CHANGELOG.md","hash":"6fbf3e5e8ed6ae6fb68fd74bfd2b53d99db4b1fd","modified":1643556536150},{"_id":"themes/archer/LICENSE","hash":"0da0c361bf299375739c6b668a44af0f5faf37bb","modified":1643556536150},{"_id":"themes/archer/README.md","hash":"069ea3c82bb762e76420b1fa1515eb93fc545574","modified":1643556536150},{"_id":"themes/archer/_config.yml","hash":"93a02363aaf413f7fdd5960c22dd83a293de7d9c","modified":1643556536150},{"_id":"themes/archer/gulpfile.js","hash":"ee1ad57aa5113a084091fd86fca2c34e1b9e4b95","modified":1643556536150},{"_id":"themes/archer/package.json","hash":"8fe7d738be6f9b73a624ea1236a12881b900c555","modified":1643556536174},{"_id":"themes/archer/webpack.config.js","hash":"e090744d8e7a0d0906d1d6b8192eb906092d1e9b","modified":1643556536278},{"_id":"themes/archer/webpack.dev.js","hash":"7c740341894bd584f72145512a58703bb134ea60","modified":1643556536278},{"_id":"themes/archer/webpack.prod.js","hash":"a34abc06d6cd8fa4e267069468726322a3656e2b","modified":1643556536278},{"_id":"themes/archer/dev/archer.sh","hash":"4065c4e55462d5ecf016464adea0d1db967ef4b4","modified":1643556536150},{"_id":"themes/archer/docs/README-en.md","hash":"f325565c0bb94501fd046268659c7752709895d1","modified":1643556536150},{"_id":"themes/archer/docs/develop-guide-en.md","hash":"0bb09c3c9d5f56820cb84e3316f60352b731d70c","modified":1643556536150},{"_id":"themes/archer/docs/develop-guide-zh.md","hash":"db6a9945e6040bd63d006da7b0b7e7ba5febd150","modified":1643556536150},{"_id":"themes/archer/languages/default.yml","hash":"e937791c5080868c3abe20bab4cf266a342b5922","modified":1643556536170},{"_id":"themes/archer/languages/en.yml","hash":"5a1a85fed95dab4f01671714ee8cc5420936c05f","modified":1643556536170},{"_id":"themes/archer/layout/404.ejs","hash":"9137c0b1153ca8cd32e60a38fd79b7e4b91c8bf4","modified":1643556536170},{"_id":"themes/archer/layout/about.ejs","hash":"748786bebad03b1ef79c551f26522fa2bee1b9dd","modified":1643556536170},{"_id":"themes/archer/layout/index.ejs","hash":"093f8dbe875cad94b9618f181d1b5621d8874b19","modified":1643556536170},{"_id":"themes/archer/layout/layout.ejs","hash":"1bee90a75c1f4b04c90421419dd68acdec15b998","modified":1643556536170},{"_id":"themes/archer/layout/post.ejs","hash":"d421aba0ab93e2b7a22d060da4c56441bf97cdb9","modified":1643556536170},{"_id":"themes/archer/.github/workflows/deploy-demo-page.yml","hash":"91c065ee0ec29f7bb10263fefa6f3072bc493a38","modified":1643556536150},{"_id":"themes/archer/layout/site-meta.ejs","hash":"562e446a742fde07e0880343d5693bf8cb0dec23","modified":1643556536170},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----------bug--help-wanted-or-bug-report-.md","hash":"012bd3afea5565204f75d8c89048ad33b9c2f948","modified":1643556536150},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----feature-request-.md","hash":"886fb1252702d46c89536b579d35ce49e53ec54d","modified":1643556536150},{"_id":"themes/archer/.github/ISSUE_TEMPLATE/-----other-issue-.md","hash":"4bf3c8ebef14a81bb55e8e0468d816e83c4133ac","modified":1643556536150},{"_id":"themes/archer/layout/_partial/algolia.ejs","hash":"c7bf50dd6e60fd8e8dfbeab9960172359af7307e","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-background-image.ejs","hash":"4e6091b81f7f327cffee6275174c52918cd1789a","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-footer-fixed.ejs","hash":"e4dbde6594c0c2d1c5de71ddf968be0879ceddb7","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-footer.ejs","hash":"d8f4236166d058421c2e4ff00660be75a3494704","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-header.ejs","hash":"57d1ae0fd6f9f1ab52a64c44a8ae17ee71de22ef","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-head.ejs","hash":"76fd2b40c501d5c6eb764c336f11521e045febc9","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-preload-polyfill.ejs","hash":"d046322674052b0667775dca0886f14e0d812897","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-profile.ejs","hash":"b4be51c4c02b69d3e95a555ae00047f3b6c2926f","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-title-tags.ejs","hash":"1d5a95782ffc382fdb6b1239b3b97db125984fa0","modified":1643556536170},{"_id":"themes/archer/layout/_partial/base-social.ejs","hash":"0190f06c2f0345cec00eba2074bbfd1b56a7fdc9","modified":1643556536170},{"_id":"themes/archer/layout/_partial/custom-font.ejs","hash":"bc6bfda53f8856e1473263a44fd861e96cc00719","modified":1643556536170},{"_id":"themes/archer/layout/_partial/intro-height.ejs","hash":"7b8b078b1c1e5b216e46b32a0cab67330c92c734","modified":1643556536170},{"_id":"themes/archer/source/assets/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1643556536190},{"_id":"themes/archer/source/assets/beian.png","hash":"a99df13e8eb11db86edebf6e5ac246eb59f4b3c4","modified":1643556536190},{"_id":"themes/archer/source/assets/example_qr.png","hash":"cce20432c34875f4d9c6df927ede0fc0f00bb194","modified":1643556536190},{"_id":"themes/archer/source/assets/loading.svg","hash":"45be17d07697d604d8981890eb21e308530c7a38","modified":1643556536190},{"_id":"themes/archer/source/avatar/Misaka.jpg","hash":"74a0372523f98dfbba992bf80642e160d04dc9b1","modified":1643556536190},{"_id":"themes/archer/source/assets/favicon.ico","hash":"8b200c575d273d41a179c102442e191414e74eae","modified":1643556536190},{"_id":"themes/archer/source/css/dark.css","hash":"32b2072ca8d39803cbd8f7395dcf02f6390dbee3","modified":1643556536190},{"_id":"themes/archer/source/css/dark.css.map","hash":"f5b60d05584b47dea744edff92c44bc389675e05","modified":1643556536190},{"_id":"themes/archer/source/css/mobile.css","hash":"7b73350f80ee39ec30b4c61895d274b4889329f4","modified":1643556536190},{"_id":"themes/archer/source/css/mobile.css.map","hash":"1f26e4000a416870ccf4e85083f7209dc55f4482","modified":1643556536190},{"_id":"themes/archer/source/css/style.css","hash":"2a3733ec29221a6f9a74f08b821ca079d18dbea6","modified":1643556536190},{"_id":"themes/archer/source/font/Source Sans Pro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1643556536198},{"_id":"themes/archer/source/font/Source Sans Pro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1643556536198},{"_id":"themes/archer/source/lib/webfontloader.min.js","hash":"4c69aeb4e4f355912503d1c460e8e7aa6ea6963e","modified":1643556536218},{"_id":"themes/archer/source/scripts/customFontLoader.js","hash":"e95e00bdb80b5b2abef477eabe59005cc8d196c5","modified":1643556536218},{"_id":"themes/archer/source/scripts/dark.js","hash":"b0b3b400432f1913c57c817e3d8ad40dbfeebabc","modified":1643556536218},{"_id":"themes/archer/source/scripts/dark.js.map","hash":"512d8ca5ed89950d8fad95ba1200f0b21ba82388","modified":1643556536218},{"_id":"themes/archer/source/scripts/main.js.LICENSE.txt","hash":"7f3206da6b550feb5291feee14bc02e74d3076a1","modified":1643556536218},{"_id":"themes/archer/source/scripts/search.js.LICENSE.txt","hash":"f98b4df48bbadc7ab1e8f9fc4618b86d33bdf44f","modified":1643556536218},{"_id":"themes/archer/source/scripts/share.js","hash":"f47267d78d896ae1ec2b4daba9f7ed098712a95b","modified":1643556536222},{"_id":"themes/archer/src/js/browser.js","hash":"c56e0094a04d6f20564f8f0da1496cb7631d4dc2","modified":1643556536234},{"_id":"themes/archer/src/js/customFontLoader.js","hash":"98bb3a1c0f69bc2675bfa6579df2dde38ba6fded","modified":1643556536234},{"_id":"themes/archer/src/js/dark.js","hash":"2cd243df8593b18a1a293f483d2db18503c53547","modified":1643556536234},{"_id":"themes/archer/src/js/fontawsome.js","hash":"43e852899ee1bc22495253428a2ff3bdedf89882","modified":1643556536234},{"_id":"themes/archer/src/js/fancybox.js","hash":"6dfc8015d6000c76806424876f5472f39e5485af","modified":1643556536234},{"_id":"themes/archer/src/js/init.js","hash":"dee0a1c959bd4dc3953428b1b2137f42bc659b32","modified":1643556536234},{"_id":"themes/archer/src/js/initSidebar.js","hash":"c9c030a451ed394934c1858c7d55ec5a7b588305","modified":1643556536234},{"_id":"themes/archer/src/js/main.js","hash":"103af0f91a07e77cb20ac3f8b547a043586d34ea","modified":1643556536234},{"_id":"themes/archer/src/js/mobile.js","hash":"4ae6837e18b729f85b5097867fc742ba2d1edf25","modified":1643556536234},{"_id":"themes/archer/src/js/scroll.js","hash":"19f1e5352228034f897f503a25bd760c3bebcbf2","modified":1643556536234},{"_id":"themes/archer/src/js/share.js","hash":"c2e6a3d8d6883cde0c67484daca5e742ebb8e0d1","modified":1643556536234},{"_id":"themes/archer/src/js/search.js","hash":"0bf92b51fef092989f4fe16fb7ef7724d11e9f58","modified":1643556536234},{"_id":"themes/archer/src/js/sidebar.js","hash":"3f917f2fb5c5b9db1660458899506547b1767746","modified":1643556536234},{"_id":"themes/archer/src/js/tag.js","hash":"395db7eb2d09e2df6eefcf3f4c7da5cd809a6221","modified":1643556536234},{"_id":"themes/archer/src/js/toc.js","hash":"ff7022cd08e26baf22cbf8c1f158e5fd67e74e48","modified":1643556536234},{"_id":"themes/archer/src/js/util.js","hash":"e49b30f6ba82d5183d005fc0192d2d673969586b","modified":1643556536234},{"_id":"themes/archer/src/scss/_common.scss","hash":"e80acb4f0049d24260f0a32a301f985ae7e166b8","modified":1643556536234},{"_id":"themes/archer/src/scss/_mixin.scss","hash":"78da2632e7150baa0fd1f6d04fc59ca5e304903d","modified":1643556536250},{"_id":"themes/archer/src/scss/_normalize.scss","hash":"a2dbeb38ad08bb8975856d75954cc697bf8e5ff7","modified":1643556536266},{"_id":"themes/archer/src/scss/_variables.scss","hash":"01e5cab2b5fc686c52145d65229f17db13a3cc54","modified":1643556536274},{"_id":"themes/archer/src/scss/dark.scss","hash":"739af46f0ef8c0c89c3e78ec577e844678f737b5","modified":1643556536274},{"_id":"themes/archer/src/scss/mobile.scss","hash":"20bb8ac78c3a2505f5b8997f31544ff23179aaf7","modified":1643556536274},{"_id":"themes/archer/src/scss/style.scss","hash":"b10b9a44efaa293b7ac220e66c963dca04ad4bc7","modified":1643556536274},{"_id":"themes/archer/layout/_partial/comment/changyan.ejs","hash":"cc02b3cf9586135d2d7f822c7ad97d81fdf6d4e5","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/disqus.ejs","hash":"0f0612ce9ca5c3dc349153a87fdc9dba5f93c52c","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/gitment.ejs","hash":"eda79ada5171ed44e4f3ae4d8a345ad2c7adb2df","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/gitalk.ejs","hash":"840279fd3e21dc1cdb1932fe4d9a3be5f670e764","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/livere.ejs","hash":"d65d9372fca4b316b94ae511f8ccfb0b92d7b065","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/utteranc.ejs","hash":"f4ec58c74e6870b8c22032ad3a3c1ee33e5ec41d","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/valine.ejs","hash":"24cd7b9e28ceb4b2083ddccce26517de64b35119","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/waline.ejs","hash":"c2208d6f05490bbf1b35cdf1519a39933212c33e","modified":1643556536170},{"_id":"themes/archer/layout/_partial/comment/youyan.ejs","hash":"2f4ef49a74a8d63310af60ecda6d765b8c386ff4","modified":1643556536170},{"_id":"themes/archer/layout/_partial/critical-css/critical-style.ejs","hash":"e67a7a2f6bcbfd97e95577446872e217e0c48e80","modified":1643556536170},{"_id":"themes/archer/layout/_partial/math/mathjax.ejs","hash":"84c40a07765e95213045e9b9f7a8c9aaa9c69161","modified":1643556536170},{"_id":"themes/archer/layout/_partial/script/font-loader.ejs","hash":"0473335774025d185dcbaf641496b25a8f33f7af","modified":1643556536170},{"_id":"themes/archer/layout/_partial/sidebar/base-sidebar.ejs","hash":"bdf08beebbe454da9d4c55b35efd317d5f222be5","modified":1643556536170},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-archives.ejs","hash":"6360da867c23b8daa5e34e62c5c5552e2974e360","modified":1643556536170},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-categories.ejs","hash":"02f407d9f9968d228a6a47f2a283b8cf41836a1a","modified":1643556536170},{"_id":"themes/archer/layout/_partial/sidebar/sidebar-tags.ejs","hash":"469455994771da166ddecb4839efa9ef28f2775d","modified":1643556536170},{"_id":"themes/archer/src/scss/_dark/_common-dark.scss","hash":"fc03470312c57a39bc131a1e86cdd3ea2ddb164a","modified":1643556536234},{"_id":"themes/archer/src/scss/_partial/_404.scss","hash":"9e5cb20871e5bf1af4cf50694a73bd7c9fe64685","modified":1643556536266},{"_id":"themes/archer/src/scss/_partial/_algolia.scss","hash":"fd7716d8559a9f58f7caef576c553ca7ba1a85e1","modified":1643556536266},{"_id":"themes/archer/src/scss/_partial/_index-page.scss","hash":"7ed45c11316bb9bf441ab897fcfed9beea108ad6","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_post-page.scss","hash":"26a55109cd29fd0f01134aaf5cb80bde789f4d13","modified":1643556536274},{"_id":"themes/archer/src/scss/_dark/_partial/_algolia-dark.scss","hash":"e9ea52ca5410c6a6eb53d2a6de1419d3db97d8ca","modified":1643556536234},{"_id":"themes/archer/src/scss/_dark/_partial/_index-page-dark.scss","hash":"4c1406e82b2d4503e027443f64f0984fe0942e1d","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_post-page-dark.scss","hash":"d61059785c72c626990f5b473dc3570cb52c0d73","modified":1643556536250},{"_id":"themes/archer/src/scss/_mobile/_partial/_index-page-mobile.scss","hash":"2d166bb6f234b8773a9ea12457b10e94902a32f1","modified":1643556536250},{"_id":"themes/archer/src/scss/_partial/_comment/_gitalk.scss","hash":"341bb251987f30221936e36b44374b2b5ce0d218","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_post/_code.scss","hash":"504f9fdb723c7b287d958211189d25919ac592f6","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_post/_writing-enhance.scss","hash":"4cb495c64d144b2bcf225f2b87641017bd652e66","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_footer-fixed.scss","hash":"1eb918f6c16054ef2b53b9eea60c751ad89bbd55","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_footer.scss","hash":"4aafefa6834c8a8583c1cdace620a31306676a57","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_header.scss","hash":"3ae33e6dec6956dee8e9f524e2947ad3cc717b37","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_intro.scss","hash":"4567b9081f063e5fb388b0671f3bc322bdc9acfa","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_paginator.scss","hash":"67c2e697a5fbb3b8006cf358ea45eb7f75b496f8","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_profile.scss","hash":"4771add895f8a47917ae2d0d34b92cb327329bf1","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_partial/_scrollbar.scss","hash":"424c08f4acc3f643567f138ffea7d8337791d2c4","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-archive.scss","hash":"a7374f46ca31bf8ebf5bafea909100921d0c52a4","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar-tags.scss","hash":"93cc82cb56663e83e90fbd6fe31ffdd38e694f3b","modified":1643556536274},{"_id":"themes/archer/src/scss/_partial/_sidebar/_sidebar.scss","hash":"b2870a9cdaea9b9c8426d406d6859a8f3f1a995f","modified":1643556536274},{"_id":"themes/archer/src/scss/_dark/_partial/_comment/_gitalk-dark.scss","hash":"f5d5c83166450e2346d0a2182c8726f8c98cfb1a","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-dark.scss","hash":"d074a8fef75ba626dd3448cc42290a8c722fd182","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_footer-fixed-dark.scss","hash":"f4e3eb7aa19c1061b5d9df4f6a7745902e5843f2","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_profile-dark.scss","hash":"c0fe68f6e9c196157adc71fea0d97f6f70f0a31b","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_partial/_header-dark.scss","hash":"ed815d959a37cccdf9137ace91c68bea8ca922c2","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_post/_code-dark.scss","hash":"9ded8203699f816558fd1493a3ce7cf3d38818e9","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-archive-dark.scss","hash":"79b7548214339807ff713f0c7454a227d24d6d0d","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-tags-dark.scss","hash":"6621db2ff1182e3cd14286af4b8f3d8c5bd14e2a","modified":1643556536250},{"_id":"themes/archer/src/scss/_dark/_partial/_sidebar/_sidebar-dark.scss","hash":"8e77738f83a425eebb00513ee98e487fe71fdc22","modified":1643556536250},{"_id":"themes/archer/src/scss/_mobile/_partial/_post/_writing-enhance-mobile.scss","hash":"9e714c1cdc61a4ebd5510667e87e879d0b14de67","modified":1643556536266},{"_id":"themes/archer/src/scss/_mobile/_partial/_sidebar/_sidebar-tags-mobile.scss","hash":"b5c62234defe693b4cfa65bda188d71c937eeaf9","modified":1643556536266},{"_id":"themes/archer/source/css/style.css.map","hash":"c9495e0d815109b6cb17ddaa1a99e10714e0a6e8","modified":1643556536190},{"_id":"themes/archer/source/font/Oswald-Regular.ttf","hash":"965d729546a43a8490ad4cf33c25ac475682100c","modified":1643556536198},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff","hash":"12eef75e1ad3eca9dae42b65505010ce4464a315","modified":1643556536198},{"_id":"themes/archer/source/font/SourceCodePro-Regular.ttf.woff2","hash":"f5991289ec17884cb641da0646d278d36702a190","modified":1643556536198},{"_id":"themes/archer/source/intro/404-bg.jpg","hash":"3afb5bb26f4ff0bd0e0a28df955c8aa7d746d3c5","modified":1643556536214},{"_id":"themes/archer/source/lib/jquery.min.js","hash":"ad886e472b3557f3dc7dfa2bc43468ab8d1cef5b","modified":1643556536218},{"_id":"themes/archer/source/scripts/customFontLoader.js.map","hash":"0fb40aed5a9c1d3f97dbad07ae3279229eaebea9","modified":1643556536218},{"_id":"themes/archer/source/scripts/share.js.map","hash":"b6a3e931cf44fdac5fd717f64019f2aa3b0d62ef","modified":1643556536222},{"_id":"themes/archer/source/intro/about-bg.jpg","hash":"ab388276822417cc4e703312c14e20280ec783b3","modified":1643556536214},{"_id":"themes/archer/source/intro/post-bg.jpg","hash":"525fafb2238c27754d8fa751f143ff1de9b8482d","modified":1643556536214},{"_id":"themes/archer/source/scripts/search.js","hash":"6f2e0cefb575617be37bfb2c2954f48e568e8f00","modified":1643556536218},{"_id":"themes/archer/package-lock.json","hash":"b0768219adb4e1abc5fa057ec2dcc5451f924ddb","modified":1643556536174},{"_id":"themes/archer/docs/snap.png","hash":"0b2a8bf016f6eed576abfdcdb7dcf8de51c12562","modified":1643556536150},{"_id":"themes/archer/source/intro/index-bg.jpg","hash":"96b52e177b8bc53e64ec6ee1e10b2b6a4e13083b","modified":1643556536214},{"_id":"themes/archer/source/scripts/search.js.map","hash":"1ecdd768a261ebede8b51ca383c9bf519a4f6c7c","modified":1643556536222},{"_id":"themes/archer/source/scripts/main.js","hash":"95f0284e68221e5f2f50e8a59de6f7fdda66608b","modified":1643556536218},{"_id":"themes/archer/source/scripts/main.js.map","hash":"b2f3bab368e872ecc910e48fff47797432ab019f","modified":1643556536218},{"_id":"source/_posts/2021-03-21-graphql-and-restful.md","hash":"4e3191a606effb13bb10cefecb5cfdcda1c1a1bc","modified":1643557321281},{"_id":"source/_posts/2021-05-09-Agile-Design.md","hash":"150cd2043dc516db455d52a06fbe360923432a26","modified":1643556753570},{"_id":"source/_posts/2021-06-15-Django-With-DDD.md","hash":"42751ceef6024e290f2c2ed8adc2c646dc9b7a35","modified":1643556753570},{"_id":"source/_posts/2021-06-17-DRF-Exception.md","hash":"fa6f4505ef65dfb17cd18cb967658cb3b96dc609","modified":1643556753570},{"_id":"source/_posts/2021-07-15-parallel-and-asynchronous-python.md","hash":"e287a2a7eabfb9e5fad277345d590a7580d0e979","modified":1643556753570},{"_id":"source/_posts/2021-03-30-DRF-Bussiness-Logic.md","hash":"251588be627dd011c348cf9ad92d47edec9f9675","modified":1643556753570},{"_id":"source/_posts/2021-11-21-product.md","hash":"fb0d59d41e34453452e972458f8c7dd797b0819d","modified":1643556753570},{"_id":"source/_posts/2021-12-16-design-doc.md","hash":"d3df83b3a2905ab909f52375ca36ab262902e996","modified":1643556753570},{"_id":"source/_posts/2022-01-30-知识掌握的广度与深度.md","hash":"17cc1acbc0ca7915444d561768ad9e4804d5dad1","modified":1643557087488},{"_id":"source/_posts/Agile-Dev.md","hash":"ce37bb155a22a6d282f3db1f0ad25ecb0eeee2d5","modified":1643557019497},{"_id":"source/_posts/New-Coding-Language.md","hash":"822d3b02ed5b0d2c2b27ab7eb7bc9c926a7577e5","modified":1643557295949},{"_id":"source/_posts/grpc-hello-world.md","hash":"0c1377668bca9f011ad6dbebb7f77cbfe9010df0","modified":1643557331913},{"_id":"source/_posts/study-rust-by-talent-plan.md","hash":"ec3055d204bbfaa70a2af4ca5162cb7b5e70b8e8","modified":1643557196507},{"_id":"source/about/index.md","hash":"4cda189ae2350e623af6a7b70f73240d865071fe","modified":1643556803173},{"_id":"source/_posts/graphql-and-restful.md","hash":"4e3191a606effb13bb10cefecb5cfdcda1c1a1bc","modified":1643557321281},{"_id":"source/tags/index.md","hash":"df36198a1fc555f25c6ac9cc2bb8d85f427699b8","modified":1643557689496},{"_id":"source/_posts/Agile-Design.md","hash":"229235063c76192bd38d39772aca3635b6676c36","modified":1643558029529},{"_id":"source/_posts/DRF-Bussiness-Logic.md","hash":"e476fb7c94467ddcbcb409921e6599b8646b975d","modified":1643558342766},{"_id":"source/_posts/DRF-Exception.md","hash":"7171dd9e26dc972c6e770bf31de3707b5f58f9d7","modified":1643558416209},{"_id":"source/_posts/Django-With-DDD.md","hash":"efdde02f548f2c0d2ad79e77a3e8e7661bd83094","modified":1643558381169},{"_id":"source/_posts/breaking-creation-product.md","hash":"780b5052ed71b76c6c465a092fe49188009d67c2","modified":1643558463540},{"_id":"source/_posts/parallel-and-asynchronous-python.md","hash":"2caabcec3b199c7e907932c8e7af5ff5833ec643","modified":1643558301662},{"_id":"source/_posts/software-design-doc.md","hash":"1b10a34931e3c39e06cbf94c14d3eb49f36c7347","modified":1643558498008},{"_id":"source/_posts/知识掌握的广度与深度.md","hash":"17cc1acbc0ca7915444d561768ad9e4804d5dad1","modified":1643557087488},{"_id":"source/avatar.jpg","hash":"9ac0f54a8ae0a95a997952aa1450ccd387e4253a","modified":1643559804108},{"_id":"source/avatar/avatar.jpg","hash":"9ac0f54a8ae0a95a997952aa1450ccd387e4253a","modified":1643559804108},{"_id":"source/_posts/knowledge-breath-and-depth.md","hash":"17cc1acbc0ca7915444d561768ad9e4804d5dad1","modified":1643561723397}],"Category":[],"Data":[],"Page":[{"layout":"page","title":"About","_content":"\n### About ME\n\n2014年开始接触Python，也是第一次接触代码。那时候想要搭建一个微信公众号后台做自动回复，从百度搜索“Python一步一步搭建微信公众号后台”开始，申请SAE（新浪云），copy代码，调Python缩进，改代码逻辑返回更丰富的信息...。就这样，开始了学会编码。\n\n大学时代，在别人都使用Matlab和Fortran（是的，古老的算法是用Fortran写的，所以我们也需要学Fortran，以便至少能看懂那些历史遗迹。有趣的是，这门课是我大学所有课程的唯一最高分。）处理数据时，我用Python。有印象的是，使用Python做了一个程序自动读取excel数据，完成计算并填写回表格，提交作业的时候，把这个程序打包成exe文件提交。这个事情花了我一个晚上。\n\n考研没有成功之后，开始从事程序员的工作。我很有幸，得到一些大佬的赏识，愿意接纳我一个没有任何大型编码项目，也不是很了解计算机原理和操作系统的同学，参与到他们的项目之中。\n\n到今天，终于能够自己独立设计完成后端项目。\n\n当前，正在涉猎分布式存储与计算，协助公司设计计算框架，搭建计算和存储平台。\n\n如果时间还充裕，会涉猎一些react的东西。\n\n平时，就研究研究金融和哲学，赚钱思考两不误。\n\n#### 业务后端开发\n\n- 深入研究Django及其生态如DRF、Filter等框架，持续读代码和文档，改进后端架构设计\n- 了解celery的机制，其实celery有很多限制，对于跑业务算法不能满足，所以在我负责的项目中很少使用，更多只是当作一种设计思路的学习\n- 进程、线程、协程研究中，希望找到python本身足以支撑并行的能力，以设计计算 框架\n- Postgres研究中\n- Redis研究中\n\n#### 分布式服务\n积极读论文\n- Raft协议学习中\n- 分布式锁\n\n### Contact\n\nzhangn661@gmail.com\n","source":"about/index.md","raw":"---\nlayout: page\ntitle: About\n---\n\n### About ME\n\n2014年开始接触Python，也是第一次接触代码。那时候想要搭建一个微信公众号后台做自动回复，从百度搜索“Python一步一步搭建微信公众号后台”开始，申请SAE（新浪云），copy代码，调Python缩进，改代码逻辑返回更丰富的信息...。就这样，开始了学会编码。\n\n大学时代，在别人都使用Matlab和Fortran（是的，古老的算法是用Fortran写的，所以我们也需要学Fortran，以便至少能看懂那些历史遗迹。有趣的是，这门课是我大学所有课程的唯一最高分。）处理数据时，我用Python。有印象的是，使用Python做了一个程序自动读取excel数据，完成计算并填写回表格，提交作业的时候，把这个程序打包成exe文件提交。这个事情花了我一个晚上。\n\n考研没有成功之后，开始从事程序员的工作。我很有幸，得到一些大佬的赏识，愿意接纳我一个没有任何大型编码项目，也不是很了解计算机原理和操作系统的同学，参与到他们的项目之中。\n\n到今天，终于能够自己独立设计完成后端项目。\n\n当前，正在涉猎分布式存储与计算，协助公司设计计算框架，搭建计算和存储平台。\n\n如果时间还充裕，会涉猎一些react的东西。\n\n平时，就研究研究金融和哲学，赚钱思考两不误。\n\n#### 业务后端开发\n\n- 深入研究Django及其生态如DRF、Filter等框架，持续读代码和文档，改进后端架构设计\n- 了解celery的机制，其实celery有很多限制，对于跑业务算法不能满足，所以在我负责的项目中很少使用，更多只是当作一种设计思路的学习\n- 进程、线程、协程研究中，希望找到python本身足以支撑并行的能力，以设计计算 框架\n- Postgres研究中\n- Redis研究中\n\n#### 分布式服务\n积极读论文\n- Raft协议学习中\n- 分布式锁\n\n### Contact\n\nzhangn661@gmail.com\n","date":"2022-01-30T15:33:23.173Z","updated":"2022-01-30T15:33:23.173Z","path":"about/index.html","_id":"ckz1fa9tf000ds5ht0vx02xk6","comments":1,"content":"<h3 id=\"About-ME\"><a href=\"#About-ME\" class=\"headerlink\" title=\"About ME\"></a>About ME</h3><p>2014年开始接触Python，也是第一次接触代码。那时候想要搭建一个微信公众号后台做自动回复，从百度搜索“Python一步一步搭建微信公众号后台”开始，申请SAE（新浪云），copy代码，调Python缩进，改代码逻辑返回更丰富的信息…。就这样，开始了学会编码。</p>\n<p>大学时代，在别人都使用Matlab和Fortran（是的，古老的算法是用Fortran写的，所以我们也需要学Fortran，以便至少能看懂那些历史遗迹。有趣的是，这门课是我大学所有课程的唯一最高分。）处理数据时，我用Python。有印象的是，使用Python做了一个程序自动读取excel数据，完成计算并填写回表格，提交作业的时候，把这个程序打包成exe文件提交。这个事情花了我一个晚上。</p>\n<p>考研没有成功之后，开始从事程序员的工作。我很有幸，得到一些大佬的赏识，愿意接纳我一个没有任何大型编码项目，也不是很了解计算机原理和操作系统的同学，参与到他们的项目之中。</p>\n<p>到今天，终于能够自己独立设计完成后端项目。</p>\n<p>当前，正在涉猎分布式存储与计算，协助公司设计计算框架，搭建计算和存储平台。</p>\n<p>如果时间还充裕，会涉猎一些react的东西。</p>\n<p>平时，就研究研究金融和哲学，赚钱思考两不误。</p>\n<h4 id=\"业务后端开发\"><a href=\"#业务后端开发\" class=\"headerlink\" title=\"业务后端开发\"></a>业务后端开发</h4><ul>\n<li>深入研究Django及其生态如DRF、Filter等框架，持续读代码和文档，改进后端架构设计</li>\n<li>了解celery的机制，其实celery有很多限制，对于跑业务算法不能满足，所以在我负责的项目中很少使用，更多只是当作一种设计思路的学习</li>\n<li>进程、线程、协程研究中，希望找到python本身足以支撑并行的能力，以设计计算 框架</li>\n<li>Postgres研究中</li>\n<li>Redis研究中</li>\n</ul>\n<h4 id=\"分布式服务\"><a href=\"#分布式服务\" class=\"headerlink\" title=\"分布式服务\"></a>分布式服务</h4><p>积极读论文</p>\n<ul>\n<li>Raft协议学习中</li>\n<li>分布式锁</li>\n</ul>\n<h3 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h3><p><a href=\"mailto:&#122;&#104;&#x61;&#x6e;&#103;&#x6e;&#x36;&#54;&#x31;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;\">&#122;&#104;&#x61;&#x6e;&#103;&#x6e;&#x36;&#54;&#x31;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"About-ME\"><a href=\"#About-ME\" class=\"headerlink\" title=\"About ME\"></a>About ME</h3><p>2014年开始接触Python，也是第一次接触代码。那时候想要搭建一个微信公众号后台做自动回复，从百度搜索“Python一步一步搭建微信公众号后台”开始，申请SAE（新浪云），copy代码，调Python缩进，改代码逻辑返回更丰富的信息…。就这样，开始了学会编码。</p>\n<p>大学时代，在别人都使用Matlab和Fortran（是的，古老的算法是用Fortran写的，所以我们也需要学Fortran，以便至少能看懂那些历史遗迹。有趣的是，这门课是我大学所有课程的唯一最高分。）处理数据时，我用Python。有印象的是，使用Python做了一个程序自动读取excel数据，完成计算并填写回表格，提交作业的时候，把这个程序打包成exe文件提交。这个事情花了我一个晚上。</p>\n<p>考研没有成功之后，开始从事程序员的工作。我很有幸，得到一些大佬的赏识，愿意接纳我一个没有任何大型编码项目，也不是很了解计算机原理和操作系统的同学，参与到他们的项目之中。</p>\n<p>到今天，终于能够自己独立设计完成后端项目。</p>\n<p>当前，正在涉猎分布式存储与计算，协助公司设计计算框架，搭建计算和存储平台。</p>\n<p>如果时间还充裕，会涉猎一些react的东西。</p>\n<p>平时，就研究研究金融和哲学，赚钱思考两不误。</p>\n<h4 id=\"业务后端开发\"><a href=\"#业务后端开发\" class=\"headerlink\" title=\"业务后端开发\"></a>业务后端开发</h4><ul>\n<li>深入研究Django及其生态如DRF、Filter等框架，持续读代码和文档，改进后端架构设计</li>\n<li>了解celery的机制，其实celery有很多限制，对于跑业务算法不能满足，所以在我负责的项目中很少使用，更多只是当作一种设计思路的学习</li>\n<li>进程、线程、协程研究中，希望找到python本身足以支撑并行的能力，以设计计算 框架</li>\n<li>Postgres研究中</li>\n<li>Redis研究中</li>\n</ul>\n<h4 id=\"分布式服务\"><a href=\"#分布式服务\" class=\"headerlink\" title=\"分布式服务\"></a>分布式服务</h4><p>积极读论文</p>\n<ul>\n<li>Raft协议学习中</li>\n<li>分布式锁</li>\n</ul>\n<h3 id=\"Contact\"><a href=\"#Contact\" class=\"headerlink\" title=\"Contact\"></a>Contact</h3><p><a href=\"mailto:&#122;&#104;&#x61;&#x6e;&#103;&#x6e;&#x36;&#54;&#x31;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;\">&#122;&#104;&#x61;&#x6e;&#103;&#x6e;&#x36;&#54;&#x31;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p>\n"},{"title":"tags","date":"2022-01-30T15:48:09.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2022-01-30 23:48:09\n---\n","updated":"2022-01-30T15:48:09.496Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckz1ftd6w0000clht50zeaunt","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"通过 talent-plan 项目学习rust","date":"2022-01-27T16:00:00.000Z","_content":"\n[toc]\n\n### 前言\n本篇不介绍基本的条件语句，变量初始化等语法，相关语法通过阅读教程可以学习，通过编写项目可以很快掌握。本篇更多的是介绍Rust的一些核心特性。\n### talent-plan项目介绍\n\n[talent-plan](https://github.com/pingcap/talent-plan) 是[pingcap](https://en.pingcap.com/)提供的一个github课程，包括实现基本kv存储引擎，实现分布式引擎等等课程。具体可查看对应链接。\n\n### Rust核心特征\n通过完成project-1，我们可以接触到许多rust的核心。\n#### 面向对象设计\n- 定义对象\n```Rust\n#[derive(Default)]\npub struct KvStore {\n    pub store_map: HashMap<String, String>,\n}\n```\nRust只有`struct`的概念，通过定义`struct`来定义一个面向对象语言中的“类”，并且为其定义属性。其中，通过添加`pub`表示该属性为`public`类型的属性\n- 定义对象的方法\n```Rust\nimpl KvStore {\n    pub fn new() -> KvStore {\n        KvStore {\n            store_map: HashMap::new(),\n        }\n    }\n    pub fn set(&mut self, key: String, value: String) {\n        self.store_map.insert(key, value);\n    }\n    pub fn get(&self, key: String) -> Option<String> {\n        let value = &self.store_map.get(&key);\n        return match value {\n            None => None,\n            Some(data) => Some(data.to_string()),\n        };\n    }\n    pub fn remove(&mut self, key: String) {\n        self.store_map.remove(&key);\n    }\n}\n```\n其中，`pub`指定了该方法是一个`public`类型的方法，不指定则是一个`private`的方法。由于Rust不使用继承，通过组合来结构代码，所以不需要`protected`的方法。\n- 参考\n[rust面向对象语言的特征](https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html)\n\n#### 泛型支持\n#### 枚举与模式匹配\n#### 变量生命周期\n变量生命周期管理的设计，是Rust作为一门手动管理内存的语言能同时保证安全与高性能的原因。作为基础介绍，将直接看代码，详细介绍可以看参考，以及其他blog。\n\n#### 引用与借用\n引用与借用，是基于变量生命周期管理设计的变量传递的方法，单独描述\n\n#### trait定义\ntrait在project-1中没有直接应用，如果有使用到简短的方法来定义command，在理解为什么可以这么实现的时候，就会开始接触到trait\n","source":"_posts/study-rust-by-talent-plan.md","raw":"---\ntitle: 通过 talent-plan 项目学习rust\ndate: 2022-01-28\n---\n\n[toc]\n\n### 前言\n本篇不介绍基本的条件语句，变量初始化等语法，相关语法通过阅读教程可以学习，通过编写项目可以很快掌握。本篇更多的是介绍Rust的一些核心特性。\n### talent-plan项目介绍\n\n[talent-plan](https://github.com/pingcap/talent-plan) 是[pingcap](https://en.pingcap.com/)提供的一个github课程，包括实现基本kv存储引擎，实现分布式引擎等等课程。具体可查看对应链接。\n\n### Rust核心特征\n通过完成project-1，我们可以接触到许多rust的核心。\n#### 面向对象设计\n- 定义对象\n```Rust\n#[derive(Default)]\npub struct KvStore {\n    pub store_map: HashMap<String, String>,\n}\n```\nRust只有`struct`的概念，通过定义`struct`来定义一个面向对象语言中的“类”，并且为其定义属性。其中，通过添加`pub`表示该属性为`public`类型的属性\n- 定义对象的方法\n```Rust\nimpl KvStore {\n    pub fn new() -> KvStore {\n        KvStore {\n            store_map: HashMap::new(),\n        }\n    }\n    pub fn set(&mut self, key: String, value: String) {\n        self.store_map.insert(key, value);\n    }\n    pub fn get(&self, key: String) -> Option<String> {\n        let value = &self.store_map.get(&key);\n        return match value {\n            None => None,\n            Some(data) => Some(data.to_string()),\n        };\n    }\n    pub fn remove(&mut self, key: String) {\n        self.store_map.remove(&key);\n    }\n}\n```\n其中，`pub`指定了该方法是一个`public`类型的方法，不指定则是一个`private`的方法。由于Rust不使用继承，通过组合来结构代码，所以不需要`protected`的方法。\n- 参考\n[rust面向对象语言的特征](https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html)\n\n#### 泛型支持\n#### 枚举与模式匹配\n#### 变量生命周期\n变量生命周期管理的设计，是Rust作为一门手动管理内存的语言能同时保证安全与高性能的原因。作为基础介绍，将直接看代码，详细介绍可以看参考，以及其他blog。\n\n#### 引用与借用\n引用与借用，是基于变量生命周期管理设计的变量传递的方法，单独描述\n\n#### trait定义\ntrait在project-1中没有直接应用，如果有使用到简短的方法来定义command，在理解为什么可以这么实现的时候，就会开始接触到trait\n","slug":"study-rust-by-talent-plan","published":1,"updated":"2022-01-30T15:39:56.507Z","_id":"ckz1f97kb000cs5ht570qb878","comments":1,"layout":"post","photos":[],"link":"","content":"<p>[toc]</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本篇不介绍基本的条件语句，变量初始化等语法，相关语法通过阅读教程可以学习，通过编写项目可以很快掌握。本篇更多的是介绍Rust的一些核心特性。</p>\n<h3 id=\"talent-plan项目介绍\"><a href=\"#talent-plan项目介绍\" class=\"headerlink\" title=\"talent-plan项目介绍\"></a>talent-plan项目介绍</h3><p><a href=\"https://github.com/pingcap/talent-plan\">talent-plan</a> 是<a href=\"https://en.pingcap.com/\">pingcap</a>提供的一个github课程，包括实现基本kv存储引擎，实现分布式引擎等等课程。具体可查看对应链接。</p>\n<h3 id=\"Rust核心特征\"><a href=\"#Rust核心特征\" class=\"headerlink\" title=\"Rust核心特征\"></a>Rust核心特征</h3><p>通过完成project-1，我们可以接触到许多rust的核心。</p>\n<h4 id=\"面向对象设计\"><a href=\"#面向对象设计\" class=\"headerlink\" title=\"面向对象设计\"></a>面向对象设计</h4><ul>\n<li>定义对象<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Default)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">KvStore</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> store_map: HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nRust只有<code>struct</code>的概念，通过定义<code>struct</code>来定义一个面向对象语言中的“类”，并且为其定义属性。其中，通过添加<code>pub</code>表示该属性为<code>public</code>类型的属性</li>\n<li>定义对象的方法<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> KvStore &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>() -&gt; KvStore &#123;</span><br><span class=\"line\">        KvStore &#123;</span><br><span class=\"line\">            store_map: HashMap::new(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, key: <span class=\"built_in\">String</span>, value: <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.store_map.insert(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get</span></span>(&amp;<span class=\"keyword\">self</span>, key: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = &amp;<span class=\"keyword\">self</span>.store_map.get(&amp;key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">match</span> value &#123;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(data) =&gt; <span class=\"literal\">Some</span>(data.to_string()),</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">remove</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, key: <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.store_map.remove(&amp;key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n其中，<code>pub</code>指定了该方法是一个<code>public</code>类型的方法，不指定则是一个<code>private</code>的方法。由于Rust不使用继承，通过组合来结构代码，所以不需要<code>protected</code>的方法。</li>\n<li>参考<br><a href=\"https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html\">rust面向对象语言的特征</a></li>\n</ul>\n<h4 id=\"泛型支持\"><a href=\"#泛型支持\" class=\"headerlink\" title=\"泛型支持\"></a>泛型支持</h4><h4 id=\"枚举与模式匹配\"><a href=\"#枚举与模式匹配\" class=\"headerlink\" title=\"枚举与模式匹配\"></a>枚举与模式匹配</h4><h4 id=\"变量生命周期\"><a href=\"#变量生命周期\" class=\"headerlink\" title=\"变量生命周期\"></a>变量生命周期</h4><p>变量生命周期管理的设计，是Rust作为一门手动管理内存的语言能同时保证安全与高性能的原因。作为基础介绍，将直接看代码，详细介绍可以看参考，以及其他blog。</p>\n<h4 id=\"引用与借用\"><a href=\"#引用与借用\" class=\"headerlink\" title=\"引用与借用\"></a>引用与借用</h4><p>引用与借用，是基于变量生命周期管理设计的变量传递的方法，单独描述</p>\n<h4 id=\"trait定义\"><a href=\"#trait定义\" class=\"headerlink\" title=\"trait定义\"></a>trait定义</h4><p>trait在project-1中没有直接应用，如果有使用到简短的方法来定义command，在理解为什么可以这么实现的时候，就会开始接触到trait</p>\n","site":{"data":{}},"excerpt":"","more":"<p>[toc]</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>本篇不介绍基本的条件语句，变量初始化等语法，相关语法通过阅读教程可以学习，通过编写项目可以很快掌握。本篇更多的是介绍Rust的一些核心特性。</p>\n<h3 id=\"talent-plan项目介绍\"><a href=\"#talent-plan项目介绍\" class=\"headerlink\" title=\"talent-plan项目介绍\"></a>talent-plan项目介绍</h3><p><a href=\"https://github.com/pingcap/talent-plan\">talent-plan</a> 是<a href=\"https://en.pingcap.com/\">pingcap</a>提供的一个github课程，包括实现基本kv存储引擎，实现分布式引擎等等课程。具体可查看对应链接。</p>\n<h3 id=\"Rust核心特征\"><a href=\"#Rust核心特征\" class=\"headerlink\" title=\"Rust核心特征\"></a>Rust核心特征</h3><p>通过完成project-1，我们可以接触到许多rust的核心。</p>\n<h4 id=\"面向对象设计\"><a href=\"#面向对象设计\" class=\"headerlink\" title=\"面向对象设计\"></a>面向对象设计</h4><ul>\n<li>定义对象<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#[derive(Default)]</span></span><br><span class=\"line\"><span class=\"keyword\">pub</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">KvStore</span></span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> store_map: HashMap&lt;<span class=\"built_in\">String</span>, <span class=\"built_in\">String</span>&gt;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\nRust只有<code>struct</code>的概念，通过定义<code>struct</code>来定义一个面向对象语言中的“类”，并且为其定义属性。其中，通过添加<code>pub</code>表示该属性为<code>public</code>类型的属性</li>\n<li>定义对象的方法<figure class=\"highlight rust\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">impl</span> KvStore &#123;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">new</span></span>() -&gt; KvStore &#123;</span><br><span class=\"line\">        KvStore &#123;</span><br><span class=\"line\">            store_map: HashMap::new(),</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">set</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, key: <span class=\"built_in\">String</span>, value: <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.store_map.insert(key, value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">get</span></span>(&amp;<span class=\"keyword\">self</span>, key: <span class=\"built_in\">String</span>) -&gt; <span class=\"built_in\">Option</span>&lt;<span class=\"built_in\">String</span>&gt; &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> value = &amp;<span class=\"keyword\">self</span>.store_map.get(&amp;key);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">match</span> value &#123;</span><br><span class=\"line\">            <span class=\"literal\">None</span> =&gt; <span class=\"literal\">None</span>,</span><br><span class=\"line\">            <span class=\"literal\">Some</span>(data) =&gt; <span class=\"literal\">Some</span>(data.to_string()),</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">pub</span> <span class=\"function\"><span class=\"keyword\">fn</span> <span class=\"title\">remove</span></span>(&amp;<span class=\"keyword\">mut</span> <span class=\"keyword\">self</span>, key: <span class=\"built_in\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.store_map.remove(&amp;key);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n其中，<code>pub</code>指定了该方法是一个<code>public</code>类型的方法，不指定则是一个<code>private</code>的方法。由于Rust不使用继承，通过组合来结构代码，所以不需要<code>protected</code>的方法。</li>\n<li>参考<br><a href=\"https://kaisery.github.io/trpl-zh-cn/ch17-01-what-is-oo.html\">rust面向对象语言的特征</a></li>\n</ul>\n<h4 id=\"泛型支持\"><a href=\"#泛型支持\" class=\"headerlink\" title=\"泛型支持\"></a>泛型支持</h4><h4 id=\"枚举与模式匹配\"><a href=\"#枚举与模式匹配\" class=\"headerlink\" title=\"枚举与模式匹配\"></a>枚举与模式匹配</h4><h4 id=\"变量生命周期\"><a href=\"#变量生命周期\" class=\"headerlink\" title=\"变量生命周期\"></a>变量生命周期</h4><p>变量生命周期管理的设计，是Rust作为一门手动管理内存的语言能同时保证安全与高性能的原因。作为基础介绍，将直接看代码，详细介绍可以看参考，以及其他blog。</p>\n<h4 id=\"引用与借用\"><a href=\"#引用与借用\" class=\"headerlink\" title=\"引用与借用\"></a>引用与借用</h4><p>引用与借用，是基于变量生命周期管理设计的变量传递的方法，单独描述</p>\n<h4 id=\"trait定义\"><a href=\"#trait定义\" class=\"headerlink\" title=\"trait定义\"></a>trait定义</h4><p>trait在project-1中没有直接应用，如果有使用到简短的方法来定义command，在理解为什么可以这么实现的时候，就会开始接触到trait</p>\n"},{"layout":"post","title":"敏捷开发辅助新项目验证与落地","author":"Edison","date":"2020-11-07T16:00:00.000Z","_content":"\n### 精益创业中的反馈循环\n在《精益创业》这本书中提到的一个反馈循环为```开发-测量-认知```。即，使用最小的力量开发一个产品，将其投入到小范围的市场中进行假设验证，最后收集反馈进行认知更新，并迭代到开发中。在这个循环中，如果一切顺利的话，我们会将产品逐渐优化。如果测量验证出现非期望的结果，我们可以及时终止投入，减少沉没成本。\n\n### 何为MVP\nMVP，英文为：Minimum Viable Product。即最小有价值（可用）产品。许多人将关注点放在可用，却忽视了验证可用。部分产品经理在设计产品及进行排期的时候，是按产品的功能堆迭进行排期的。即一期包含了什么功能，二期包含了什么功能。却从来没有去想一期验证了用户需要什么功能，二期验证了用户需要什么功能。\n\n我们在某一个系统设计的时候，在最初阶段，没有对数据库索引做设计。我们认为，在当时的阶段，尽快将业务逻辑实现，并验证模型设计是适合业务应用的，那才是当务之急。做索引设计只会分散我们的注意力和时间，而无益于我们验证设计是否符合需求。按照需求的持续发展，我们在根据实际情况进行索引的设计与增添，是完全来得及的。也就是说，就那个阶段而言，模型设计与业务逻辑实现才是MVP，索引设计不包含在MVP之中。而这一切，基于我们要验证什么需求，而不是基于我们想要推出什么功能。\n\n### 验证需求而不是满足需求\n\n我们在设计一款产品的时候，需求来源往往有两个。一个是用户明确提出他对某个具体的功能或者服务有需求；另一个是产品设计者通过某些调研判断某个功能或者服务能解决用户当前意识不到的需求，即创造用户需求。举个例子，老年人可以方便的使用微信，不是简单的老年人也能学习微信，微信方便易学，而是老年人不得不去学。所以微信为老年人创造了需求。\n\n无论一个需求来源于何处，基本上他都是一个假设性的需求。**我们所做的每一款产品，并不是在解决或者满足用户的需求，而是在持续不断的验证用户确实有这些需求**。如果我们能够站在这个角度去思考产品设计的时候，我们就该知道，当对产品进行迭代排期，需要达成的目标是，每一次更新验证了什么，而不是每一次更新解决了什么。\n\n所有的需求都有多个解决方案，没有一个人的解决方案是绝对可行的。但是我们却可以验证某个实践确实解决了问题。也就是说，做出来才是第一要务，设计是为了做的更好，本质仍在于做出产品。\n\n### 敏捷开发辅助新产品实践\n\n敏捷开发一个核心要义就是快速迭代。\n\n用户的需求如果是非常紧急的，即缺少了某种解决方案会非常不方便。比如下班高峰期打不到出租车，需要更多的车投入运营等；或者用户的需求是被创造出来的。比如不玩微信玩抖音，不玩抖音看电视。无论是什么样子的需求，用市场的角度去解析，都是“不稳定”的。需求时刻在变，要求迭代要足够快速，用迭代来验证需求已经改变；用产品更新来让持续产生用户价值。\n\n如果我们意识不到迭代的重要性，认为目前没有迭代的情况下，用户仍能很好的处理好自己的问题，而不积极去推进自己的产品迭代，那相当于，我们自己放弃了验证用户需求的机会。其结果会是两种，如果用户有多个依赖，那么，用户需求会被其他的迭代更快的产品所验证和满足，如果用户只能使用自己的产品，比如，规定了我们只能使用某一款笔记本，工作沟通工具等，且其迭代周期不够，那么当用户需求急升的时候，就会是该产品无法承受而被迫革新的时候。被革新虽然是常有的事，但是作为该产品的负责人和参与者，不一定希望自己的产品是这样的结尾 。\n\n### 总结\n敏捷开发模式希望通过坚持快速迭代来不断验证用户需求，最终保持产品持续走在最具竞争力的位置。即时验证用户需求不及预期，也可以降低沉没成本并即时调整航向。","source":"_posts/Agile-Dev.md","raw":"---\nlayout: post\ntitle: 敏捷开发辅助新项目验证与落地\nauthor: Edison\ndate: 2020/11/08\n---\n\n### 精益创业中的反馈循环\n在《精益创业》这本书中提到的一个反馈循环为```开发-测量-认知```。即，使用最小的力量开发一个产品，将其投入到小范围的市场中进行假设验证，最后收集反馈进行认知更新，并迭代到开发中。在这个循环中，如果一切顺利的话，我们会将产品逐渐优化。如果测量验证出现非期望的结果，我们可以及时终止投入，减少沉没成本。\n\n### 何为MVP\nMVP，英文为：Minimum Viable Product。即最小有价值（可用）产品。许多人将关注点放在可用，却忽视了验证可用。部分产品经理在设计产品及进行排期的时候，是按产品的功能堆迭进行排期的。即一期包含了什么功能，二期包含了什么功能。却从来没有去想一期验证了用户需要什么功能，二期验证了用户需要什么功能。\n\n我们在某一个系统设计的时候，在最初阶段，没有对数据库索引做设计。我们认为，在当时的阶段，尽快将业务逻辑实现，并验证模型设计是适合业务应用的，那才是当务之急。做索引设计只会分散我们的注意力和时间，而无益于我们验证设计是否符合需求。按照需求的持续发展，我们在根据实际情况进行索引的设计与增添，是完全来得及的。也就是说，就那个阶段而言，模型设计与业务逻辑实现才是MVP，索引设计不包含在MVP之中。而这一切，基于我们要验证什么需求，而不是基于我们想要推出什么功能。\n\n### 验证需求而不是满足需求\n\n我们在设计一款产品的时候，需求来源往往有两个。一个是用户明确提出他对某个具体的功能或者服务有需求；另一个是产品设计者通过某些调研判断某个功能或者服务能解决用户当前意识不到的需求，即创造用户需求。举个例子，老年人可以方便的使用微信，不是简单的老年人也能学习微信，微信方便易学，而是老年人不得不去学。所以微信为老年人创造了需求。\n\n无论一个需求来源于何处，基本上他都是一个假设性的需求。**我们所做的每一款产品，并不是在解决或者满足用户的需求，而是在持续不断的验证用户确实有这些需求**。如果我们能够站在这个角度去思考产品设计的时候，我们就该知道，当对产品进行迭代排期，需要达成的目标是，每一次更新验证了什么，而不是每一次更新解决了什么。\n\n所有的需求都有多个解决方案，没有一个人的解决方案是绝对可行的。但是我们却可以验证某个实践确实解决了问题。也就是说，做出来才是第一要务，设计是为了做的更好，本质仍在于做出产品。\n\n### 敏捷开发辅助新产品实践\n\n敏捷开发一个核心要义就是快速迭代。\n\n用户的需求如果是非常紧急的，即缺少了某种解决方案会非常不方便。比如下班高峰期打不到出租车，需要更多的车投入运营等；或者用户的需求是被创造出来的。比如不玩微信玩抖音，不玩抖音看电视。无论是什么样子的需求，用市场的角度去解析，都是“不稳定”的。需求时刻在变，要求迭代要足够快速，用迭代来验证需求已经改变；用产品更新来让持续产生用户价值。\n\n如果我们意识不到迭代的重要性，认为目前没有迭代的情况下，用户仍能很好的处理好自己的问题，而不积极去推进自己的产品迭代，那相当于，我们自己放弃了验证用户需求的机会。其结果会是两种，如果用户有多个依赖，那么，用户需求会被其他的迭代更快的产品所验证和满足，如果用户只能使用自己的产品，比如，规定了我们只能使用某一款笔记本，工作沟通工具等，且其迭代周期不够，那么当用户需求急升的时候，就会是该产品无法承受而被迫革新的时候。被革新虽然是常有的事，但是作为该产品的负责人和参与者，不一定希望自己的产品是这样的结尾 。\n\n### 总结\n敏捷开发模式希望通过坚持快速迭代来不断验证用户需求，最终保持产品持续走在最具竞争力的位置。即时验证用户需求不及预期，也可以降低沉没成本并即时调整航向。","slug":"Agile-Dev","published":1,"updated":"2022-01-30T15:36:59.497Z","_id":"ckz1fkjxu000es5ht0leh1wr9","comments":1,"photos":[],"link":"","content":"<h3 id=\"精益创业中的反馈循环\"><a href=\"#精益创业中的反馈循环\" class=\"headerlink\" title=\"精益创业中的反馈循环\"></a>精益创业中的反馈循环</h3><p>在《精益创业》这本书中提到的一个反馈循环为<code>开发-测量-认知</code>。即，使用最小的力量开发一个产品，将其投入到小范围的市场中进行假设验证，最后收集反馈进行认知更新，并迭代到开发中。在这个循环中，如果一切顺利的话，我们会将产品逐渐优化。如果测量验证出现非期望的结果，我们可以及时终止投入，减少沉没成本。</p>\n<h3 id=\"何为MVP\"><a href=\"#何为MVP\" class=\"headerlink\" title=\"何为MVP\"></a>何为MVP</h3><p>MVP，英文为：Minimum Viable Product。即最小有价值（可用）产品。许多人将关注点放在可用，却忽视了验证可用。部分产品经理在设计产品及进行排期的时候，是按产品的功能堆迭进行排期的。即一期包含了什么功能，二期包含了什么功能。却从来没有去想一期验证了用户需要什么功能，二期验证了用户需要什么功能。</p>\n<p>我们在某一个系统设计的时候，在最初阶段，没有对数据库索引做设计。我们认为，在当时的阶段，尽快将业务逻辑实现，并验证模型设计是适合业务应用的，那才是当务之急。做索引设计只会分散我们的注意力和时间，而无益于我们验证设计是否符合需求。按照需求的持续发展，我们在根据实际情况进行索引的设计与增添，是完全来得及的。也就是说，就那个阶段而言，模型设计与业务逻辑实现才是MVP，索引设计不包含在MVP之中。而这一切，基于我们要验证什么需求，而不是基于我们想要推出什么功能。</p>\n<h3 id=\"验证需求而不是满足需求\"><a href=\"#验证需求而不是满足需求\" class=\"headerlink\" title=\"验证需求而不是满足需求\"></a>验证需求而不是满足需求</h3><p>我们在设计一款产品的时候，需求来源往往有两个。一个是用户明确提出他对某个具体的功能或者服务有需求；另一个是产品设计者通过某些调研判断某个功能或者服务能解决用户当前意识不到的需求，即创造用户需求。举个例子，老年人可以方便的使用微信，不是简单的老年人也能学习微信，微信方便易学，而是老年人不得不去学。所以微信为老年人创造了需求。</p>\n<p>无论一个需求来源于何处，基本上他都是一个假设性的需求。<strong>我们所做的每一款产品，并不是在解决或者满足用户的需求，而是在持续不断的验证用户确实有这些需求</strong>。如果我们能够站在这个角度去思考产品设计的时候，我们就该知道，当对产品进行迭代排期，需要达成的目标是，每一次更新验证了什么，而不是每一次更新解决了什么。</p>\n<p>所有的需求都有多个解决方案，没有一个人的解决方案是绝对可行的。但是我们却可以验证某个实践确实解决了问题。也就是说，做出来才是第一要务，设计是为了做的更好，本质仍在于做出产品。</p>\n<h3 id=\"敏捷开发辅助新产品实践\"><a href=\"#敏捷开发辅助新产品实践\" class=\"headerlink\" title=\"敏捷开发辅助新产品实践\"></a>敏捷开发辅助新产品实践</h3><p>敏捷开发一个核心要义就是快速迭代。</p>\n<p>用户的需求如果是非常紧急的，即缺少了某种解决方案会非常不方便。比如下班高峰期打不到出租车，需要更多的车投入运营等；或者用户的需求是被创造出来的。比如不玩微信玩抖音，不玩抖音看电视。无论是什么样子的需求，用市场的角度去解析，都是“不稳定”的。需求时刻在变，要求迭代要足够快速，用迭代来验证需求已经改变；用产品更新来让持续产生用户价值。</p>\n<p>如果我们意识不到迭代的重要性，认为目前没有迭代的情况下，用户仍能很好的处理好自己的问题，而不积极去推进自己的产品迭代，那相当于，我们自己放弃了验证用户需求的机会。其结果会是两种，如果用户有多个依赖，那么，用户需求会被其他的迭代更快的产品所验证和满足，如果用户只能使用自己的产品，比如，规定了我们只能使用某一款笔记本，工作沟通工具等，且其迭代周期不够，那么当用户需求急升的时候，就会是该产品无法承受而被迫革新的时候。被革新虽然是常有的事，但是作为该产品的负责人和参与者，不一定希望自己的产品是这样的结尾 。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>敏捷开发模式希望通过坚持快速迭代来不断验证用户需求，最终保持产品持续走在最具竞争力的位置。即时验证用户需求不及预期，也可以降低沉没成本并即时调整航向。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"精益创业中的反馈循环\"><a href=\"#精益创业中的反馈循环\" class=\"headerlink\" title=\"精益创业中的反馈循环\"></a>精益创业中的反馈循环</h3><p>在《精益创业》这本书中提到的一个反馈循环为<code>开发-测量-认知</code>。即，使用最小的力量开发一个产品，将其投入到小范围的市场中进行假设验证，最后收集反馈进行认知更新，并迭代到开发中。在这个循环中，如果一切顺利的话，我们会将产品逐渐优化。如果测量验证出现非期望的结果，我们可以及时终止投入，减少沉没成本。</p>\n<h3 id=\"何为MVP\"><a href=\"#何为MVP\" class=\"headerlink\" title=\"何为MVP\"></a>何为MVP</h3><p>MVP，英文为：Minimum Viable Product。即最小有价值（可用）产品。许多人将关注点放在可用，却忽视了验证可用。部分产品经理在设计产品及进行排期的时候，是按产品的功能堆迭进行排期的。即一期包含了什么功能，二期包含了什么功能。却从来没有去想一期验证了用户需要什么功能，二期验证了用户需要什么功能。</p>\n<p>我们在某一个系统设计的时候，在最初阶段，没有对数据库索引做设计。我们认为，在当时的阶段，尽快将业务逻辑实现，并验证模型设计是适合业务应用的，那才是当务之急。做索引设计只会分散我们的注意力和时间，而无益于我们验证设计是否符合需求。按照需求的持续发展，我们在根据实际情况进行索引的设计与增添，是完全来得及的。也就是说，就那个阶段而言，模型设计与业务逻辑实现才是MVP，索引设计不包含在MVP之中。而这一切，基于我们要验证什么需求，而不是基于我们想要推出什么功能。</p>\n<h3 id=\"验证需求而不是满足需求\"><a href=\"#验证需求而不是满足需求\" class=\"headerlink\" title=\"验证需求而不是满足需求\"></a>验证需求而不是满足需求</h3><p>我们在设计一款产品的时候，需求来源往往有两个。一个是用户明确提出他对某个具体的功能或者服务有需求；另一个是产品设计者通过某些调研判断某个功能或者服务能解决用户当前意识不到的需求，即创造用户需求。举个例子，老年人可以方便的使用微信，不是简单的老年人也能学习微信，微信方便易学，而是老年人不得不去学。所以微信为老年人创造了需求。</p>\n<p>无论一个需求来源于何处，基本上他都是一个假设性的需求。<strong>我们所做的每一款产品，并不是在解决或者满足用户的需求，而是在持续不断的验证用户确实有这些需求</strong>。如果我们能够站在这个角度去思考产品设计的时候，我们就该知道，当对产品进行迭代排期，需要达成的目标是，每一次更新验证了什么，而不是每一次更新解决了什么。</p>\n<p>所有的需求都有多个解决方案，没有一个人的解决方案是绝对可行的。但是我们却可以验证某个实践确实解决了问题。也就是说，做出来才是第一要务，设计是为了做的更好，本质仍在于做出产品。</p>\n<h3 id=\"敏捷开发辅助新产品实践\"><a href=\"#敏捷开发辅助新产品实践\" class=\"headerlink\" title=\"敏捷开发辅助新产品实践\"></a>敏捷开发辅助新产品实践</h3><p>敏捷开发一个核心要义就是快速迭代。</p>\n<p>用户的需求如果是非常紧急的，即缺少了某种解决方案会非常不方便。比如下班高峰期打不到出租车，需要更多的车投入运营等；或者用户的需求是被创造出来的。比如不玩微信玩抖音，不玩抖音看电视。无论是什么样子的需求，用市场的角度去解析，都是“不稳定”的。需求时刻在变，要求迭代要足够快速，用迭代来验证需求已经改变；用产品更新来让持续产生用户价值。</p>\n<p>如果我们意识不到迭代的重要性，认为目前没有迭代的情况下，用户仍能很好的处理好自己的问题，而不积极去推进自己的产品迭代，那相当于，我们自己放弃了验证用户需求的机会。其结果会是两种，如果用户有多个依赖，那么，用户需求会被其他的迭代更快的产品所验证和满足，如果用户只能使用自己的产品，比如，规定了我们只能使用某一款笔记本，工作沟通工具等，且其迭代周期不够，那么当用户需求急升的时候，就会是该产品无法承受而被迫革新的时候。被革新虽然是常有的事，但是作为该产品的负责人和参与者，不一定希望自己的产品是这样的结尾 。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>敏捷开发模式希望通过坚持快速迭代来不断验证用户需求，最终保持产品持续走在最具竞争力的位置。即时验证用户需求不及预期，也可以降低沉没成本并即时调整航向。</p>\n"},{"layout":"post","title":"我如何学一门新的编程语言","date":"2021-01-02T16:00:00.000Z","_content":"\n### 先写一个demo\n学编程语言需要先用，先尝试使用他发挥作用。想想我们学习自己的母语，不是从认识拼音开始的，也不是从认字开始的，而是先模仿，喊出一些基本的称呼等等，逐步知道每个发音代表的一些特殊含义。我们不一定理解那些含义，但是我们已经尝试着让他发挥作用。\n我学习编程语言也是如此，写一个简单的小游戏或者小工具，也许是一个简单的猜字游戏，也许是一个定时闹钟，也许是一个仿grep功能的工具。不管是什么工具，我基本可以快速理清设计方案，然后花一个小时，基于google，找到各种代码编写的方案，完成小工具的实现。\n在实现的过程中，我会比想象中投入，因为我的目标已经变成了工具实现，而不是语言学习。犹如用新英雄打王者荣耀，刷野怪的时候我或许会体验一下新技能，打团战的时候我一门心思只想赢。做demo同理，我会因为关注成功实现而变得投入，会在敲下每一行代码的过程中，去了解编程语言在做某件事的时候的处理方式。\n这样，我对一门编程语言就有一个基本的印象了。\n\n### 开始看编程书\n看编程书很多时候只需要对内容描述有一个印象就可以了。看的过程中，我几乎不写代码。复现某一个语言特性，看起来是增强对语言的理解，但是如果只是做一次，其实很快就忘记了，所看个印象就可以了。我只大概看一下有些什么不一样的特性，看一眼代码是怎么展示这个特性就结束了。\n因为光看不练，是不能在需要的时候用上的。所以，看编程书的具体内容会看的很快，后面基本上只把编程书当做索引来查看，不再专门做完整的阅读。\n\n## 开始尝试使用代码\n正常情况下，在看完编程书后，再来写代码，基本是啥也写不出来的。就像数学题，完整的看了例题，到应用的时候，基本还是不知道从哪里入手。\n","source":"_posts/New-Coding-Language.md","raw":"---\nlayout: post\ntitle: 我如何学一门新的编程语言\ndate: 2021-01-03\n---\n\n### 先写一个demo\n学编程语言需要先用，先尝试使用他发挥作用。想想我们学习自己的母语，不是从认识拼音开始的，也不是从认字开始的，而是先模仿，喊出一些基本的称呼等等，逐步知道每个发音代表的一些特殊含义。我们不一定理解那些含义，但是我们已经尝试着让他发挥作用。\n我学习编程语言也是如此，写一个简单的小游戏或者小工具，也许是一个简单的猜字游戏，也许是一个定时闹钟，也许是一个仿grep功能的工具。不管是什么工具，我基本可以快速理清设计方案，然后花一个小时，基于google，找到各种代码编写的方案，完成小工具的实现。\n在实现的过程中，我会比想象中投入，因为我的目标已经变成了工具实现，而不是语言学习。犹如用新英雄打王者荣耀，刷野怪的时候我或许会体验一下新技能，打团战的时候我一门心思只想赢。做demo同理，我会因为关注成功实现而变得投入，会在敲下每一行代码的过程中，去了解编程语言在做某件事的时候的处理方式。\n这样，我对一门编程语言就有一个基本的印象了。\n\n### 开始看编程书\n看编程书很多时候只需要对内容描述有一个印象就可以了。看的过程中，我几乎不写代码。复现某一个语言特性，看起来是增强对语言的理解，但是如果只是做一次，其实很快就忘记了，所看个印象就可以了。我只大概看一下有些什么不一样的特性，看一眼代码是怎么展示这个特性就结束了。\n因为光看不练，是不能在需要的时候用上的。所以，看编程书的具体内容会看的很快，后面基本上只把编程书当做索引来查看，不再专门做完整的阅读。\n\n## 开始尝试使用代码\n正常情况下，在看完编程书后，再来写代码，基本是啥也写不出来的。就像数学题，完整的看了例题，到应用的时候，基本还是不知道从哪里入手。\n","slug":"New-Coding-Language","published":1,"updated":"2022-01-30T15:41:35.949Z","_id":"ckz1fl4ny000fs5ht96ol0ihj","comments":1,"photos":[],"link":"","content":"<h3 id=\"先写一个demo\"><a href=\"#先写一个demo\" class=\"headerlink\" title=\"先写一个demo\"></a>先写一个demo</h3><p>学编程语言需要先用，先尝试使用他发挥作用。想想我们学习自己的母语，不是从认识拼音开始的，也不是从认字开始的，而是先模仿，喊出一些基本的称呼等等，逐步知道每个发音代表的一些特殊含义。我们不一定理解那些含义，但是我们已经尝试着让他发挥作用。<br>我学习编程语言也是如此，写一个简单的小游戏或者小工具，也许是一个简单的猜字游戏，也许是一个定时闹钟，也许是一个仿grep功能的工具。不管是什么工具，我基本可以快速理清设计方案，然后花一个小时，基于google，找到各种代码编写的方案，完成小工具的实现。<br>在实现的过程中，我会比想象中投入，因为我的目标已经变成了工具实现，而不是语言学习。犹如用新英雄打王者荣耀，刷野怪的时候我或许会体验一下新技能，打团战的时候我一门心思只想赢。做demo同理，我会因为关注成功实现而变得投入，会在敲下每一行代码的过程中，去了解编程语言在做某件事的时候的处理方式。<br>这样，我对一门编程语言就有一个基本的印象了。</p>\n<h3 id=\"开始看编程书\"><a href=\"#开始看编程书\" class=\"headerlink\" title=\"开始看编程书\"></a>开始看编程书</h3><p>看编程书很多时候只需要对内容描述有一个印象就可以了。看的过程中，我几乎不写代码。复现某一个语言特性，看起来是增强对语言的理解，但是如果只是做一次，其实很快就忘记了，所看个印象就可以了。我只大概看一下有些什么不一样的特性，看一眼代码是怎么展示这个特性就结束了。<br>因为光看不练，是不能在需要的时候用上的。所以，看编程书的具体内容会看的很快，后面基本上只把编程书当做索引来查看，不再专门做完整的阅读。</p>\n<h2 id=\"开始尝试使用代码\"><a href=\"#开始尝试使用代码\" class=\"headerlink\" title=\"开始尝试使用代码\"></a>开始尝试使用代码</h2><p>正常情况下，在看完编程书后，再来写代码，基本是啥也写不出来的。就像数学题，完整的看了例题，到应用的时候，基本还是不知道从哪里入手。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"先写一个demo\"><a href=\"#先写一个demo\" class=\"headerlink\" title=\"先写一个demo\"></a>先写一个demo</h3><p>学编程语言需要先用，先尝试使用他发挥作用。想想我们学习自己的母语，不是从认识拼音开始的，也不是从认字开始的，而是先模仿，喊出一些基本的称呼等等，逐步知道每个发音代表的一些特殊含义。我们不一定理解那些含义，但是我们已经尝试着让他发挥作用。<br>我学习编程语言也是如此，写一个简单的小游戏或者小工具，也许是一个简单的猜字游戏，也许是一个定时闹钟，也许是一个仿grep功能的工具。不管是什么工具，我基本可以快速理清设计方案，然后花一个小时，基于google，找到各种代码编写的方案，完成小工具的实现。<br>在实现的过程中，我会比想象中投入，因为我的目标已经变成了工具实现，而不是语言学习。犹如用新英雄打王者荣耀，刷野怪的时候我或许会体验一下新技能，打团战的时候我一门心思只想赢。做demo同理，我会因为关注成功实现而变得投入，会在敲下每一行代码的过程中，去了解编程语言在做某件事的时候的处理方式。<br>这样，我对一门编程语言就有一个基本的印象了。</p>\n<h3 id=\"开始看编程书\"><a href=\"#开始看编程书\" class=\"headerlink\" title=\"开始看编程书\"></a>开始看编程书</h3><p>看编程书很多时候只需要对内容描述有一个印象就可以了。看的过程中，我几乎不写代码。复现某一个语言特性，看起来是增强对语言的理解，但是如果只是做一次，其实很快就忘记了，所看个印象就可以了。我只大概看一下有些什么不一样的特性，看一眼代码是怎么展示这个特性就结束了。<br>因为光看不练，是不能在需要的时候用上的。所以，看编程书的具体内容会看的很快，后面基本上只把编程书当做索引来查看，不再专门做完整的阅读。</p>\n<h2 id=\"开始尝试使用代码\"><a href=\"#开始尝试使用代码\" class=\"headerlink\" title=\"开始尝试使用代码\"></a>开始尝试使用代码</h2><p>正常情况下，在看完编程书后，再来写代码，基本是啥也写不出来的。就像数学题，完整的看了例题，到应用的时候，基本还是不知道从哪里入手。</p>\n"},{"layout":"post","title":"grpc hello world","author":"Edison","date":"2021-03-07T16:00:00.000Z","_content":"\n### 获取源码\n```\nhttps://github.com/grpc/grpc-go.git\n```\n源码在 ```grpc-go/examples/helloworld```文件夹\n\n### 源码解析\n#### proto文件\n- 声明使用proto3。这是最新版的格式，具体可以了解[proto3](https://developers.google.com/protocol-buffers/docs/proto3)与[proto2](https://developers.google.com/protocol-buffers/docs/proto)的区别。一般直接使用proto3即可。\n```\nsyntax = \"proto3\";\n```\n- 声明包路径，指向了使用proto文件生成的包名。默认与被应用的go包一致，也可以使用该声明自主定义。\n```\noption go_package = \"google.golang.org/grpc/examples/helloworld/helloworld\";\n```\n- 声明生成java代码时的一些规则，在此处应该没什么用。\n```\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\n```\n- 声明应用的包名。\n```\npackage helloworld;\n```\n- 声明服务调用接口。\n```\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n```\n- 消息体(message)定义。消息体是一个集成的结构，用于把各种参数集成到一个，类似于结构体。\n```\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n#### server文件\n- 头部声明。注意需要导入grpc包，同时需要把基于proto文件生成的包即```go_package```导入。\n```\n// Package main implements a server for Greeter service.\npackage main\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n```\n- 端口\n```\nconst (\n\tport = \":50051\"\n)\n```\n- 获取pb包里生成的server，并编写接口业务逻辑\n```\n// server is used to implement helloworld.GreeterServer.\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n// SayHello implements helloworld.GreeterServer\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n```\n- main函数，启动服务。使用grpc创建server，并注册到pb包中。\n```\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n```\n\n#### client文件\n- 与server一样，导入相关包\n```\n// Package main implements a client for Greeter service.\npackage main\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\nconst (\n\taddress     = \"localhost:50051\"\n\tdefaultName = \"world\"\n)\n```\n使用```pb.NewGreeterClient```创建client，并直接调用pb创建的service内接口```SayHello```.\n```\nfunc main() {\n\t// Set up a connection to the server.\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\t// Contact the server and print out its response.\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Greeting: %s\", r.GetMessage())\n}\n```\n\n### 总结\n\n使用grpc犹如餐厅里的厨房窗口(service)，服务员将菜单小票(request message)递进窗口，厨房做好菜后将菜(reply message)再送出来。   \n\n我们只需要再一开始将厨房窗口设计好，一个完整的做菜流就定义完成。后续只需要增加厨师和菜色，以满足不同的菜的需求即可。\n\n### 参考\n[proto3 语法](https://developers.google.com/protocol-buffers/docs/proto3)\n[基于go的教程](https://developers.google.com/protocol-buffers/docs/gotutorial)\n","source":"_posts/grpc-hello-world.md","raw":"---\nlayout: post\ntitle: grpc hello world\nauthor: Edison\ndate: 2021-03-08\n---\n\n### 获取源码\n```\nhttps://github.com/grpc/grpc-go.git\n```\n源码在 ```grpc-go/examples/helloworld```文件夹\n\n### 源码解析\n#### proto文件\n- 声明使用proto3。这是最新版的格式，具体可以了解[proto3](https://developers.google.com/protocol-buffers/docs/proto3)与[proto2](https://developers.google.com/protocol-buffers/docs/proto)的区别。一般直接使用proto3即可。\n```\nsyntax = \"proto3\";\n```\n- 声明包路径，指向了使用proto文件生成的包名。默认与被应用的go包一致，也可以使用该声明自主定义。\n```\noption go_package = \"google.golang.org/grpc/examples/helloworld/helloworld\";\n```\n- 声明生成java代码时的一些规则，在此处应该没什么用。\n```\noption java_multiple_files = true;\noption java_package = \"io.grpc.examples.helloworld\";\noption java_outer_classname = \"HelloWorldProto\";\n```\n- 声明应用的包名。\n```\npackage helloworld;\n```\n- 声明服务调用接口。\n```\n// The greeting service definition.\nservice Greeter {\n  // Sends a greeting\n  rpc SayHello (HelloRequest) returns (HelloReply) {}\n}\n```\n- 消息体(message)定义。消息体是一个集成的结构，用于把各种参数集成到一个，类似于结构体。\n```\n// The request message containing the user's name.\nmessage HelloRequest {\n  string name = 1;\n}\n// The response message containing the greetings\nmessage HelloReply {\n  string message = 1;\n}\n```\n\n#### server文件\n- 头部声明。注意需要导入grpc包，同时需要把基于proto文件生成的包即```go_package```导入。\n```\n// Package main implements a server for Greeter service.\npackage main\nimport (\n\t\"context\"\n\t\"log\"\n\t\"net\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\n```\n- 端口\n```\nconst (\n\tport = \":50051\"\n)\n```\n- 获取pb包里生成的server，并编写接口业务逻辑\n```\n// server is used to implement helloworld.GreeterServer.\ntype server struct {\n\tpb.UnimplementedGreeterServer\n}\n// SayHello implements helloworld.GreeterServer\nfunc (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {\n\tlog.Printf(\"Received: %v\", in.GetName())\n\treturn &pb.HelloReply{Message: \"Hello \" + in.GetName()}, nil\n}\n```\n- main函数，启动服务。使用grpc创建server，并注册到pb包中。\n```\nfunc main() {\n\tlis, err := net.Listen(\"tcp\", port)\n\tif err != nil {\n\t\tlog.Fatalf(\"failed to listen: %v\", err)\n\t}\n\ts := grpc.NewServer()\n\tpb.RegisterGreeterServer(s, &server{})\n\tif err := s.Serve(lis); err != nil {\n\t\tlog.Fatalf(\"failed to serve: %v\", err)\n\t}\n}\n```\n\n#### client文件\n- 与server一样，导入相关包\n```\n// Package main implements a client for Greeter service.\npackage main\nimport (\n\t\"context\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\tpb \"google.golang.org/grpc/examples/helloworld/helloworld\"\n)\nconst (\n\taddress     = \"localhost:50051\"\n\tdefaultName = \"world\"\n)\n```\n使用```pb.NewGreeterClient```创建client，并直接调用pb创建的service内接口```SayHello```.\n```\nfunc main() {\n\t// Set up a connection to the server.\n\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())\n\tif err != nil {\n\t\tlog.Fatalf(\"did not connect: %v\", err)\n\t}\n\tdefer conn.Close()\n\tc := pb.NewGreeterClient(conn)\n\t// Contact the server and print out its response.\n\tname := defaultName\n\tif len(os.Args) > 1 {\n\t\tname = os.Args[1]\n\t}\n\tctx, cancel := context.WithTimeout(context.Background(), time.Second)\n\tdefer cancel()\n\tr, err := c.SayHello(ctx, &pb.HelloRequest{Name: name})\n\tif err != nil {\n\t\tlog.Fatalf(\"could not greet: %v\", err)\n\t}\n\tlog.Printf(\"Greeting: %s\", r.GetMessage())\n}\n```\n\n### 总结\n\n使用grpc犹如餐厅里的厨房窗口(service)，服务员将菜单小票(request message)递进窗口，厨房做好菜后将菜(reply message)再送出来。   \n\n我们只需要再一开始将厨房窗口设计好，一个完整的做菜流就定义完成。后续只需要增加厨师和菜色，以满足不同的菜的需求即可。\n\n### 参考\n[proto3 语法](https://developers.google.com/protocol-buffers/docs/proto3)\n[基于go的教程](https://developers.google.com/protocol-buffers/docs/gotutorial)\n","slug":"grpc-hello-world","published":1,"updated":"2022-01-30T15:42:11.913Z","_id":"ckz1fm6bi000gs5ht8ljxajt6","comments":1,"photos":[],"link":"","content":"<h3 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/grpc/grpc-go.git</span><br></pre></td></tr></table></figure>\n<p>源码在 <code>grpc-go/examples/helloworld</code>文件夹</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><h4 id=\"proto文件\"><a href=\"#proto文件\" class=\"headerlink\" title=\"proto文件\"></a>proto文件</h4><ul>\n<li>声明使用proto3。这是最新版的格式，具体可以了解<a href=\"https://developers.google.com/protocol-buffers/docs/proto3\">proto3</a>与<a href=\"https://developers.google.com/protocol-buffers/docs/proto\">proto2</a>的区别。一般直接使用proto3即可。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br></pre></td></tr></table></figure></li>\n<li>声明包路径，指向了使用proto文件生成的包名。默认与被应用的go包一致，也可以使用该声明自主定义。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">option go_package = &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;;</span><br></pre></td></tr></table></figure></li>\n<li>声明生成java代码时的一些规则，在此处应该没什么用。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">option java_multiple_files = true;</span><br><span class=\"line\">option java_package = &quot;io.grpc.examples.helloworld&quot;;</span><br><span class=\"line\">option java_outer_classname = &quot;HelloWorldProto&quot;;</span><br></pre></td></tr></table></figure></li>\n<li>声明应用的包名。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package helloworld;</span><br></pre></td></tr></table></figure></li>\n<li>声明服务调用接口。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// The greeting service definition.</span><br><span class=\"line\">service Greeter &#123;</span><br><span class=\"line\">  // Sends a greeting</span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>消息体(message)定义。消息体是一个集成的结构，用于把各种参数集成到一个，类似于结构体。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// The request message containing the user&#x27;s name.</span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  string name = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// The response message containing the greetings</span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  string message = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"server文件\"><a href=\"#server文件\" class=\"headerlink\" title=\"server文件\"></a>server文件</h4><ul>\n<li>头部声明。注意需要导入grpc包，同时需要把基于proto文件生成的包即<code>go_package</code>导入。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Package main implements a server for Greeter service.</span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;context&quot;</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">\tpb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li>端口<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const (</span><br><span class=\"line\">\tport = &quot;:50051&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li>获取pb包里生成的server，并编写接口业务逻辑<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// server is used to implement helloworld.GreeterServer.</span><br><span class=\"line\">type server struct &#123;</span><br><span class=\"line\">\tpb.UnimplementedGreeterServer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// SayHello implements helloworld.GreeterServer</span><br><span class=\"line\">func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) &#123;</span><br><span class=\"line\">\tlog.Printf(&quot;Received: %v&quot;, in.GetName())</span><br><span class=\"line\">\treturn &amp;pb.HelloReply&#123;Message: &quot;Hello &quot; + in.GetName()&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>main函数，启动服务。使用grpc创建server，并注册到pb包中。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tlis, err := net.Listen(&quot;tcp&quot;, port)</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;failed to listen: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts := grpc.NewServer()</span><br><span class=\"line\">\tpb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class=\"line\">\tif err := s.Serve(lis); err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;failed to serve: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"client文件\"><a href=\"#client文件\" class=\"headerlink\" title=\"client文件\"></a>client文件</h4><ul>\n<li>与server一样，导入相关包<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Package main implements a client for Greeter service.</span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;context&quot;</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;os&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">\tpb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\">const (</span><br><span class=\"line\">\taddress     = &quot;localhost:50051&quot;</span><br><span class=\"line\">\tdefaultName = &quot;world&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n使用<code>pb.NewGreeterClient</code>创建client，并直接调用pb创建的service内接口<code>SayHello</code>.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\t// Set up a connection to the server.</span><br><span class=\"line\">\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;did not connect: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer conn.Close()</span><br><span class=\"line\">\tc := pb.NewGreeterClient(conn)</span><br><span class=\"line\">\t// Contact the server and print out its response.</span><br><span class=\"line\">\tname := defaultName</span><br><span class=\"line\">\tif len(os.Args) &gt; 1 &#123;</span><br><span class=\"line\">\t\tname = os.Args[1]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">\tdefer cancel()</span><br><span class=\"line\">\tr, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;could not greet: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Printf(&quot;Greeting: %s&quot;, r.GetMessage())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用grpc犹如餐厅里的厨房窗口(service)，服务员将菜单小票(request message)递进窗口，厨房做好菜后将菜(reply message)再送出来。   </p>\n<p>我们只需要再一开始将厨房窗口设计好，一个完整的做菜流就定义完成。后续只需要增加厨师和菜色，以满足不同的菜的需求即可。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://developers.google.com/protocol-buffers/docs/proto3\">proto3 语法</a><br><a href=\"https://developers.google.com/protocol-buffers/docs/gotutorial\">基于go的教程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"获取源码\"><a href=\"#获取源码\" class=\"headerlink\" title=\"获取源码\"></a>获取源码</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://github.com/grpc/grpc-go.git</span><br></pre></td></tr></table></figure>\n<p>源码在 <code>grpc-go/examples/helloworld</code>文件夹</p>\n<h3 id=\"源码解析\"><a href=\"#源码解析\" class=\"headerlink\" title=\"源码解析\"></a>源码解析</h3><h4 id=\"proto文件\"><a href=\"#proto文件\" class=\"headerlink\" title=\"proto文件\"></a>proto文件</h4><ul>\n<li>声明使用proto3。这是最新版的格式，具体可以了解<a href=\"https://developers.google.com/protocol-buffers/docs/proto3\">proto3</a>与<a href=\"https://developers.google.com/protocol-buffers/docs/proto\">proto2</a>的区别。一般直接使用proto3即可。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">syntax = &quot;proto3&quot;;</span><br></pre></td></tr></table></figure></li>\n<li>声明包路径，指向了使用proto文件生成的包名。默认与被应用的go包一致，也可以使用该声明自主定义。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">option go_package = &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;;</span><br></pre></td></tr></table></figure></li>\n<li>声明生成java代码时的一些规则，在此处应该没什么用。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">option java_multiple_files = true;</span><br><span class=\"line\">option java_package = &quot;io.grpc.examples.helloworld&quot;;</span><br><span class=\"line\">option java_outer_classname = &quot;HelloWorldProto&quot;;</span><br></pre></td></tr></table></figure></li>\n<li>声明应用的包名。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package helloworld;</span><br></pre></td></tr></table></figure></li>\n<li>声明服务调用接口。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// The greeting service definition.</span><br><span class=\"line\">service Greeter &#123;</span><br><span class=\"line\">  // Sends a greeting</span><br><span class=\"line\">  rpc SayHello (HelloRequest) returns (HelloReply) &#123;&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>消息体(message)定义。消息体是一个集成的结构，用于把各种参数集成到一个，类似于结构体。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// The request message containing the user&#x27;s name.</span><br><span class=\"line\">message HelloRequest &#123;</span><br><span class=\"line\">  string name = 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// The response message containing the greetings</span><br><span class=\"line\">message HelloReply &#123;</span><br><span class=\"line\">  string message = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"server文件\"><a href=\"#server文件\" class=\"headerlink\" title=\"server文件\"></a>server文件</h4><ul>\n<li>头部声明。注意需要导入grpc包，同时需要把基于proto文件生成的包即<code>go_package</code>导入。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Package main implements a server for Greeter service.</span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;context&quot;</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;net&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">\tpb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li>端口<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const (</span><br><span class=\"line\">\tport = &quot;:50051&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></li>\n<li>获取pb包里生成的server，并编写接口业务逻辑<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// server is used to implement helloworld.GreeterServer.</span><br><span class=\"line\">type server struct &#123;</span><br><span class=\"line\">\tpb.UnimplementedGreeterServer</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// SayHello implements helloworld.GreeterServer</span><br><span class=\"line\">func (s *server) SayHello(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) &#123;</span><br><span class=\"line\">\tlog.Printf(&quot;Received: %v&quot;, in.GetName())</span><br><span class=\"line\">\treturn &amp;pb.HelloReply&#123;Message: &quot;Hello &quot; + in.GetName()&#125;, nil</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>main函数，启动服务。使用grpc创建server，并注册到pb包中。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\tlis, err := net.Listen(&quot;tcp&quot;, port)</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;failed to listen: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\ts := grpc.NewServer()</span><br><span class=\"line\">\tpb.RegisterGreeterServer(s, &amp;server&#123;&#125;)</span><br><span class=\"line\">\tif err := s.Serve(lis); err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;failed to serve: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"client文件\"><a href=\"#client文件\" class=\"headerlink\" title=\"client文件\"></a>client文件</h4><ul>\n<li>与server一样，导入相关包<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Package main implements a client for Greeter service.</span><br><span class=\"line\">package main</span><br><span class=\"line\">import (</span><br><span class=\"line\">\t&quot;context&quot;</span><br><span class=\"line\">\t&quot;log&quot;</span><br><span class=\"line\">\t&quot;os&quot;</span><br><span class=\"line\">\t&quot;time&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">\t&quot;google.golang.org/grpc&quot;</span><br><span class=\"line\">\tpb &quot;google.golang.org/grpc/examples/helloworld/helloworld&quot;</span><br><span class=\"line\">)</span><br><span class=\"line\">const (</span><br><span class=\"line\">\taddress     = &quot;localhost:50051&quot;</span><br><span class=\"line\">\tdefaultName = &quot;world&quot;</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n使用<code>pb.NewGreeterClient</code>创建client，并直接调用pb创建的service内接口<code>SayHello</code>.<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func main() &#123;</span><br><span class=\"line\">\t// Set up a connection to the server.</span><br><span class=\"line\">\tconn, err := grpc.Dial(address, grpc.WithInsecure(), grpc.WithBlock())</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;did not connect: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tdefer conn.Close()</span><br><span class=\"line\">\tc := pb.NewGreeterClient(conn)</span><br><span class=\"line\">\t// Contact the server and print out its response.</span><br><span class=\"line\">\tname := defaultName</span><br><span class=\"line\">\tif len(os.Args) &gt; 1 &#123;</span><br><span class=\"line\">\t\tname = os.Args[1]</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tctx, cancel := context.WithTimeout(context.Background(), time.Second)</span><br><span class=\"line\">\tdefer cancel()</span><br><span class=\"line\">\tr, err := c.SayHello(ctx, &amp;pb.HelloRequest&#123;Name: name&#125;)</span><br><span class=\"line\">\tif err != nil &#123;</span><br><span class=\"line\">\t\tlog.Fatalf(&quot;could not greet: %v&quot;, err)</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tlog.Printf(&quot;Greeting: %s&quot;, r.GetMessage())</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>使用grpc犹如餐厅里的厨房窗口(service)，服务员将菜单小票(request message)递进窗口，厨房做好菜后将菜(reply message)再送出来。   </p>\n<p>我们只需要再一开始将厨房窗口设计好，一个完整的做菜流就定义完成。后续只需要增加厨师和菜色，以满足不同的菜的需求即可。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://developers.google.com/protocol-buffers/docs/proto3\">proto3 语法</a><br><a href=\"https://developers.google.com/protocol-buffers/docs/gotutorial\">基于go的教程</a></p>\n"},{"layout":"post","title":"Graphql and Restful API","author":"Edison","date":"2021-03-20T16:00:00.000Z","_content":"\n### GraphQL 与 RESTful\n#### GraphQL\n- 数据一次获取  \n数据返回被封装在一个入口，一次请求\n- 所见及所得  \n想要获取什么数据，就定义相应的查询字段。\n\n#### RESTful\n- 明确资源间的关系\n- HTTP verb定义对资源的行为\n\n### API设计\n\n对于前后端分离架构，API成为了前后端间数据通信协议。当一个产品经理列出需求之后之后，前后端工程师设计领域模型，抽象需求与原型成为代码可以描述的对象。在实践中发现，大多数前端工程师会对```页面```进行建模，而后端工程师则对```资源```进行建模。于是会发现，前后端工程师对模型的定义会有些差别，即使我们在设计阶段有领域模型设计，我们也无法保障前端工程师能按照领域模型设计组件，这是由页面和UI决定的。\n\n尽管API作为数据通信的协议，往往是由前后端工程师共同约定的，实际情况是，API是前端获取数据的入口，更多的时候更像是后端交付给前端的“产品”。这个时候，前端对获取数据的逻辑设计产生的需求，会转换成对API设计的复杂要求。\n\n当我们使用RESTful style API的时候，我们会需要前端工程师对领域模型也有充分的理解，这在一些团队是不一定可以做得到的。尤其是当页面组件设计需要多个资源的时候，前端工程师不得不\n\n显然，RESTful API 更偏向于后端设计的API，GraphQL则对前端更友好。\n\n如果API作为交付给前端的```产品```，则我们应该让前端工程师调用更方便更易理解，RESTful这类与后端模型相耦的风格则显现不足。通常，RESTful API无法完全由模型推导API，后端还是要修饰API以返回前端友好的数据结构。GraphQL风格则对后端提出更高的要求，包括接口性能和数据拼接等。\n\n### 新的解决方案 BFF\nBFF是Backend for Frontend。从实践前后端分离之后，前端工程师更关注单页面应用的设计，而后端工程师则持续深研领域建模。当后端工程师基于模型实现的API不足以满足前端工程师的复杂访问逻辑的时候，我们需要有一个专门为前端应用设计的后端服务，来提供API服务。\n\n#### 优点\n\n**加快前端应用开发**  \n\n前后端分离，要求先完成API设计，再进行前后端开发，可以保证联调前大家都能完成各自大部分代码实现。而现实中，由于花费大量精力定义API文档并不是一种敏捷的模式，所以很难在开发前完成API文档统一设计。同时领域模型会在开发中不断与产品经理讨论而调整，后端工程师在迭代中会不断调整接口返回格式，前端工程师并不愿意在接口不work之前就进入自己的开发（除了一些页面模版）。\n\n因此，BFF可以满足前端自主定义API数据格式，并完成页面设计与开发。待后端接口work之后，再在BFF层对接后端接口汇集数据，实现联调。\n\nNodeJS的出现，更加方便前端工程师实现BFF层。有趣的事，过往只有后端工程师，后来独立出前端工程师只负责前端模块，而现在前端工程师又回到了需要做后端开发的时代。\n\n#### 缺点\n\n**新增一层的复杂度**\n\n- 错误返回无法很好处理\n由于很多权限设计汇聚在后端业务逻辑中，当BFF层调用多个接口汇集数据之后在传回前端，此时的错误回传前端会变得复杂\n\n- 错误追踪复杂\n当出现页面错误的时候，我们需要多查看一层数据层的调用情况\n\n### 没有银弹\n\n我们在本篇没有关注性能等优势，比如，在HTTP1.1Graph QL性能有优势，而HTTP2支持下RESTful风格多个API并不会有加载问题，当然还有如传输无效数据浪费带宽。我们认为，这些都是可以有应对的方法。\n\n本篇更强调的是前后端协作的问题，以及使用哪一种风格更有利于加快迭代。后续会分享，前后端工程师如何拆解领域模型，并保持在same page。事实上，当前后端对业务理解趋于一致，API的设计也会更易于取得平衡。\n","source":"_posts/graphql-and-restful.md","raw":"---\nlayout: post\ntitle: Graphql and Restful API \nauthor: Edison\ndate: 2021-03-21\n---\n\n### GraphQL 与 RESTful\n#### GraphQL\n- 数据一次获取  \n数据返回被封装在一个入口，一次请求\n- 所见及所得  \n想要获取什么数据，就定义相应的查询字段。\n\n#### RESTful\n- 明确资源间的关系\n- HTTP verb定义对资源的行为\n\n### API设计\n\n对于前后端分离架构，API成为了前后端间数据通信协议。当一个产品经理列出需求之后之后，前后端工程师设计领域模型，抽象需求与原型成为代码可以描述的对象。在实践中发现，大多数前端工程师会对```页面```进行建模，而后端工程师则对```资源```进行建模。于是会发现，前后端工程师对模型的定义会有些差别，即使我们在设计阶段有领域模型设计，我们也无法保障前端工程师能按照领域模型设计组件，这是由页面和UI决定的。\n\n尽管API作为数据通信的协议，往往是由前后端工程师共同约定的，实际情况是，API是前端获取数据的入口，更多的时候更像是后端交付给前端的“产品”。这个时候，前端对获取数据的逻辑设计产生的需求，会转换成对API设计的复杂要求。\n\n当我们使用RESTful style API的时候，我们会需要前端工程师对领域模型也有充分的理解，这在一些团队是不一定可以做得到的。尤其是当页面组件设计需要多个资源的时候，前端工程师不得不\n\n显然，RESTful API 更偏向于后端设计的API，GraphQL则对前端更友好。\n\n如果API作为交付给前端的```产品```，则我们应该让前端工程师调用更方便更易理解，RESTful这类与后端模型相耦的风格则显现不足。通常，RESTful API无法完全由模型推导API，后端还是要修饰API以返回前端友好的数据结构。GraphQL风格则对后端提出更高的要求，包括接口性能和数据拼接等。\n\n### 新的解决方案 BFF\nBFF是Backend for Frontend。从实践前后端分离之后，前端工程师更关注单页面应用的设计，而后端工程师则持续深研领域建模。当后端工程师基于模型实现的API不足以满足前端工程师的复杂访问逻辑的时候，我们需要有一个专门为前端应用设计的后端服务，来提供API服务。\n\n#### 优点\n\n**加快前端应用开发**  \n\n前后端分离，要求先完成API设计，再进行前后端开发，可以保证联调前大家都能完成各自大部分代码实现。而现实中，由于花费大量精力定义API文档并不是一种敏捷的模式，所以很难在开发前完成API文档统一设计。同时领域模型会在开发中不断与产品经理讨论而调整，后端工程师在迭代中会不断调整接口返回格式，前端工程师并不愿意在接口不work之前就进入自己的开发（除了一些页面模版）。\n\n因此，BFF可以满足前端自主定义API数据格式，并完成页面设计与开发。待后端接口work之后，再在BFF层对接后端接口汇集数据，实现联调。\n\nNodeJS的出现，更加方便前端工程师实现BFF层。有趣的事，过往只有后端工程师，后来独立出前端工程师只负责前端模块，而现在前端工程师又回到了需要做后端开发的时代。\n\n#### 缺点\n\n**新增一层的复杂度**\n\n- 错误返回无法很好处理\n由于很多权限设计汇聚在后端业务逻辑中，当BFF层调用多个接口汇集数据之后在传回前端，此时的错误回传前端会变得复杂\n\n- 错误追踪复杂\n当出现页面错误的时候，我们需要多查看一层数据层的调用情况\n\n### 没有银弹\n\n我们在本篇没有关注性能等优势，比如，在HTTP1.1Graph QL性能有优势，而HTTP2支持下RESTful风格多个API并不会有加载问题，当然还有如传输无效数据浪费带宽。我们认为，这些都是可以有应对的方法。\n\n本篇更强调的是前后端协作的问题，以及使用哪一种风格更有利于加快迭代。后续会分享，前后端工程师如何拆解领域模型，并保持在same page。事实上，当前后端对业务理解趋于一致，API的设计也会更易于取得平衡。\n","slug":"graphql-and-restful","published":1,"updated":"2022-01-30T15:42:01.281Z","_id":"ckz1fqx5f0000vkht77e72xti","comments":1,"photos":[],"link":"","content":"<h3 id=\"GraphQL-与-RESTful\"><a href=\"#GraphQL-与-RESTful\" class=\"headerlink\" title=\"GraphQL 与 RESTful\"></a>GraphQL 与 RESTful</h3><h4 id=\"GraphQL\"><a href=\"#GraphQL\" class=\"headerlink\" title=\"GraphQL\"></a>GraphQL</h4><ul>\n<li>数据一次获取<br>数据返回被封装在一个入口，一次请求</li>\n<li>所见及所得<br>想要获取什么数据，就定义相应的查询字段。</li>\n</ul>\n<h4 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h4><ul>\n<li>明确资源间的关系</li>\n<li>HTTP verb定义对资源的行为</li>\n</ul>\n<h3 id=\"API设计\"><a href=\"#API设计\" class=\"headerlink\" title=\"API设计\"></a>API设计</h3><p>对于前后端分离架构，API成为了前后端间数据通信协议。当一个产品经理列出需求之后之后，前后端工程师设计领域模型，抽象需求与原型成为代码可以描述的对象。在实践中发现，大多数前端工程师会对<code>页面</code>进行建模，而后端工程师则对<code>资源</code>进行建模。于是会发现，前后端工程师对模型的定义会有些差别，即使我们在设计阶段有领域模型设计，我们也无法保障前端工程师能按照领域模型设计组件，这是由页面和UI决定的。</p>\n<p>尽管API作为数据通信的协议，往往是由前后端工程师共同约定的，实际情况是，API是前端获取数据的入口，更多的时候更像是后端交付给前端的“产品”。这个时候，前端对获取数据的逻辑设计产生的需求，会转换成对API设计的复杂要求。</p>\n<p>当我们使用RESTful style API的时候，我们会需要前端工程师对领域模型也有充分的理解，这在一些团队是不一定可以做得到的。尤其是当页面组件设计需要多个资源的时候，前端工程师不得不</p>\n<p>显然，RESTful API 更偏向于后端设计的API，GraphQL则对前端更友好。</p>\n<p>如果API作为交付给前端的<code>产品</code>，则我们应该让前端工程师调用更方便更易理解，RESTful这类与后端模型相耦的风格则显现不足。通常，RESTful API无法完全由模型推导API，后端还是要修饰API以返回前端友好的数据结构。GraphQL风格则对后端提出更高的要求，包括接口性能和数据拼接等。</p>\n<h3 id=\"新的解决方案-BFF\"><a href=\"#新的解决方案-BFF\" class=\"headerlink\" title=\"新的解决方案 BFF\"></a>新的解决方案 BFF</h3><p>BFF是Backend for Frontend。从实践前后端分离之后，前端工程师更关注单页面应用的设计，而后端工程师则持续深研领域建模。当后端工程师基于模型实现的API不足以满足前端工程师的复杂访问逻辑的时候，我们需要有一个专门为前端应用设计的后端服务，来提供API服务。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><strong>加快前端应用开发</strong>  </p>\n<p>前后端分离，要求先完成API设计，再进行前后端开发，可以保证联调前大家都能完成各自大部分代码实现。而现实中，由于花费大量精力定义API文档并不是一种敏捷的模式，所以很难在开发前完成API文档统一设计。同时领域模型会在开发中不断与产品经理讨论而调整，后端工程师在迭代中会不断调整接口返回格式，前端工程师并不愿意在接口不work之前就进入自己的开发（除了一些页面模版）。</p>\n<p>因此，BFF可以满足前端自主定义API数据格式，并完成页面设计与开发。待后端接口work之后，再在BFF层对接后端接口汇集数据，实现联调。</p>\n<p>NodeJS的出现，更加方便前端工程师实现BFF层。有趣的事，过往只有后端工程师，后来独立出前端工程师只负责前端模块，而现在前端工程师又回到了需要做后端开发的时代。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p><strong>新增一层的复杂度</strong></p>\n<ul>\n<li><p>错误返回无法很好处理<br>由于很多权限设计汇聚在后端业务逻辑中，当BFF层调用多个接口汇集数据之后在传回前端，此时的错误回传前端会变得复杂</p>\n</li>\n<li><p>错误追踪复杂<br>当出现页面错误的时候，我们需要多查看一层数据层的调用情况</p>\n</li>\n</ul>\n<h3 id=\"没有银弹\"><a href=\"#没有银弹\" class=\"headerlink\" title=\"没有银弹\"></a>没有银弹</h3><p>我们在本篇没有关注性能等优势，比如，在HTTP1.1Graph QL性能有优势，而HTTP2支持下RESTful风格多个API并不会有加载问题，当然还有如传输无效数据浪费带宽。我们认为，这些都是可以有应对的方法。</p>\n<p>本篇更强调的是前后端协作的问题，以及使用哪一种风格更有利于加快迭代。后续会分享，前后端工程师如何拆解领域模型，并保持在same page。事实上，当前后端对业务理解趋于一致，API的设计也会更易于取得平衡。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"GraphQL-与-RESTful\"><a href=\"#GraphQL-与-RESTful\" class=\"headerlink\" title=\"GraphQL 与 RESTful\"></a>GraphQL 与 RESTful</h3><h4 id=\"GraphQL\"><a href=\"#GraphQL\" class=\"headerlink\" title=\"GraphQL\"></a>GraphQL</h4><ul>\n<li>数据一次获取<br>数据返回被封装在一个入口，一次请求</li>\n<li>所见及所得<br>想要获取什么数据，就定义相应的查询字段。</li>\n</ul>\n<h4 id=\"RESTful\"><a href=\"#RESTful\" class=\"headerlink\" title=\"RESTful\"></a>RESTful</h4><ul>\n<li>明确资源间的关系</li>\n<li>HTTP verb定义对资源的行为</li>\n</ul>\n<h3 id=\"API设计\"><a href=\"#API设计\" class=\"headerlink\" title=\"API设计\"></a>API设计</h3><p>对于前后端分离架构，API成为了前后端间数据通信协议。当一个产品经理列出需求之后之后，前后端工程师设计领域模型，抽象需求与原型成为代码可以描述的对象。在实践中发现，大多数前端工程师会对<code>页面</code>进行建模，而后端工程师则对<code>资源</code>进行建模。于是会发现，前后端工程师对模型的定义会有些差别，即使我们在设计阶段有领域模型设计，我们也无法保障前端工程师能按照领域模型设计组件，这是由页面和UI决定的。</p>\n<p>尽管API作为数据通信的协议，往往是由前后端工程师共同约定的，实际情况是，API是前端获取数据的入口，更多的时候更像是后端交付给前端的“产品”。这个时候，前端对获取数据的逻辑设计产生的需求，会转换成对API设计的复杂要求。</p>\n<p>当我们使用RESTful style API的时候，我们会需要前端工程师对领域模型也有充分的理解，这在一些团队是不一定可以做得到的。尤其是当页面组件设计需要多个资源的时候，前端工程师不得不</p>\n<p>显然，RESTful API 更偏向于后端设计的API，GraphQL则对前端更友好。</p>\n<p>如果API作为交付给前端的<code>产品</code>，则我们应该让前端工程师调用更方便更易理解，RESTful这类与后端模型相耦的风格则显现不足。通常，RESTful API无法完全由模型推导API，后端还是要修饰API以返回前端友好的数据结构。GraphQL风格则对后端提出更高的要求，包括接口性能和数据拼接等。</p>\n<h3 id=\"新的解决方案-BFF\"><a href=\"#新的解决方案-BFF\" class=\"headerlink\" title=\"新的解决方案 BFF\"></a>新的解决方案 BFF</h3><p>BFF是Backend for Frontend。从实践前后端分离之后，前端工程师更关注单页面应用的设计，而后端工程师则持续深研领域建模。当后端工程师基于模型实现的API不足以满足前端工程师的复杂访问逻辑的时候，我们需要有一个专门为前端应用设计的后端服务，来提供API服务。</p>\n<h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h4><p><strong>加快前端应用开发</strong>  </p>\n<p>前后端分离，要求先完成API设计，再进行前后端开发，可以保证联调前大家都能完成各自大部分代码实现。而现实中，由于花费大量精力定义API文档并不是一种敏捷的模式，所以很难在开发前完成API文档统一设计。同时领域模型会在开发中不断与产品经理讨论而调整，后端工程师在迭代中会不断调整接口返回格式，前端工程师并不愿意在接口不work之前就进入自己的开发（除了一些页面模版）。</p>\n<p>因此，BFF可以满足前端自主定义API数据格式，并完成页面设计与开发。待后端接口work之后，再在BFF层对接后端接口汇集数据，实现联调。</p>\n<p>NodeJS的出现，更加方便前端工程师实现BFF层。有趣的事，过往只有后端工程师，后来独立出前端工程师只负责前端模块，而现在前端工程师又回到了需要做后端开发的时代。</p>\n<h4 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h4><p><strong>新增一层的复杂度</strong></p>\n<ul>\n<li><p>错误返回无法很好处理<br>由于很多权限设计汇聚在后端业务逻辑中，当BFF层调用多个接口汇集数据之后在传回前端，此时的错误回传前端会变得复杂</p>\n</li>\n<li><p>错误追踪复杂<br>当出现页面错误的时候，我们需要多查看一层数据层的调用情况</p>\n</li>\n</ul>\n<h3 id=\"没有银弹\"><a href=\"#没有银弹\" class=\"headerlink\" title=\"没有银弹\"></a>没有银弹</h3><p>我们在本篇没有关注性能等优势，比如，在HTTP1.1Graph QL性能有优势，而HTTP2支持下RESTful风格多个API并不会有加载问题，当然还有如传输无效数据浪费带宽。我们认为，这些都是可以有应对的方法。</p>\n<p>本篇更强调的是前后端协作的问题，以及使用哪一种风格更有利于加快迭代。后续会分享，前后端工程师如何拆解领域模型，并保持在same page。事实上，当前后端对业务理解趋于一致，API的设计也会更易于取得平衡。</p>\n"},{"layout":"post","title":"敏捷软件开发：设计","date":"2021-05-08T16:00:00.000Z","_content":"\n本篇为阅读《敏捷软件开发：原则，模式与实践》后的读后感。主要阅读的是第二部分：敏捷设计。\n这本书的第一部分，关于敏捷开发中的测试驱动开发与重构，可以阅读其他专门的书籍。我阅读的是《重构，改善既有代码设计》。\n本书第三部分的案例，可自由选择是否阅读以加深理解。我自己更多的是结合自己遇到的问题，从书中描述找到问题的解决方案。\n\n### 什么是敏捷设计\n\n#### 软件越来越难维护\n\n软件在第一版本发布的时候，是软件设计最干净清晰的时候。随着复杂的需求与软件持续迭代，软件代码往往会在原来的设计上做各种hack以满足新的需求。\n\n这系列的破坏设计的操作，会在后续的需求增加的过程中逐渐变得难以维护，而后的需求迭代速率将越来越慢。\n\n#### 使用敏捷设计\n\n所以我们推荐使用```TDD + 重构```的形式，来持续调整代码设计，每一次做微小的重构，尽管对单次迭代耗时长，但是把一个大的重构的时间分散在每次迭代中，将有利于代码持续维护。\n\n此外，在后续的内容中，将使用经典的软件设计原则，来从一开始就让软件设计趋于敏捷，或者说，让软件设计能更好的**拥抱变化**。\n\n#### 尽可能保持代码干净\n\n由于在实际开发项目中，文档是软件开发的附属物，代码才是软件开发的本身。如果代码设计的好，将有效的加快开发过程，同时方便新任开发者快速接手，阅读，理解与进一步设计。\n\n### 软件设计原则\n\n软件设计原则篇章，重点讲述了经典的六大设计原则中的其中五项```SOLID```。\n\n#### 单一职责原则\n\n> 就一个类而言，应该只有一个引起他变化的原因\n\n将一个类中复杂的耦合分离开来，是该原则的实践。这要求，每一次做类设计，都要避免将一堆复杂的逻辑放在一个类中，否则这个类就失去了单一职责的原则。\n\n而在具体情况中，对于几乎不会发生变化的模块，我们不需要为了解耦而解耦，而是将他们放在一个类即可。\n\n单一职责原则，简单也复杂。难点在于，我们很难在一开始就知道，哪些职责（引起变化的原因 ）是需要解耦的。所以，我们仍然需要通过持续重构来不断优化类设计，使其符合单一职责原则。\n\n#### 开发-封闭原则\n\n> 对扩展开放，对更改封闭\n\n对扩展开放，是指，对一个类新增能力是允许的，而且可以非常容易做到的。对更改封闭，是指，对一个类做能力新增的时候，只需要添加代码，而不需要对旧的代码做修改。\n\n开放-封闭原则是一种非常理想的原则。我们很难在实际业务中，完全不修改旧代码的逻辑，而新增新的代码，除非代码架构从一开始就是与业务不耦合的架构。我们新增业务逻辑的时候，是完全有可能修改旧的逻辑使其具备支持新的业务逻辑的能力。甚至，修改旧的业务逻辑本身就是这次新增的一部分。而我们在编写原来的业务逻辑的时候，并不一定能考虑到其不能支持新增的需求。\n\n所以，事实上，要实现该原则，要做的就是，重构。我们需要先将旧的代码逻辑重构成符合开放-封闭原则的代码，并跑通测试。然后，在对更改封闭的前提下编写类扩展代码。\n\n书中提到预测，我认为，预测是一种潜意识的行为，当对业务熟悉，对团队熟悉，对设计方法熟悉，自然会在设计过程中做出更准群的预测。可以说，有办法做到预测，且确实准确预测，则执行该原则会变得简单。而即使没有预测，通过重构，我们依然可以解决问题。\n\n#### 里氏替换\n\n> 子类型必须能够替换掉基类型\n\n里氏替换的应用场景是这样子的：假设我们定一个一个base类和一个sub类，其中，base类定义了一个method，sub类复写了该method。同时我们定义了一个function用于接受base类的输入，并执行base类的method。这个时候，我们要求子类可以作为function的输入，即是说，子类复写的method必须是与base类的method在输入和输出上是一致的，仅内部计算逻辑不一致。\n\n当我们在sub类复写了method，造成sub类不能替换base类的时候，我们可能会在function对输入做处理，让其可以接受base类和sub类。我们更可能为sub类专门写一个测试验证其能通过。其实这两者都违反了前述的开放-封闭原则。即我们对function的修改没有对sub类封闭。\n\n另外需要说的是：\n\n- 里氏原则是面向行为的。一个行为限制了某种输入，才有原则的应用场景。\n- 基于契约设计。显然，我们预先约定了base类和sub类符合里氏原则，才有办法开发接受base类的符合原则的function\n- 继承本身是复杂的设计，golang甚至舍弃了继承，但我们在这里不谈关于继承的问题。当我们在使用继承的时候，要时刻注意是否符合里氏替换原则。\n\n#### 接口隔离原则\n\n> 不应该让client依赖于使用不到的方法\n\n一个client需要来源于其他类的某一个特殊的功能，这个时候，如果使用继承，则会将另一个类的所有接口都携带进来，这个时候对client本身是不利的。\n\n解决方案：\n\n- 可以使用适配器（Adapter）来实现隔离，不过这会造成性能问题\n- 使用多重继承\n\n#### 依赖倒置原则\n\n> 高层模块不应该依赖于低层模块，两者应该都依赖于抽象\n> 抽象不应该依赖于细节，细节应该依赖于抽象\n\n一个经典的例子是，我们在使用框架进行web服务开发的时候，通常只需要编写处理request与返回response的业务逻辑，而request与response的具体执行，都由框架直接执行。从分层的角度，框架是底层，我们实现的web业务是高层。显然，web服务没有调用底层的http处理，而是底层的处理调用了高层的web业务。\n\n高层模块通常都会依赖底层模块。依赖倒置的目的是为了应对底层模块经常变动的情况。基于开发-封闭原则，如果底层模块变动造成了依赖他的高层模块需要调整，则应该拒绝高层对底层的依赖，而是让两者依赖于不变动的抽象。\n\n至于细节依赖抽象，则比较好理解。通常，细节是比较容易因为需求增加或调整而发生变更的，抽象则不然。所以细节需要依赖抽象，而抽象不应该依赖细节，即不应该因为细节变更而造成抽象的变更。\n\n### 总结\n\n敏捷设计的基础是，在测试驱动开发的前提下，持续重构。同时使用软件设计基本原则，保障代码不至于陷入“坏味道”而难以重构。\n","source":"_posts/Agile-Design.md","raw":"---\nlayout: post\ntitle: 敏捷软件开发：设计\ndate: 2021-05-09\ntags:\n  - agile\n---\n\n本篇为阅读《敏捷软件开发：原则，模式与实践》后的读后感。主要阅读的是第二部分：敏捷设计。\n这本书的第一部分，关于敏捷开发中的测试驱动开发与重构，可以阅读其他专门的书籍。我阅读的是《重构，改善既有代码设计》。\n本书第三部分的案例，可自由选择是否阅读以加深理解。我自己更多的是结合自己遇到的问题，从书中描述找到问题的解决方案。\n\n### 什么是敏捷设计\n\n#### 软件越来越难维护\n\n软件在第一版本发布的时候，是软件设计最干净清晰的时候。随着复杂的需求与软件持续迭代，软件代码往往会在原来的设计上做各种hack以满足新的需求。\n\n这系列的破坏设计的操作，会在后续的需求增加的过程中逐渐变得难以维护，而后的需求迭代速率将越来越慢。\n\n#### 使用敏捷设计\n\n所以我们推荐使用```TDD + 重构```的形式，来持续调整代码设计，每一次做微小的重构，尽管对单次迭代耗时长，但是把一个大的重构的时间分散在每次迭代中，将有利于代码持续维护。\n\n此外，在后续的内容中，将使用经典的软件设计原则，来从一开始就让软件设计趋于敏捷，或者说，让软件设计能更好的**拥抱变化**。\n\n#### 尽可能保持代码干净\n\n由于在实际开发项目中，文档是软件开发的附属物，代码才是软件开发的本身。如果代码设计的好，将有效的加快开发过程，同时方便新任开发者快速接手，阅读，理解与进一步设计。\n\n### 软件设计原则\n\n软件设计原则篇章，重点讲述了经典的六大设计原则中的其中五项```SOLID```。\n\n#### 单一职责原则\n\n> 就一个类而言，应该只有一个引起他变化的原因\n\n将一个类中复杂的耦合分离开来，是该原则的实践。这要求，每一次做类设计，都要避免将一堆复杂的逻辑放在一个类中，否则这个类就失去了单一职责的原则。\n\n而在具体情况中，对于几乎不会发生变化的模块，我们不需要为了解耦而解耦，而是将他们放在一个类即可。\n\n单一职责原则，简单也复杂。难点在于，我们很难在一开始就知道，哪些职责（引起变化的原因 ）是需要解耦的。所以，我们仍然需要通过持续重构来不断优化类设计，使其符合单一职责原则。\n\n#### 开发-封闭原则\n\n> 对扩展开放，对更改封闭\n\n对扩展开放，是指，对一个类新增能力是允许的，而且可以非常容易做到的。对更改封闭，是指，对一个类做能力新增的时候，只需要添加代码，而不需要对旧的代码做修改。\n\n开放-封闭原则是一种非常理想的原则。我们很难在实际业务中，完全不修改旧代码的逻辑，而新增新的代码，除非代码架构从一开始就是与业务不耦合的架构。我们新增业务逻辑的时候，是完全有可能修改旧的逻辑使其具备支持新的业务逻辑的能力。甚至，修改旧的业务逻辑本身就是这次新增的一部分。而我们在编写原来的业务逻辑的时候，并不一定能考虑到其不能支持新增的需求。\n\n所以，事实上，要实现该原则，要做的就是，重构。我们需要先将旧的代码逻辑重构成符合开放-封闭原则的代码，并跑通测试。然后，在对更改封闭的前提下编写类扩展代码。\n\n书中提到预测，我认为，预测是一种潜意识的行为，当对业务熟悉，对团队熟悉，对设计方法熟悉，自然会在设计过程中做出更准群的预测。可以说，有办法做到预测，且确实准确预测，则执行该原则会变得简单。而即使没有预测，通过重构，我们依然可以解决问题。\n\n#### 里氏替换\n\n> 子类型必须能够替换掉基类型\n\n里氏替换的应用场景是这样子的：假设我们定一个一个base类和一个sub类，其中，base类定义了一个method，sub类复写了该method。同时我们定义了一个function用于接受base类的输入，并执行base类的method。这个时候，我们要求子类可以作为function的输入，即是说，子类复写的method必须是与base类的method在输入和输出上是一致的，仅内部计算逻辑不一致。\n\n当我们在sub类复写了method，造成sub类不能替换base类的时候，我们可能会在function对输入做处理，让其可以接受base类和sub类。我们更可能为sub类专门写一个测试验证其能通过。其实这两者都违反了前述的开放-封闭原则。即我们对function的修改没有对sub类封闭。\n\n另外需要说的是：\n\n- 里氏原则是面向行为的。一个行为限制了某种输入，才有原则的应用场景。\n- 基于契约设计。显然，我们预先约定了base类和sub类符合里氏原则，才有办法开发接受base类的符合原则的function\n- 继承本身是复杂的设计，golang甚至舍弃了继承，但我们在这里不谈关于继承的问题。当我们在使用继承的时候，要时刻注意是否符合里氏替换原则。\n\n#### 接口隔离原则\n\n> 不应该让client依赖于使用不到的方法\n\n一个client需要来源于其他类的某一个特殊的功能，这个时候，如果使用继承，则会将另一个类的所有接口都携带进来，这个时候对client本身是不利的。\n\n解决方案：\n\n- 可以使用适配器（Adapter）来实现隔离，不过这会造成性能问题\n- 使用多重继承\n\n#### 依赖倒置原则\n\n> 高层模块不应该依赖于低层模块，两者应该都依赖于抽象\n> 抽象不应该依赖于细节，细节应该依赖于抽象\n\n一个经典的例子是，我们在使用框架进行web服务开发的时候，通常只需要编写处理request与返回response的业务逻辑，而request与response的具体执行，都由框架直接执行。从分层的角度，框架是底层，我们实现的web业务是高层。显然，web服务没有调用底层的http处理，而是底层的处理调用了高层的web业务。\n\n高层模块通常都会依赖底层模块。依赖倒置的目的是为了应对底层模块经常变动的情况。基于开发-封闭原则，如果底层模块变动造成了依赖他的高层模块需要调整，则应该拒绝高层对底层的依赖，而是让两者依赖于不变动的抽象。\n\n至于细节依赖抽象，则比较好理解。通常，细节是比较容易因为需求增加或调整而发生变更的，抽象则不然。所以细节需要依赖抽象，而抽象不应该依赖细节，即不应该因为细节变更而造成抽象的变更。\n\n### 总结\n\n敏捷设计的基础是，在测试驱动开发的前提下，持续重构。同时使用软件设计基本原则，保障代码不至于陷入“坏味道”而难以重构。\n","slug":"Agile-Design","published":1,"updated":"2022-01-30T15:53:49.529Z","_id":"ckz1fzx8o0001clht2yij2e9i","comments":1,"photos":[],"link":"","content":"<p>本篇为阅读《敏捷软件开发：原则，模式与实践》后的读后感。主要阅读的是第二部分：敏捷设计。<br>这本书的第一部分，关于敏捷开发中的测试驱动开发与重构，可以阅读其他专门的书籍。我阅读的是《重构，改善既有代码设计》。<br>本书第三部分的案例，可自由选择是否阅读以加深理解。我自己更多的是结合自己遇到的问题，从书中描述找到问题的解决方案。</p>\n<h3 id=\"什么是敏捷设计\"><a href=\"#什么是敏捷设计\" class=\"headerlink\" title=\"什么是敏捷设计\"></a>什么是敏捷设计</h3><h4 id=\"软件越来越难维护\"><a href=\"#软件越来越难维护\" class=\"headerlink\" title=\"软件越来越难维护\"></a>软件越来越难维护</h4><p>软件在第一版本发布的时候，是软件设计最干净清晰的时候。随着复杂的需求与软件持续迭代，软件代码往往会在原来的设计上做各种hack以满足新的需求。</p>\n<p>这系列的破坏设计的操作，会在后续的需求增加的过程中逐渐变得难以维护，而后的需求迭代速率将越来越慢。</p>\n<h4 id=\"使用敏捷设计\"><a href=\"#使用敏捷设计\" class=\"headerlink\" title=\"使用敏捷设计\"></a>使用敏捷设计</h4><p>所以我们推荐使用<code>TDD + 重构</code>的形式，来持续调整代码设计，每一次做微小的重构，尽管对单次迭代耗时长，但是把一个大的重构的时间分散在每次迭代中，将有利于代码持续维护。</p>\n<p>此外，在后续的内容中，将使用经典的软件设计原则，来从一开始就让软件设计趋于敏捷，或者说，让软件设计能更好的<strong>拥抱变化</strong>。</p>\n<h4 id=\"尽可能保持代码干净\"><a href=\"#尽可能保持代码干净\" class=\"headerlink\" title=\"尽可能保持代码干净\"></a>尽可能保持代码干净</h4><p>由于在实际开发项目中，文档是软件开发的附属物，代码才是软件开发的本身。如果代码设计的好，将有效的加快开发过程，同时方便新任开发者快速接手，阅读，理解与进一步设计。</p>\n<h3 id=\"软件设计原则\"><a href=\"#软件设计原则\" class=\"headerlink\" title=\"软件设计原则\"></a>软件设计原则</h3><p>软件设计原则篇章，重点讲述了经典的六大设计原则中的其中五项<code>SOLID</code>。</p>\n<h4 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h4><blockquote>\n<p>就一个类而言，应该只有一个引起他变化的原因</p>\n</blockquote>\n<p>将一个类中复杂的耦合分离开来，是该原则的实践。这要求，每一次做类设计，都要避免将一堆复杂的逻辑放在一个类中，否则这个类就失去了单一职责的原则。</p>\n<p>而在具体情况中，对于几乎不会发生变化的模块，我们不需要为了解耦而解耦，而是将他们放在一个类即可。</p>\n<p>单一职责原则，简单也复杂。难点在于，我们很难在一开始就知道，哪些职责（引起变化的原因 ）是需要解耦的。所以，我们仍然需要通过持续重构来不断优化类设计，使其符合单一职责原则。</p>\n<h4 id=\"开发-封闭原则\"><a href=\"#开发-封闭原则\" class=\"headerlink\" title=\"开发-封闭原则\"></a>开发-封闭原则</h4><blockquote>\n<p>对扩展开放，对更改封闭</p>\n</blockquote>\n<p>对扩展开放，是指，对一个类新增能力是允许的，而且可以非常容易做到的。对更改封闭，是指，对一个类做能力新增的时候，只需要添加代码，而不需要对旧的代码做修改。</p>\n<p>开放-封闭原则是一种非常理想的原则。我们很难在实际业务中，完全不修改旧代码的逻辑，而新增新的代码，除非代码架构从一开始就是与业务不耦合的架构。我们新增业务逻辑的时候，是完全有可能修改旧的逻辑使其具备支持新的业务逻辑的能力。甚至，修改旧的业务逻辑本身就是这次新增的一部分。而我们在编写原来的业务逻辑的时候，并不一定能考虑到其不能支持新增的需求。</p>\n<p>所以，事实上，要实现该原则，要做的就是，重构。我们需要先将旧的代码逻辑重构成符合开放-封闭原则的代码，并跑通测试。然后，在对更改封闭的前提下编写类扩展代码。</p>\n<p>书中提到预测，我认为，预测是一种潜意识的行为，当对业务熟悉，对团队熟悉，对设计方法熟悉，自然会在设计过程中做出更准群的预测。可以说，有办法做到预测，且确实准确预测，则执行该原则会变得简单。而即使没有预测，通过重构，我们依然可以解决问题。</p>\n<h4 id=\"里氏替换\"><a href=\"#里氏替换\" class=\"headerlink\" title=\"里氏替换\"></a>里氏替换</h4><blockquote>\n<p>子类型必须能够替换掉基类型</p>\n</blockquote>\n<p>里氏替换的应用场景是这样子的：假设我们定一个一个base类和一个sub类，其中，base类定义了一个method，sub类复写了该method。同时我们定义了一个function用于接受base类的输入，并执行base类的method。这个时候，我们要求子类可以作为function的输入，即是说，子类复写的method必须是与base类的method在输入和输出上是一致的，仅内部计算逻辑不一致。</p>\n<p>当我们在sub类复写了method，造成sub类不能替换base类的时候，我们可能会在function对输入做处理，让其可以接受base类和sub类。我们更可能为sub类专门写一个测试验证其能通过。其实这两者都违反了前述的开放-封闭原则。即我们对function的修改没有对sub类封闭。</p>\n<p>另外需要说的是：</p>\n<ul>\n<li>里氏原则是面向行为的。一个行为限制了某种输入，才有原则的应用场景。</li>\n<li>基于契约设计。显然，我们预先约定了base类和sub类符合里氏原则，才有办法开发接受base类的符合原则的function</li>\n<li>继承本身是复杂的设计，golang甚至舍弃了继承，但我们在这里不谈关于继承的问题。当我们在使用继承的时候，要时刻注意是否符合里氏替换原则。</li>\n</ul>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><blockquote>\n<p>不应该让client依赖于使用不到的方法</p>\n</blockquote>\n<p>一个client需要来源于其他类的某一个特殊的功能，这个时候，如果使用继承，则会将另一个类的所有接口都携带进来，这个时候对client本身是不利的。</p>\n<p>解决方案：</p>\n<ul>\n<li>可以使用适配器（Adapter）来实现隔离，不过这会造成性能问题</li>\n<li>使用多重继承</li>\n</ul>\n<h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><blockquote>\n<p>高层模块不应该依赖于低层模块，两者应该都依赖于抽象<br>抽象不应该依赖于细节，细节应该依赖于抽象</p>\n</blockquote>\n<p>一个经典的例子是，我们在使用框架进行web服务开发的时候，通常只需要编写处理request与返回response的业务逻辑，而request与response的具体执行，都由框架直接执行。从分层的角度，框架是底层，我们实现的web业务是高层。显然，web服务没有调用底层的http处理，而是底层的处理调用了高层的web业务。</p>\n<p>高层模块通常都会依赖底层模块。依赖倒置的目的是为了应对底层模块经常变动的情况。基于开发-封闭原则，如果底层模块变动造成了依赖他的高层模块需要调整，则应该拒绝高层对底层的依赖，而是让两者依赖于不变动的抽象。</p>\n<p>至于细节依赖抽象，则比较好理解。通常，细节是比较容易因为需求增加或调整而发生变更的，抽象则不然。所以细节需要依赖抽象，而抽象不应该依赖细节，即不应该因为细节变更而造成抽象的变更。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>敏捷设计的基础是，在测试驱动开发的前提下，持续重构。同时使用软件设计基本原则，保障代码不至于陷入“坏味道”而难以重构。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本篇为阅读《敏捷软件开发：原则，模式与实践》后的读后感。主要阅读的是第二部分：敏捷设计。<br>这本书的第一部分，关于敏捷开发中的测试驱动开发与重构，可以阅读其他专门的书籍。我阅读的是《重构，改善既有代码设计》。<br>本书第三部分的案例，可自由选择是否阅读以加深理解。我自己更多的是结合自己遇到的问题，从书中描述找到问题的解决方案。</p>\n<h3 id=\"什么是敏捷设计\"><a href=\"#什么是敏捷设计\" class=\"headerlink\" title=\"什么是敏捷设计\"></a>什么是敏捷设计</h3><h4 id=\"软件越来越难维护\"><a href=\"#软件越来越难维护\" class=\"headerlink\" title=\"软件越来越难维护\"></a>软件越来越难维护</h4><p>软件在第一版本发布的时候，是软件设计最干净清晰的时候。随着复杂的需求与软件持续迭代，软件代码往往会在原来的设计上做各种hack以满足新的需求。</p>\n<p>这系列的破坏设计的操作，会在后续的需求增加的过程中逐渐变得难以维护，而后的需求迭代速率将越来越慢。</p>\n<h4 id=\"使用敏捷设计\"><a href=\"#使用敏捷设计\" class=\"headerlink\" title=\"使用敏捷设计\"></a>使用敏捷设计</h4><p>所以我们推荐使用<code>TDD + 重构</code>的形式，来持续调整代码设计，每一次做微小的重构，尽管对单次迭代耗时长，但是把一个大的重构的时间分散在每次迭代中，将有利于代码持续维护。</p>\n<p>此外，在后续的内容中，将使用经典的软件设计原则，来从一开始就让软件设计趋于敏捷，或者说，让软件设计能更好的<strong>拥抱变化</strong>。</p>\n<h4 id=\"尽可能保持代码干净\"><a href=\"#尽可能保持代码干净\" class=\"headerlink\" title=\"尽可能保持代码干净\"></a>尽可能保持代码干净</h4><p>由于在实际开发项目中，文档是软件开发的附属物，代码才是软件开发的本身。如果代码设计的好，将有效的加快开发过程，同时方便新任开发者快速接手，阅读，理解与进一步设计。</p>\n<h3 id=\"软件设计原则\"><a href=\"#软件设计原则\" class=\"headerlink\" title=\"软件设计原则\"></a>软件设计原则</h3><p>软件设计原则篇章，重点讲述了经典的六大设计原则中的其中五项<code>SOLID</code>。</p>\n<h4 id=\"单一职责原则\"><a href=\"#单一职责原则\" class=\"headerlink\" title=\"单一职责原则\"></a>单一职责原则</h4><blockquote>\n<p>就一个类而言，应该只有一个引起他变化的原因</p>\n</blockquote>\n<p>将一个类中复杂的耦合分离开来，是该原则的实践。这要求，每一次做类设计，都要避免将一堆复杂的逻辑放在一个类中，否则这个类就失去了单一职责的原则。</p>\n<p>而在具体情况中，对于几乎不会发生变化的模块，我们不需要为了解耦而解耦，而是将他们放在一个类即可。</p>\n<p>单一职责原则，简单也复杂。难点在于，我们很难在一开始就知道，哪些职责（引起变化的原因 ）是需要解耦的。所以，我们仍然需要通过持续重构来不断优化类设计，使其符合单一职责原则。</p>\n<h4 id=\"开发-封闭原则\"><a href=\"#开发-封闭原则\" class=\"headerlink\" title=\"开发-封闭原则\"></a>开发-封闭原则</h4><blockquote>\n<p>对扩展开放，对更改封闭</p>\n</blockquote>\n<p>对扩展开放，是指，对一个类新增能力是允许的，而且可以非常容易做到的。对更改封闭，是指，对一个类做能力新增的时候，只需要添加代码，而不需要对旧的代码做修改。</p>\n<p>开放-封闭原则是一种非常理想的原则。我们很难在实际业务中，完全不修改旧代码的逻辑，而新增新的代码，除非代码架构从一开始就是与业务不耦合的架构。我们新增业务逻辑的时候，是完全有可能修改旧的逻辑使其具备支持新的业务逻辑的能力。甚至，修改旧的业务逻辑本身就是这次新增的一部分。而我们在编写原来的业务逻辑的时候，并不一定能考虑到其不能支持新增的需求。</p>\n<p>所以，事实上，要实现该原则，要做的就是，重构。我们需要先将旧的代码逻辑重构成符合开放-封闭原则的代码，并跑通测试。然后，在对更改封闭的前提下编写类扩展代码。</p>\n<p>书中提到预测，我认为，预测是一种潜意识的行为，当对业务熟悉，对团队熟悉，对设计方法熟悉，自然会在设计过程中做出更准群的预测。可以说，有办法做到预测，且确实准确预测，则执行该原则会变得简单。而即使没有预测，通过重构，我们依然可以解决问题。</p>\n<h4 id=\"里氏替换\"><a href=\"#里氏替换\" class=\"headerlink\" title=\"里氏替换\"></a>里氏替换</h4><blockquote>\n<p>子类型必须能够替换掉基类型</p>\n</blockquote>\n<p>里氏替换的应用场景是这样子的：假设我们定一个一个base类和一个sub类，其中，base类定义了一个method，sub类复写了该method。同时我们定义了一个function用于接受base类的输入，并执行base类的method。这个时候，我们要求子类可以作为function的输入，即是说，子类复写的method必须是与base类的method在输入和输出上是一致的，仅内部计算逻辑不一致。</p>\n<p>当我们在sub类复写了method，造成sub类不能替换base类的时候，我们可能会在function对输入做处理，让其可以接受base类和sub类。我们更可能为sub类专门写一个测试验证其能通过。其实这两者都违反了前述的开放-封闭原则。即我们对function的修改没有对sub类封闭。</p>\n<p>另外需要说的是：</p>\n<ul>\n<li>里氏原则是面向行为的。一个行为限制了某种输入，才有原则的应用场景。</li>\n<li>基于契约设计。显然，我们预先约定了base类和sub类符合里氏原则，才有办法开发接受base类的符合原则的function</li>\n<li>继承本身是复杂的设计，golang甚至舍弃了继承，但我们在这里不谈关于继承的问题。当我们在使用继承的时候，要时刻注意是否符合里氏替换原则。</li>\n</ul>\n<h4 id=\"接口隔离原则\"><a href=\"#接口隔离原则\" class=\"headerlink\" title=\"接口隔离原则\"></a>接口隔离原则</h4><blockquote>\n<p>不应该让client依赖于使用不到的方法</p>\n</blockquote>\n<p>一个client需要来源于其他类的某一个特殊的功能，这个时候，如果使用继承，则会将另一个类的所有接口都携带进来，这个时候对client本身是不利的。</p>\n<p>解决方案：</p>\n<ul>\n<li>可以使用适配器（Adapter）来实现隔离，不过这会造成性能问题</li>\n<li>使用多重继承</li>\n</ul>\n<h4 id=\"依赖倒置原则\"><a href=\"#依赖倒置原则\" class=\"headerlink\" title=\"依赖倒置原则\"></a>依赖倒置原则</h4><blockquote>\n<p>高层模块不应该依赖于低层模块，两者应该都依赖于抽象<br>抽象不应该依赖于细节，细节应该依赖于抽象</p>\n</blockquote>\n<p>一个经典的例子是，我们在使用框架进行web服务开发的时候，通常只需要编写处理request与返回response的业务逻辑，而request与response的具体执行，都由框架直接执行。从分层的角度，框架是底层，我们实现的web业务是高层。显然，web服务没有调用底层的http处理，而是底层的处理调用了高层的web业务。</p>\n<p>高层模块通常都会依赖底层模块。依赖倒置的目的是为了应对底层模块经常变动的情况。基于开发-封闭原则，如果底层模块变动造成了依赖他的高层模块需要调整，则应该拒绝高层对底层的依赖，而是让两者依赖于不变动的抽象。</p>\n<p>至于细节依赖抽象，则比较好理解。通常，细节是比较容易因为需求增加或调整而发生变更的，抽象则不然。所以细节需要依赖抽象，而抽象不应该依赖细节，即不应该因为细节变更而造成抽象的变更。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>敏捷设计的基础是，在测试驱动开发的前提下，持续重构。同时使用软件设计基本原则，保障代码不至于陷入“坏味道”而难以重构。</p>\n"},{"layout":"post","title":"DRF Exception Handle","author":"Edison","date":"2021-07-14T16:00:00.000Z","_content":"\n持续更新关于python并行计算与异步计算的包，后续再根据篇章拆分。\n\n### Python 并行\n\n#### 并行库\n[threading](https://docs.python.org/3/library/threading.html)\n[multiprocessing](https://docs.python.org/3/library/multiprocessing.html)\n\n#### multiprocessing 中的一些问题\n##### 问题\n- [开启子进程的方法与问题](https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods)  \n    spawn相比fork会更耗时，但是fork在处理一个多线程的进程时可能会陷入死锁等问题。这是由于[fork本身的机制](https://man7.org/linux/man-pages/man2/fork.2.html)造成的。这也使得在使用包的过程中常常遇到一些问题。\n- IO问题  \n    [fork本身会继承打开文件的描述符](https://man7.org/linux/man-pages/man2/fork.2.html)，所以对于多进程的处理，要留意IO处理带来的不良影响\n##### 建议\n由于使用多进程更多是因为，CPython本身的GIL造成无法使用多个CPU核，而使用多进程的方式进行处理。所以仅当处理多核计算任务的时候，我们使用multiprocessing，并且尽量让处理内容限定在计算而不包含IO。\n\n### Python 异步\n#### gunicorn + gevent\n[gunicorn async worker](https://docs.gunicorn.org/en/latest/design.html#async-workers)\n\n### 其他\n\n[Event Loop Wiki](https://en.wikipedia.org/wiki/Event_loop)","source":"_posts/parallel-and-asynchronous-python.md","raw":"---\nlayout: post\ntitle: DRF Exception Handle\nauthor: Edison\ndate: 2021-07-15\n---\n\n持续更新关于python并行计算与异步计算的包，后续再根据篇章拆分。\n\n### Python 并行\n\n#### 并行库\n[threading](https://docs.python.org/3/library/threading.html)\n[multiprocessing](https://docs.python.org/3/library/multiprocessing.html)\n\n#### multiprocessing 中的一些问题\n##### 问题\n- [开启子进程的方法与问题](https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods)  \n    spawn相比fork会更耗时，但是fork在处理一个多线程的进程时可能会陷入死锁等问题。这是由于[fork本身的机制](https://man7.org/linux/man-pages/man2/fork.2.html)造成的。这也使得在使用包的过程中常常遇到一些问题。\n- IO问题  \n    [fork本身会继承打开文件的描述符](https://man7.org/linux/man-pages/man2/fork.2.html)，所以对于多进程的处理，要留意IO处理带来的不良影响\n##### 建议\n由于使用多进程更多是因为，CPython本身的GIL造成无法使用多个CPU核，而使用多进程的方式进行处理。所以仅当处理多核计算任务的时候，我们使用multiprocessing，并且尽量让处理内容限定在计算而不包含IO。\n\n### Python 异步\n#### gunicorn + gevent\n[gunicorn async worker](https://docs.gunicorn.org/en/latest/design.html#async-workers)\n\n### 其他\n\n[Event Loop Wiki](https://en.wikipedia.org/wiki/Event_loop)","slug":"parallel-and-asynchronous-python","published":1,"updated":"2022-01-30T15:58:21.662Z","_id":"ckz1g6er40007clht4ni794b1","comments":1,"photos":[],"link":"","content":"<p>持续更新关于python并行计算与异步计算的包，后续再根据篇章拆分。</p>\n<h3 id=\"Python-并行\"><a href=\"#Python-并行\" class=\"headerlink\" title=\"Python 并行\"></a>Python 并行</h3><h4 id=\"并行库\"><a href=\"#并行库\" class=\"headerlink\" title=\"并行库\"></a>并行库</h4><p><a href=\"https://docs.python.org/3/library/threading.html\">threading</a><br><a href=\"https://docs.python.org/3/library/multiprocessing.html\">multiprocessing</a></p>\n<h4 id=\"multiprocessing-中的一些问题\"><a href=\"#multiprocessing-中的一些问题\" class=\"headerlink\" title=\"multiprocessing 中的一些问题\"></a>multiprocessing 中的一些问题</h4><h5 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h5><ul>\n<li><a href=\"https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\">开启子进程的方法与问题</a><br>  spawn相比fork会更耗时，但是fork在处理一个多线程的进程时可能会陷入死锁等问题。这是由于<a href=\"https://man7.org/linux/man-pages/man2/fork.2.html\">fork本身的机制</a>造成的。这也使得在使用包的过程中常常遇到一些问题。</li>\n<li>IO问题<br>  <a href=\"https://man7.org/linux/man-pages/man2/fork.2.html\">fork本身会继承打开文件的描述符</a>，所以对于多进程的处理，要留意IO处理带来的不良影响<h5 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h5>由于使用多进程更多是因为，CPython本身的GIL造成无法使用多个CPU核，而使用多进程的方式进行处理。所以仅当处理多核计算任务的时候，我们使用multiprocessing，并且尽量让处理内容限定在计算而不包含IO。</li>\n</ul>\n<h3 id=\"Python-异步\"><a href=\"#Python-异步\" class=\"headerlink\" title=\"Python 异步\"></a>Python 异步</h3><h4 id=\"gunicorn-gevent\"><a href=\"#gunicorn-gevent\" class=\"headerlink\" title=\"gunicorn + gevent\"></a>gunicorn + gevent</h4><p><a href=\"https://docs.gunicorn.org/en/latest/design.html#async-workers\">gunicorn async worker</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p><a href=\"https://en.wikipedia.org/wiki/Event_loop\">Event Loop Wiki</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>持续更新关于python并行计算与异步计算的包，后续再根据篇章拆分。</p>\n<h3 id=\"Python-并行\"><a href=\"#Python-并行\" class=\"headerlink\" title=\"Python 并行\"></a>Python 并行</h3><h4 id=\"并行库\"><a href=\"#并行库\" class=\"headerlink\" title=\"并行库\"></a>并行库</h4><p><a href=\"https://docs.python.org/3/library/threading.html\">threading</a><br><a href=\"https://docs.python.org/3/library/multiprocessing.html\">multiprocessing</a></p>\n<h4 id=\"multiprocessing-中的一些问题\"><a href=\"#multiprocessing-中的一些问题\" class=\"headerlink\" title=\"multiprocessing 中的一些问题\"></a>multiprocessing 中的一些问题</h4><h5 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h5><ul>\n<li><a href=\"https://docs.python.org/3/library/multiprocessing.html#contexts-and-start-methods\">开启子进程的方法与问题</a><br>  spawn相比fork会更耗时，但是fork在处理一个多线程的进程时可能会陷入死锁等问题。这是由于<a href=\"https://man7.org/linux/man-pages/man2/fork.2.html\">fork本身的机制</a>造成的。这也使得在使用包的过程中常常遇到一些问题。</li>\n<li>IO问题<br>  <a href=\"https://man7.org/linux/man-pages/man2/fork.2.html\">fork本身会继承打开文件的描述符</a>，所以对于多进程的处理，要留意IO处理带来的不良影响<h5 id=\"建议\"><a href=\"#建议\" class=\"headerlink\" title=\"建议\"></a>建议</h5>由于使用多进程更多是因为，CPython本身的GIL造成无法使用多个CPU核，而使用多进程的方式进行处理。所以仅当处理多核计算任务的时候，我们使用multiprocessing，并且尽量让处理内容限定在计算而不包含IO。</li>\n</ul>\n<h3 id=\"Python-异步\"><a href=\"#Python-异步\" class=\"headerlink\" title=\"Python 异步\"></a>Python 异步</h3><h4 id=\"gunicorn-gevent\"><a href=\"#gunicorn-gevent\" class=\"headerlink\" title=\"gunicorn + gevent\"></a>gunicorn + gevent</h4><p><a href=\"https://docs.gunicorn.org/en/latest/design.html#async-workers\">gunicorn async worker</a></p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><p><a href=\"https://en.wikipedia.org/wiki/Event_loop\">Event Loop Wiki</a></p>\n"},{"layout":"post","title":"Django Restful Framework Business Logic","author":"Edison","date":"2021-03-29T16:00:00.000Z","_content":"\n### Django Restful Framework Business Logic \n#### Django Restful Framework \n- Restful API\nDjango Restful Framework 提供了非常便利的方法序列化Restful API，并且提供了统一的数据返回格式（包括错误返回）。\n- Serializer\nSerializer 提供了数据序列化反序列的操作，并承担了validation的工作，validator有内置，也可以自主添加。\n\n#### 局限性\n我们在使用中也发现了一些局限性。这些局限，根本上是因为框架是基于Model去设计的。当我们遇到API由多个不同的Django Model组成数据的时候，就会遇到限制。当AP\n- Writtable Nested SerializerI的输入输出由多个Django Model组成时，我们无法写入nested serializer。如果是一个relation field，当指定```source```的时候，我们会发现，由于```set_value```是字典嵌套赋值操作，该field作为入参没有办法被成功```set_value```。为了在执行```serializer.save()```的时候能够顺利存储多个Django Model，我们不得不修改serializer的```create```和```update```操作。而这破坏了前述serializer所提供的能力。\n\n#### 解决方案\n\n- 使用宽表\n\n对于需要在一个```serializer```进行读写的数据，本质上也说明了该数据集很有可能属于同一个领域模型。对于一个模型，我们可以使用一张表存下它。如果模型包含的字段较多，我们可以使用宽表。\n\n宽表在OLTP场景中，可能会带来写入性能的影响。我们需要权衡的是，我们的业务量是否会因此而带来性能影响。对于小型业务，这是一个不错的考虑。\n\n使用宽表还有另一个问题，就是migration会不断在同一张表上进行，随着数据量增加，可能会对migration的性能带来不良影响。同样的，在小型业务中，这些问题仍然不会很显著。当我们遇到性能问题的时候，很可能表结构已经因为业务发展做了拆分了。\n\n- 使用service层\n\n使用service层，是将view与model隔离的一种好方法。将大量复杂的业务逻辑封装在service层中，在view层为业务提供适配的API，并引入各种权限校验等通用逻辑，在model层独立设计模型及其关系，由service层将两者串联起来。\n\nservice层像是设计模式中的适配器，当model设计与前端的model不完全一致的时候，service充当适配器的效果，将两者串联起来。\n\nservice的引入会带来代码的开发，增加开发成本，当然也相应会带来不稳定的因素。\n\n#### 框架只是解决一部分问题\n\n使用DRF框架显然可以快速的开发一个restful的应用，在业务逻辑非常简单的时候（常规的CRUD居多），完成一个项目的开发可能只需要一两天的时间。而我们在实际使用中也发现框架对读取数据及其关联数据的能力非常强大，相对的写入关联数据的支持非常少。这个在官方文档中关于```writtable nested serializer```的描述就很显见了，在```ListSerializer```的```update```方法也提到需要由开发者自行编写。这其实是框架设计团队的权衡与取舍，毕竟写入的逻辑通常很复杂，由用户定义会比提供一套内置方法更加有价值。在各类社区中，有很多开发者也分享了写入场景及写入方法的代码。\n\n框架中还出现了同一个方法的输入不一致等问题。比如对于```ListSerializer```的```to_representation```方法，输入的```data```是一个```Database Manager```，而对于字段类型的```Serializer```，则是对应的```value```。\n\n这些问题都说明了，框架只能解决一部分的问题，框架也只想解决一部分的问题。框架提供了某一类非常方便的接口，其内部封装则是非常复杂的，这些封装在经过充分测试之后通常会变得稳定，尽管里面仍可能存在不好理解的地方。\n\n因此，我们使用DRF的时候，如果可以充分利用其能力，达到低代码高稳定的效果，则尽管使用。但是，我们也不需要被```serializer```的设计框住，自定义必须的service来处理业务逻辑，反而可以使整个业务逻辑更清晰，更具备可测试性与可维护性。\n","source":"_posts/DRF-Bussiness-Logic.md","raw":"---\nlayout: post\ntitle: Django Restful Framework Business Logic\nauthor: Edison\ndate: 2021-03-30\n---\n\n### Django Restful Framework Business Logic \n#### Django Restful Framework \n- Restful API\nDjango Restful Framework 提供了非常便利的方法序列化Restful API，并且提供了统一的数据返回格式（包括错误返回）。\n- Serializer\nSerializer 提供了数据序列化反序列的操作，并承担了validation的工作，validator有内置，也可以自主添加。\n\n#### 局限性\n我们在使用中也发现了一些局限性。这些局限，根本上是因为框架是基于Model去设计的。当我们遇到API由多个不同的Django Model组成数据的时候，就会遇到限制。当AP\n- Writtable Nested SerializerI的输入输出由多个Django Model组成时，我们无法写入nested serializer。如果是一个relation field，当指定```source```的时候，我们会发现，由于```set_value```是字典嵌套赋值操作，该field作为入参没有办法被成功```set_value```。为了在执行```serializer.save()```的时候能够顺利存储多个Django Model，我们不得不修改serializer的```create```和```update```操作。而这破坏了前述serializer所提供的能力。\n\n#### 解决方案\n\n- 使用宽表\n\n对于需要在一个```serializer```进行读写的数据，本质上也说明了该数据集很有可能属于同一个领域模型。对于一个模型，我们可以使用一张表存下它。如果模型包含的字段较多，我们可以使用宽表。\n\n宽表在OLTP场景中，可能会带来写入性能的影响。我们需要权衡的是，我们的业务量是否会因此而带来性能影响。对于小型业务，这是一个不错的考虑。\n\n使用宽表还有另一个问题，就是migration会不断在同一张表上进行，随着数据量增加，可能会对migration的性能带来不良影响。同样的，在小型业务中，这些问题仍然不会很显著。当我们遇到性能问题的时候，很可能表结构已经因为业务发展做了拆分了。\n\n- 使用service层\n\n使用service层，是将view与model隔离的一种好方法。将大量复杂的业务逻辑封装在service层中，在view层为业务提供适配的API，并引入各种权限校验等通用逻辑，在model层独立设计模型及其关系，由service层将两者串联起来。\n\nservice层像是设计模式中的适配器，当model设计与前端的model不完全一致的时候，service充当适配器的效果，将两者串联起来。\n\nservice的引入会带来代码的开发，增加开发成本，当然也相应会带来不稳定的因素。\n\n#### 框架只是解决一部分问题\n\n使用DRF框架显然可以快速的开发一个restful的应用，在业务逻辑非常简单的时候（常规的CRUD居多），完成一个项目的开发可能只需要一两天的时间。而我们在实际使用中也发现框架对读取数据及其关联数据的能力非常强大，相对的写入关联数据的支持非常少。这个在官方文档中关于```writtable nested serializer```的描述就很显见了，在```ListSerializer```的```update```方法也提到需要由开发者自行编写。这其实是框架设计团队的权衡与取舍，毕竟写入的逻辑通常很复杂，由用户定义会比提供一套内置方法更加有价值。在各类社区中，有很多开发者也分享了写入场景及写入方法的代码。\n\n框架中还出现了同一个方法的输入不一致等问题。比如对于```ListSerializer```的```to_representation```方法，输入的```data```是一个```Database Manager```，而对于字段类型的```Serializer```，则是对应的```value```。\n\n这些问题都说明了，框架只能解决一部分的问题，框架也只想解决一部分的问题。框架提供了某一类非常方便的接口，其内部封装则是非常复杂的，这些封装在经过充分测试之后通常会变得稳定，尽管里面仍可能存在不好理解的地方。\n\n因此，我们使用DRF的时候，如果可以充分利用其能力，达到低代码高稳定的效果，则尽管使用。但是，我们也不需要被```serializer```的设计框住，自定义必须的service来处理业务逻辑，反而可以使整个业务逻辑更清晰，更具备可测试性与可维护性。\n","slug":"DRF-Bussiness-Logic","published":1,"updated":"2022-01-30T15:59:02.766Z","_id":"ckz1g7kdi0008clht9fpq6u17","comments":1,"photos":[],"link":"","content":"<h3 id=\"Django-Restful-Framework-Business-Logic\"><a href=\"#Django-Restful-Framework-Business-Logic\" class=\"headerlink\" title=\"Django Restful Framework Business Logic\"></a>Django Restful Framework Business Logic</h3><h4 id=\"Django-Restful-Framework\"><a href=\"#Django-Restful-Framework\" class=\"headerlink\" title=\"Django Restful Framework\"></a>Django Restful Framework</h4><ul>\n<li>Restful API<br>Django Restful Framework 提供了非常便利的方法序列化Restful API，并且提供了统一的数据返回格式（包括错误返回）。</li>\n<li>Serializer<br>Serializer 提供了数据序列化反序列的操作，并承担了validation的工作，validator有内置，也可以自主添加。</li>\n</ul>\n<h4 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h4><p>我们在使用中也发现了一些局限性。这些局限，根本上是因为框架是基于Model去设计的。当我们遇到API由多个不同的Django Model组成数据的时候，就会遇到限制。当AP</p>\n<ul>\n<li>Writtable Nested SerializerI的输入输出由多个Django Model组成时，我们无法写入nested serializer。如果是一个relation field，当指定<code>source</code>的时候，我们会发现，由于<code>set_value</code>是字典嵌套赋值操作，该field作为入参没有办法被成功<code>set_value</code>。为了在执行<code>serializer.save()</code>的时候能够顺利存储多个Django Model，我们不得不修改serializer的<code>create</code>和<code>update</code>操作。而这破坏了前述serializer所提供的能力。</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>使用宽表</li>\n</ul>\n<p>对于需要在一个<code>serializer</code>进行读写的数据，本质上也说明了该数据集很有可能属于同一个领域模型。对于一个模型，我们可以使用一张表存下它。如果模型包含的字段较多，我们可以使用宽表。</p>\n<p>宽表在OLTP场景中，可能会带来写入性能的影响。我们需要权衡的是，我们的业务量是否会因此而带来性能影响。对于小型业务，这是一个不错的考虑。</p>\n<p>使用宽表还有另一个问题，就是migration会不断在同一张表上进行，随着数据量增加，可能会对migration的性能带来不良影响。同样的，在小型业务中，这些问题仍然不会很显著。当我们遇到性能问题的时候，很可能表结构已经因为业务发展做了拆分了。</p>\n<ul>\n<li>使用service层</li>\n</ul>\n<p>使用service层，是将view与model隔离的一种好方法。将大量复杂的业务逻辑封装在service层中，在view层为业务提供适配的API，并引入各种权限校验等通用逻辑，在model层独立设计模型及其关系，由service层将两者串联起来。</p>\n<p>service层像是设计模式中的适配器，当model设计与前端的model不完全一致的时候，service充当适配器的效果，将两者串联起来。</p>\n<p>service的引入会带来代码的开发，增加开发成本，当然也相应会带来不稳定的因素。</p>\n<h4 id=\"框架只是解决一部分问题\"><a href=\"#框架只是解决一部分问题\" class=\"headerlink\" title=\"框架只是解决一部分问题\"></a>框架只是解决一部分问题</h4><p>使用DRF框架显然可以快速的开发一个restful的应用，在业务逻辑非常简单的时候（常规的CRUD居多），完成一个项目的开发可能只需要一两天的时间。而我们在实际使用中也发现框架对读取数据及其关联数据的能力非常强大，相对的写入关联数据的支持非常少。这个在官方文档中关于<code>writtable nested serializer</code>的描述就很显见了，在<code>ListSerializer</code>的<code>update</code>方法也提到需要由开发者自行编写。这其实是框架设计团队的权衡与取舍，毕竟写入的逻辑通常很复杂，由用户定义会比提供一套内置方法更加有价值。在各类社区中，有很多开发者也分享了写入场景及写入方法的代码。</p>\n<p>框架中还出现了同一个方法的输入不一致等问题。比如对于<code>ListSerializer</code>的<code>to_representation</code>方法，输入的<code>data</code>是一个<code>Database Manager</code>，而对于字段类型的<code>Serializer</code>，则是对应的<code>value</code>。</p>\n<p>这些问题都说明了，框架只能解决一部分的问题，框架也只想解决一部分的问题。框架提供了某一类非常方便的接口，其内部封装则是非常复杂的，这些封装在经过充分测试之后通常会变得稳定，尽管里面仍可能存在不好理解的地方。</p>\n<p>因此，我们使用DRF的时候，如果可以充分利用其能力，达到低代码高稳定的效果，则尽管使用。但是，我们也不需要被<code>serializer</code>的设计框住，自定义必须的service来处理业务逻辑，反而可以使整个业务逻辑更清晰，更具备可测试性与可维护性。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Django-Restful-Framework-Business-Logic\"><a href=\"#Django-Restful-Framework-Business-Logic\" class=\"headerlink\" title=\"Django Restful Framework Business Logic\"></a>Django Restful Framework Business Logic</h3><h4 id=\"Django-Restful-Framework\"><a href=\"#Django-Restful-Framework\" class=\"headerlink\" title=\"Django Restful Framework\"></a>Django Restful Framework</h4><ul>\n<li>Restful API<br>Django Restful Framework 提供了非常便利的方法序列化Restful API，并且提供了统一的数据返回格式（包括错误返回）。</li>\n<li>Serializer<br>Serializer 提供了数据序列化反序列的操作，并承担了validation的工作，validator有内置，也可以自主添加。</li>\n</ul>\n<h4 id=\"局限性\"><a href=\"#局限性\" class=\"headerlink\" title=\"局限性\"></a>局限性</h4><p>我们在使用中也发现了一些局限性。这些局限，根本上是因为框架是基于Model去设计的。当我们遇到API由多个不同的Django Model组成数据的时候，就会遇到限制。当AP</p>\n<ul>\n<li>Writtable Nested SerializerI的输入输出由多个Django Model组成时，我们无法写入nested serializer。如果是一个relation field，当指定<code>source</code>的时候，我们会发现，由于<code>set_value</code>是字典嵌套赋值操作，该field作为入参没有办法被成功<code>set_value</code>。为了在执行<code>serializer.save()</code>的时候能够顺利存储多个Django Model，我们不得不修改serializer的<code>create</code>和<code>update</code>操作。而这破坏了前述serializer所提供的能力。</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>使用宽表</li>\n</ul>\n<p>对于需要在一个<code>serializer</code>进行读写的数据，本质上也说明了该数据集很有可能属于同一个领域模型。对于一个模型，我们可以使用一张表存下它。如果模型包含的字段较多，我们可以使用宽表。</p>\n<p>宽表在OLTP场景中，可能会带来写入性能的影响。我们需要权衡的是，我们的业务量是否会因此而带来性能影响。对于小型业务，这是一个不错的考虑。</p>\n<p>使用宽表还有另一个问题，就是migration会不断在同一张表上进行，随着数据量增加，可能会对migration的性能带来不良影响。同样的，在小型业务中，这些问题仍然不会很显著。当我们遇到性能问题的时候，很可能表结构已经因为业务发展做了拆分了。</p>\n<ul>\n<li>使用service层</li>\n</ul>\n<p>使用service层，是将view与model隔离的一种好方法。将大量复杂的业务逻辑封装在service层中，在view层为业务提供适配的API，并引入各种权限校验等通用逻辑，在model层独立设计模型及其关系，由service层将两者串联起来。</p>\n<p>service层像是设计模式中的适配器，当model设计与前端的model不完全一致的时候，service充当适配器的效果，将两者串联起来。</p>\n<p>service的引入会带来代码的开发，增加开发成本，当然也相应会带来不稳定的因素。</p>\n<h4 id=\"框架只是解决一部分问题\"><a href=\"#框架只是解决一部分问题\" class=\"headerlink\" title=\"框架只是解决一部分问题\"></a>框架只是解决一部分问题</h4><p>使用DRF框架显然可以快速的开发一个restful的应用，在业务逻辑非常简单的时候（常规的CRUD居多），完成一个项目的开发可能只需要一两天的时间。而我们在实际使用中也发现框架对读取数据及其关联数据的能力非常强大，相对的写入关联数据的支持非常少。这个在官方文档中关于<code>writtable nested serializer</code>的描述就很显见了，在<code>ListSerializer</code>的<code>update</code>方法也提到需要由开发者自行编写。这其实是框架设计团队的权衡与取舍，毕竟写入的逻辑通常很复杂，由用户定义会比提供一套内置方法更加有价值。在各类社区中，有很多开发者也分享了写入场景及写入方法的代码。</p>\n<p>框架中还出现了同一个方法的输入不一致等问题。比如对于<code>ListSerializer</code>的<code>to_representation</code>方法，输入的<code>data</code>是一个<code>Database Manager</code>，而对于字段类型的<code>Serializer</code>，则是对应的<code>value</code>。</p>\n<p>这些问题都说明了，框架只能解决一部分的问题，框架也只想解决一部分的问题。框架提供了某一类非常方便的接口，其内部封装则是非常复杂的，这些封装在经过充分测试之后通常会变得稳定，尽管里面仍可能存在不好理解的地方。</p>\n<p>因此，我们使用DRF的时候，如果可以充分利用其能力，达到低代码高稳定的效果，则尽管使用。但是，我们也不需要被<code>serializer</code>的设计框住，自定义必须的service来处理业务逻辑，反而可以使整个业务逻辑更清晰，更具备可测试性与可维护性。</p>\n"},{"layout":"post","title":"Django With DDD","author":"Edison","date":"2021-06-14T16:00:00.000Z","_content":"\n在[DRF业务逻辑实现](https://zhangn661.com/2021/03/30/DRF-Bussiness-Logic/)篇中，提到关于使用Django框架编写业务逻辑的一些局限性以及可能的解决方案。当业务开始扩展的时候，渐渐发现，框架对复杂业务的支持能力明显不足，已经超出了使用service来处理的能力了。\n\n当开始尝试使用DDD来进行模块与架构设计时，不仅要理解DDD是什么，同时需要去理解DDD在Django中应用的困难[^1][^2]\n\n一种有效的方法是，从```serializers```中封装```domail_serializers```，用来承担```view```中的业务逻辑执行，担任一个```实体```。```view```作为一个```bounded context```的存在，绑定多个```serializers```，完成一个业务逻辑的执行。\n\n显然，```DRF```已经基于这样的方式实现了，不足之处在于```serializers```的能力有限，同时，```DRF```没有强调```serializers```是一个```domain```\n\n(先占坑，后续再补充DDD的调研与实践...)\n\n\n\n[^1]: [django-design-philosophies](https://docs.djangoproject.com/en/3.2/misc/design-philosophies/#include-all-relevant-domain-logic)\n[^2]: [active-record](https://www.martinfowler.com/eaaCatalog/activeRecord.html)","source":"_posts/Django-With-DDD.md","raw":"---\nlayout: post\ntitle: Django With DDD\nauthor: Edison\ndate: 2021-06-15\n---\n\n在[DRF业务逻辑实现](https://zhangn661.com/2021/03/30/DRF-Bussiness-Logic/)篇中，提到关于使用Django框架编写业务逻辑的一些局限性以及可能的解决方案。当业务开始扩展的时候，渐渐发现，框架对复杂业务的支持能力明显不足，已经超出了使用service来处理的能力了。\n\n当开始尝试使用DDD来进行模块与架构设计时，不仅要理解DDD是什么，同时需要去理解DDD在Django中应用的困难[^1][^2]\n\n一种有效的方法是，从```serializers```中封装```domail_serializers```，用来承担```view```中的业务逻辑执行，担任一个```实体```。```view```作为一个```bounded context```的存在，绑定多个```serializers```，完成一个业务逻辑的执行。\n\n显然，```DRF```已经基于这样的方式实现了，不足之处在于```serializers```的能力有限，同时，```DRF```没有强调```serializers```是一个```domain```\n\n(先占坑，后续再补充DDD的调研与实践...)\n\n\n\n[^1]: [django-design-philosophies](https://docs.djangoproject.com/en/3.2/misc/design-philosophies/#include-all-relevant-domain-logic)\n[^2]: [active-record](https://www.martinfowler.com/eaaCatalog/activeRecord.html)","slug":"Django-With-DDD","published":1,"updated":"2022-01-30T15:59:41.169Z","_id":"ckz1g8g2h0009clhta715c6f5","comments":1,"photos":[],"link":"","content":"<p>在<a href=\"https://zhangn661.com/2021/03/30/DRF-Bussiness-Logic/\">DRF业务逻辑实现</a>篇中，提到关于使用Django框架编写业务逻辑的一些局限性以及可能的解决方案。当业务开始扩展的时候，渐渐发现，框架对复杂业务的支持能力明显不足，已经超出了使用service来处理的能力了。</p>\n<p>当开始尝试使用DDD来进行模块与架构设计时，不仅要理解DDD是什么，同时需要去理解DDD在Django中应用的困难<a href=\"%5Bactive-record%5D(https://www.martinfowler.com/eaaCatalog/activeRecord.html)\">^1</a></p>\n<p>一种有效的方法是，从<code>serializers</code>中封装<code>domail_serializers</code>，用来承担<code>view</code>中的业务逻辑执行，担任一个<code>实体</code>。<code>view</code>作为一个<code>bounded context</code>的存在，绑定多个<code>serializers</code>，完成一个业务逻辑的执行。</p>\n<p>显然，<code>DRF</code>已经基于这样的方式实现了，不足之处在于<code>serializers</code>的能力有限，同时，<code>DRF</code>没有强调<code>serializers</code>是一个<code>domain</code></p>\n<p>(先占坑，后续再补充DDD的调研与实践…)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://zhangn661.com/2021/03/30/DRF-Bussiness-Logic/\">DRF业务逻辑实现</a>篇中，提到关于使用Django框架编写业务逻辑的一些局限性以及可能的解决方案。当业务开始扩展的时候，渐渐发现，框架对复杂业务的支持能力明显不足，已经超出了使用service来处理的能力了。</p>\n<p>当开始尝试使用DDD来进行模块与架构设计时，不仅要理解DDD是什么，同时需要去理解DDD在Django中应用的困难<a href=\"%5Bactive-record%5D(https://www.martinfowler.com/eaaCatalog/activeRecord.html)\">^1</a></p>\n<p>一种有效的方法是，从<code>serializers</code>中封装<code>domail_serializers</code>，用来承担<code>view</code>中的业务逻辑执行，担任一个<code>实体</code>。<code>view</code>作为一个<code>bounded context</code>的存在，绑定多个<code>serializers</code>，完成一个业务逻辑的执行。</p>\n<p>显然，<code>DRF</code>已经基于这样的方式实现了，不足之处在于<code>serializers</code>的能力有限，同时，<code>DRF</code>没有强调<code>serializers</code>是一个<code>domain</code></p>\n<p>(先占坑，后续再补充DDD的调研与实践…)</p>\n"},{"layout":"post","title":"DRF Exception Handle","author":"Edison","date":"2021-06-16T16:00:00.000Z","_content":"\n### 框架报错源码解析\n- exception 处理器\n```python\n# rest_framework.views 71-101\ndef exception_handler(exc, context):\n    \"\"\"\n    Returns the response that should be used for any given exception.\n\n    By default we handle the REST framework `APIException`, and also\n    Django's built-in `Http404` and `PermissionDenied` exceptions.\n\n    Any unhandled exceptions may return `None`, which will cause a 500 error\n    to be raised.\n    \"\"\"\n    if isinstance(exc, Http404):\n        exc = exceptions.NotFound()\n    elif isinstance(exc, PermissionDenied):\n        exc = exceptions.PermissionDenied()\n\n    if isinstance(exc, exceptions.APIException):\n        headers = {}\n        if getattr(exc, 'auth_header', None):\n            headers['WWW-Authenticate'] = exc.auth_header\n        if getattr(exc, 'wait', None):\n            headers['Retry-After'] = '%d' % exc.wait\n\n        if isinstance(exc.detail, (list, dict)):\n            data = exc.detail\n        else:\n            data = {'detail': exc.detail}\n\n        set_rollback()\n        return Response(data, status=exc.status_code, headers=headers)\n\n    return None\n```\n从处理器源码可以看到，当抛出一个```str```的错误的时候，处理器会主动为其添加一个```detail```的```key```来包裹成可以被后续处理为```json```的格式，而对于```list```与```dict```的格式，则直接返回。\n\n- ValidationError 处理\n\n```python\n#rest_framework.exceptions.ValidationError 140-158\nclass ValidationError(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = _('Invalid input.')\n    default_code = 'invalid'\n\n    def __init__(self, detail=None, code=None):\n        if detail is None:\n            detail = self.default_detail\n        if code is None:\n            code = self.default_code\n\n        # For validation failures, we may collect many errors together,\n        # so the details should always be coerced to a list if not already.\n        if isinstance(detail, tuple):\n            detail = list(detail)\n        elif not isinstance(detail, dict) and not isinstance(detail, list):\n            detail = [detail]\n\n        self.detail = _get_error_details(detail, code)\n```\n对于```ValidationError```错误，会强制将最后的值转换为```list```类型，这是考虑到一个```field```可能有多条不同的错误需要累积。\n\n- 序列化报错处理\n\n```python\n#rest_framework.serializers 323-346\ndef as_serializer_error(exc):\n    assert isinstance(exc, (ValidationError, DjangoValidationError))\n\n    if isinstance(exc, DjangoValidationError):\n        detail = get_error_detail(exc)\n    else:\n        detail = exc.detail\n\n    if isinstance(detail, Mapping):\n        # If errors may be a dict we use the standard {key: list of values}.\n        # Here we ensure that all the values are *lists* of errors.\n        return {\n            key: value if isinstance(value, (list, Mapping)) else [value]\n            for key, value in detail.items()\n        }\n    elif isinstance(detail, list):\n        # Errors raised as a list are non-field errors.\n        return {\n            api_settings.NON_FIELD_ERRORS_KEY: detail\n        }\n    # Errors raised as a string are non-field errors.\n    return {\n        api_settings.NON_FIELD_ERRORS_KEY: [detail]\n    }\n```\ndrf中的序列化器```serializers```，在运行```run_validation```序列化报错的过程中，会给没有列出具体字段错误的```detail```信息，即不是```dict```格式的信息，带上一个```non_field_errors```的key来标准化。\n\n### 推荐方案\n- 非400报错\n对于403，404等错误码，直接获取```detail```下的值即可\n- 400报错\n对于ValidationError错误，需要做两种处理\n  1. 单独创建，报错如下，直接识别到错误的字段\n  ```\n  {\n    \"id\": [\"Not Unique\"]\n  }\n  ```\n  2. 批量创建，报错如下，按顺序识别创建的条目的错误字段。如果为空，则说明无校验错误。\n  ```\n  [\n    {},\n    {\n      \"id\": [\"Not Unique\"]\n    },\n    {},\n    {}\n  ]\n  ```\n  此外，关于返回值为数组，需要前端进行相应处理具有多个错误信息的报错。\n### 其他方案\n根据参考方案，按照团队习惯，可以自定义```exception_handler```，以定义团队使用的错误信息格式。\n### 参考文档\n[drf-exception](https://www.django-rest-framework.org/api-guide/exceptions/#custom-exception-handling)\n","source":"_posts/DRF-Exception.md","raw":"---\nlayout: post\ntitle: DRF Exception Handle\nauthor: Edison\ndate: 2021-06-17\n---\n\n### 框架报错源码解析\n- exception 处理器\n```python\n# rest_framework.views 71-101\ndef exception_handler(exc, context):\n    \"\"\"\n    Returns the response that should be used for any given exception.\n\n    By default we handle the REST framework `APIException`, and also\n    Django's built-in `Http404` and `PermissionDenied` exceptions.\n\n    Any unhandled exceptions may return `None`, which will cause a 500 error\n    to be raised.\n    \"\"\"\n    if isinstance(exc, Http404):\n        exc = exceptions.NotFound()\n    elif isinstance(exc, PermissionDenied):\n        exc = exceptions.PermissionDenied()\n\n    if isinstance(exc, exceptions.APIException):\n        headers = {}\n        if getattr(exc, 'auth_header', None):\n            headers['WWW-Authenticate'] = exc.auth_header\n        if getattr(exc, 'wait', None):\n            headers['Retry-After'] = '%d' % exc.wait\n\n        if isinstance(exc.detail, (list, dict)):\n            data = exc.detail\n        else:\n            data = {'detail': exc.detail}\n\n        set_rollback()\n        return Response(data, status=exc.status_code, headers=headers)\n\n    return None\n```\n从处理器源码可以看到，当抛出一个```str```的错误的时候，处理器会主动为其添加一个```detail```的```key```来包裹成可以被后续处理为```json```的格式，而对于```list```与```dict```的格式，则直接返回。\n\n- ValidationError 处理\n\n```python\n#rest_framework.exceptions.ValidationError 140-158\nclass ValidationError(APIException):\n    status_code = status.HTTP_400_BAD_REQUEST\n    default_detail = _('Invalid input.')\n    default_code = 'invalid'\n\n    def __init__(self, detail=None, code=None):\n        if detail is None:\n            detail = self.default_detail\n        if code is None:\n            code = self.default_code\n\n        # For validation failures, we may collect many errors together,\n        # so the details should always be coerced to a list if not already.\n        if isinstance(detail, tuple):\n            detail = list(detail)\n        elif not isinstance(detail, dict) and not isinstance(detail, list):\n            detail = [detail]\n\n        self.detail = _get_error_details(detail, code)\n```\n对于```ValidationError```错误，会强制将最后的值转换为```list```类型，这是考虑到一个```field```可能有多条不同的错误需要累积。\n\n- 序列化报错处理\n\n```python\n#rest_framework.serializers 323-346\ndef as_serializer_error(exc):\n    assert isinstance(exc, (ValidationError, DjangoValidationError))\n\n    if isinstance(exc, DjangoValidationError):\n        detail = get_error_detail(exc)\n    else:\n        detail = exc.detail\n\n    if isinstance(detail, Mapping):\n        # If errors may be a dict we use the standard {key: list of values}.\n        # Here we ensure that all the values are *lists* of errors.\n        return {\n            key: value if isinstance(value, (list, Mapping)) else [value]\n            for key, value in detail.items()\n        }\n    elif isinstance(detail, list):\n        # Errors raised as a list are non-field errors.\n        return {\n            api_settings.NON_FIELD_ERRORS_KEY: detail\n        }\n    # Errors raised as a string are non-field errors.\n    return {\n        api_settings.NON_FIELD_ERRORS_KEY: [detail]\n    }\n```\ndrf中的序列化器```serializers```，在运行```run_validation```序列化报错的过程中，会给没有列出具体字段错误的```detail```信息，即不是```dict```格式的信息，带上一个```non_field_errors```的key来标准化。\n\n### 推荐方案\n- 非400报错\n对于403，404等错误码，直接获取```detail```下的值即可\n- 400报错\n对于ValidationError错误，需要做两种处理\n  1. 单独创建，报错如下，直接识别到错误的字段\n  ```\n  {\n    \"id\": [\"Not Unique\"]\n  }\n  ```\n  2. 批量创建，报错如下，按顺序识别创建的条目的错误字段。如果为空，则说明无校验错误。\n  ```\n  [\n    {},\n    {\n      \"id\": [\"Not Unique\"]\n    },\n    {},\n    {}\n  ]\n  ```\n  此外，关于返回值为数组，需要前端进行相应处理具有多个错误信息的报错。\n### 其他方案\n根据参考方案，按照团队习惯，可以自定义```exception_handler```，以定义团队使用的错误信息格式。\n### 参考文档\n[drf-exception](https://www.django-rest-framework.org/api-guide/exceptions/#custom-exception-handling)\n","slug":"DRF-Exception","published":1,"updated":"2022-01-30T16:00:16.209Z","_id":"ckz1g9587000aclhth5x26pnk","comments":1,"photos":[],"link":"","content":"<h3 id=\"框架报错源码解析\"><a href=\"#框架报错源码解析\" class=\"headerlink\" title=\"框架报错源码解析\"></a>框架报错源码解析</h3><ul>\n<li><p>exception 处理器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rest_framework.views 71-101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exception_handler</span>(<span class=\"params\">exc, context</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Returns the response that should be used for any given exception.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    By default we handle the REST framework `APIException`, and also</span></span><br><span class=\"line\"><span class=\"string\">    Django&#x27;s built-in `Http404` and `PermissionDenied` exceptions.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Any unhandled exceptions may return `None`, which will cause a 500 error</span></span><br><span class=\"line\"><span class=\"string\">    to be raised.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc, Http404):</span><br><span class=\"line\">        exc = exceptions.NotFound()</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(exc, PermissionDenied):</span><br><span class=\"line\">        exc = exceptions.PermissionDenied()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc, exceptions.APIException):</span><br><span class=\"line\">        headers = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">getattr</span>(exc, <span class=\"string\">&#x27;auth_header&#x27;</span>, <span class=\"literal\">None</span>):</span><br><span class=\"line\">            headers[<span class=\"string\">&#x27;WWW-Authenticate&#x27;</span>] = exc.auth_header</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">getattr</span>(exc, <span class=\"string\">&#x27;wait&#x27;</span>, <span class=\"literal\">None</span>):</span><br><span class=\"line\">            headers[<span class=\"string\">&#x27;Retry-After&#x27;</span>] = <span class=\"string\">&#x27;%d&#x27;</span> % exc.wait</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc.detail, (<span class=\"built_in\">list</span>, <span class=\"built_in\">dict</span>)):</span><br><span class=\"line\">            data = exc.detail</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            data = &#123;<span class=\"string\">&#x27;detail&#x27;</span>: exc.detail&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        set_rollback()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Response(data, status=exc.status_code, headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>从处理器源码可以看到，当抛出一个<code>str</code>的错误的时候，处理器会主动为其添加一个<code>detail</code>的<code>key</code>来包裹成可以被后续处理为<code>json</code>的格式，而对于<code>list</code>与<code>dict</code>的格式，则直接返回。</p>\n</li>\n<li><p>ValidationError 处理</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#rest_framework.exceptions.ValidationError 140-158</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidationError</span>(<span class=\"params\">APIException</span>):</span></span><br><span class=\"line\">    status_code = status.HTTP_400_BAD_REQUEST</span><br><span class=\"line\">    default_detail = _(<span class=\"string\">&#x27;Invalid input.&#x27;</span>)</span><br><span class=\"line\">    default_code = <span class=\"string\">&#x27;invalid&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, detail=<span class=\"literal\">None</span>, code=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> detail <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            detail = self.default_detail</span><br><span class=\"line\">        <span class=\"keyword\">if</span> code <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            code = self.default_code</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># For validation failures, we may collect many errors together,</span></span><br><span class=\"line\">        <span class=\"comment\"># so the details should always be coerced to a list if not already.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">tuple</span>):</span><br><span class=\"line\">            detail = <span class=\"built_in\">list</span>(detail)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">dict</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">list</span>):</span><br><span class=\"line\">            detail = [detail]</span><br><span class=\"line\"></span><br><span class=\"line\">        self.detail = _get_error_details(detail, code)</span><br></pre></td></tr></table></figure>\n<p>对于<code>ValidationError</code>错误，会强制将最后的值转换为<code>list</code>类型，这是考虑到一个<code>field</code>可能有多条不同的错误需要累积。</p>\n<ul>\n<li>序列化报错处理</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#rest_framework.serializers 323-346</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">as_serializer_error</span>(<span class=\"params\">exc</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(exc, (ValidationError, DjangoValidationError))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc, DjangoValidationError):</span><br><span class=\"line\">        detail = get_error_detail(exc)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        detail = exc.detail</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(detail, Mapping):</span><br><span class=\"line\">        <span class=\"comment\"># If errors may be a dict we use the standard &#123;key: list of values&#125;.</span></span><br><span class=\"line\">        <span class=\"comment\"># Here we ensure that all the values are *lists* of errors.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            key: value <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(value, (<span class=\"built_in\">list</span>, Mapping)) <span class=\"keyword\">else</span> [value]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> detail.items()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">list</span>):</span><br><span class=\"line\">        <span class=\"comment\"># Errors raised as a list are non-field errors.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            api_settings.NON_FIELD_ERRORS_KEY: detail</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\"># Errors raised as a string are non-field errors.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        api_settings.NON_FIELD_ERRORS_KEY: [detail]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>drf中的序列化器<code>serializers</code>，在运行<code>run_validation</code>序列化报错的过程中，会给没有列出具体字段错误的<code>detail</code>信息，即不是<code>dict</code>格式的信息，带上一个<code>non_field_errors</code>的key来标准化。</p>\n<h3 id=\"推荐方案\"><a href=\"#推荐方案\" class=\"headerlink\" title=\"推荐方案\"></a>推荐方案</h3><ul>\n<li>非400报错<br>对于403，404等错误码，直接获取<code>detail</code>下的值即可</li>\n<li>400报错<br>对于ValidationError错误，需要做两种处理<ol>\n<li>单独创建，报错如下，直接识别到错误的字段<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;id&quot;: [&quot;Not Unique&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>批量创建，报错如下，按顺序识别创建的条目的错误字段。如果为空，则说明无校验错误。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;id&quot;: [&quot;Not Unique&quot;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;&#125;,</span><br><span class=\"line\">  &#123;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n此外，关于返回值为数组，需要前端进行相应处理具有多个错误信息的报错。<h3 id=\"其他方案\"><a href=\"#其他方案\" class=\"headerlink\" title=\"其他方案\"></a>其他方案</h3>根据参考方案，按照团队习惯，可以自定义<code>exception_handler</code>，以定义团队使用的错误信息格式。<h3 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h3><a href=\"https://www.django-rest-framework.org/api-guide/exceptions/#custom-exception-handling\">drf-exception</a></li>\n</ol>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"框架报错源码解析\"><a href=\"#框架报错源码解析\" class=\"headerlink\" title=\"框架报错源码解析\"></a>框架报错源码解析</h3><ul>\n<li><p>exception 处理器</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># rest_framework.views 71-101</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">exception_handler</span>(<span class=\"params\">exc, context</span>):</span></span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">    Returns the response that should be used for any given exception.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    By default we handle the REST framework `APIException`, and also</span></span><br><span class=\"line\"><span class=\"string\">    Django&#x27;s built-in `Http404` and `PermissionDenied` exceptions.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Any unhandled exceptions may return `None`, which will cause a 500 error</span></span><br><span class=\"line\"><span class=\"string\">    to be raised.</span></span><br><span class=\"line\"><span class=\"string\">    &quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc, Http404):</span><br><span class=\"line\">        exc = exceptions.NotFound()</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(exc, PermissionDenied):</span><br><span class=\"line\">        exc = exceptions.PermissionDenied()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc, exceptions.APIException):</span><br><span class=\"line\">        headers = &#123;&#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">getattr</span>(exc, <span class=\"string\">&#x27;auth_header&#x27;</span>, <span class=\"literal\">None</span>):</span><br><span class=\"line\">            headers[<span class=\"string\">&#x27;WWW-Authenticate&#x27;</span>] = exc.auth_header</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">getattr</span>(exc, <span class=\"string\">&#x27;wait&#x27;</span>, <span class=\"literal\">None</span>):</span><br><span class=\"line\">            headers[<span class=\"string\">&#x27;Retry-After&#x27;</span>] = <span class=\"string\">&#x27;%d&#x27;</span> % exc.wait</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc.detail, (<span class=\"built_in\">list</span>, <span class=\"built_in\">dict</span>)):</span><br><span class=\"line\">            data = exc.detail</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            data = &#123;<span class=\"string\">&#x27;detail&#x27;</span>: exc.detail&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        set_rollback()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Response(data, status=exc.status_code, headers=headers)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">None</span></span><br></pre></td></tr></table></figure>\n<p>从处理器源码可以看到，当抛出一个<code>str</code>的错误的时候，处理器会主动为其添加一个<code>detail</code>的<code>key</code>来包裹成可以被后续处理为<code>json</code>的格式，而对于<code>list</code>与<code>dict</code>的格式，则直接返回。</p>\n</li>\n<li><p>ValidationError 处理</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#rest_framework.exceptions.ValidationError 140-158</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ValidationError</span>(<span class=\"params\">APIException</span>):</span></span><br><span class=\"line\">    status_code = status.HTTP_400_BAD_REQUEST</span><br><span class=\"line\">    default_detail = _(<span class=\"string\">&#x27;Invalid input.&#x27;</span>)</span><br><span class=\"line\">    default_code = <span class=\"string\">&#x27;invalid&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span>(<span class=\"params\">self, detail=<span class=\"literal\">None</span>, code=<span class=\"literal\">None</span></span>):</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> detail <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            detail = self.default_detail</span><br><span class=\"line\">        <span class=\"keyword\">if</span> code <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            code = self.default_code</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># For validation failures, we may collect many errors together,</span></span><br><span class=\"line\">        <span class=\"comment\"># so the details should always be coerced to a list if not already.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">tuple</span>):</span><br><span class=\"line\">            detail = <span class=\"built_in\">list</span>(detail)</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">dict</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">list</span>):</span><br><span class=\"line\">            detail = [detail]</span><br><span class=\"line\"></span><br><span class=\"line\">        self.detail = _get_error_details(detail, code)</span><br></pre></td></tr></table></figure>\n<p>对于<code>ValidationError</code>错误，会强制将最后的值转换为<code>list</code>类型，这是考虑到一个<code>field</code>可能有多条不同的错误需要累积。</p>\n<ul>\n<li>序列化报错处理</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#rest_framework.serializers 323-346</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">as_serializer_error</span>(<span class=\"params\">exc</span>):</span></span><br><span class=\"line\">    <span class=\"keyword\">assert</span> <span class=\"built_in\">isinstance</span>(exc, (ValidationError, DjangoValidationError))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(exc, DjangoValidationError):</span><br><span class=\"line\">        detail = get_error_detail(exc)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        detail = exc.detail</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(detail, Mapping):</span><br><span class=\"line\">        <span class=\"comment\"># If errors may be a dict we use the standard &#123;key: list of values&#125;.</span></span><br><span class=\"line\">        <span class=\"comment\"># Here we ensure that all the values are *lists* of errors.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            key: value <span class=\"keyword\">if</span> <span class=\"built_in\">isinstance</span>(value, (<span class=\"built_in\">list</span>, Mapping)) <span class=\"keyword\">else</span> [value]</span><br><span class=\"line\">            <span class=\"keyword\">for</span> key, value <span class=\"keyword\">in</span> detail.items()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"keyword\">elif</span> <span class=\"built_in\">isinstance</span>(detail, <span class=\"built_in\">list</span>):</span><br><span class=\"line\">        <span class=\"comment\"># Errors raised as a list are non-field errors.</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            api_settings.NON_FIELD_ERRORS_KEY: detail</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"comment\"># Errors raised as a string are non-field errors.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        api_settings.NON_FIELD_ERRORS_KEY: [detail]</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n<p>drf中的序列化器<code>serializers</code>，在运行<code>run_validation</code>序列化报错的过程中，会给没有列出具体字段错误的<code>detail</code>信息，即不是<code>dict</code>格式的信息，带上一个<code>non_field_errors</code>的key来标准化。</p>\n<h3 id=\"推荐方案\"><a href=\"#推荐方案\" class=\"headerlink\" title=\"推荐方案\"></a>推荐方案</h3><ul>\n<li>非400报错<br>对于403，404等错误码，直接获取<code>detail</code>下的值即可</li>\n<li>400报错<br>对于ValidationError错误，需要做两种处理<ol>\n<li>单独创建，报错如下，直接识别到错误的字段<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;id&quot;: [&quot;Not Unique&quot;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>批量创建，报错如下，按顺序识别创建的条目的错误字段。如果为空，则说明无校验错误。<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[</span><br><span class=\"line\">  &#123;&#125;,</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    &quot;id&quot;: [&quot;Not Unique&quot;]</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &#123;&#125;,</span><br><span class=\"line\">  &#123;&#125;</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure>\n此外，关于返回值为数组，需要前端进行相应处理具有多个错误信息的报错。<h3 id=\"其他方案\"><a href=\"#其他方案\" class=\"headerlink\" title=\"其他方案\"></a>其他方案</h3>根据参考方案，按照团队习惯，可以自定义<code>exception_handler</code>，以定义团队使用的错误信息格式。<h3 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h3><a href=\"https://www.django-rest-framework.org/api-guide/exceptions/#custom-exception-handling\">drf-exception</a></li>\n</ol>\n</li>\n</ul>\n"},{"layout":"post","title":"突破式创新的产品设计","date":"2021-11-20T16:00:00.000Z","_content":"\n### 10倍的产品改进\n\n《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如果产品所属的市场价值极大，2-3倍的改进会引来一大群竞争者轻易的介入，这将使得产品在后续的迭代中疲于与其他竞争者斡旋，而丢失了让产品变得更好的目标。如果产品的市场价值有限，那么产品能带来的收益也有限，投入的成本也将有限，并很难再继续做大。事实上，有相当一部分产品的推出，比原来的产品带来的改进少于其带来的麻烦。这样的产品，基本很难吸引到用户。俞军提出的产品价值公式可以很好诠释这一点，即`新产品价值 > 旧产品价值 + 迁移成本`，这样的新产品才有可能成功。\n\n一款产品想要在推出的时候，占领并持续垄断市场，需要十倍的产品改进。这里我们不细谈市场是否存在，假设已经经过足够的调研验证市场确实存在。如同我们使用微信，很难有新一款社交工具可以打败。\n\n10倍的改进不只在于产品功能本身，还有其交互体验，产品性能与稳定。chrome关于其核心原则的介绍，可以很好的指导10倍的改进。\n\n10倍的改进本身并不容易衡量。但是我们可以从以下几个点去判断：\n- 技术不可替代\n- 交互更加简单\n- 稳定性更佳\n- 交互反应更加快速\n\n此外，安全性不在这里提出，但是也越来越重要，越来越成为一款产品是否“改进”的判断标准之一。\n\n“MVP法则”本身并没有问题，但是很多人在定义minimum value的时候，往往只抓住了某个核心需求即快速的进行产品设计，开发者也只专注于实现核心功能而不考虑优化。当用户有多个价值需求的时候，技术不满足、产品没有完成设计，会让用户体验不佳而造成初始不良印象，甚至放弃使用该产品。而用户对产品的不良反馈将会严重打击产品迭代的积极性。除非产品经理与开发者能认识到自身的不足。更可惜的是，着急推出的可能可以创造改变但是设计不良的产品，无异于让竞争者快速入场并将自己打到。\n\n一款“MVP”产品，应该在一开始就具备建立垄断的能力。Apple产品、Chrome、微信都是如此。即使后来的各种移动端设备、浏览器(包括app内建的浏览器如微信搜索)、社交工具，都无法撼动。Apple在近些年不断被挑战，也是因为其仅做的2-3倍的改进，让华为、小米等竞争者可以快速完成替代，并在其他方面创造竞争力。尽管不足以将Apple踢出竞争环境，但是也不断在蚕食其市场。而其他踢出竞争环境的产品包括Firefox、柯达等。\n\n要做到10倍的改进行，需要深耕技术基础的工程师，准确理解用户需求的产品经理。\n\n要做到看起来很难，事实也是如此。而最基本的方法是，每一次做技术设计或产品设计的时候，都问自己，\n- 有没有理解不到位的地方？\n- 有没有更好的解决方法？\n- 不调整设计减少的成本和收益比是否可以承受？\n\n","source":"_posts/breaking-creation-product.md","raw":"---\nlayout: post\ntitle: 突破式创新的产品设计\ndate: 2021-11-21\n---\n\n### 10倍的产品改进\n\n《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如果产品所属的市场价值极大，2-3倍的改进会引来一大群竞争者轻易的介入，这将使得产品在后续的迭代中疲于与其他竞争者斡旋，而丢失了让产品变得更好的目标。如果产品的市场价值有限，那么产品能带来的收益也有限，投入的成本也将有限，并很难再继续做大。事实上，有相当一部分产品的推出，比原来的产品带来的改进少于其带来的麻烦。这样的产品，基本很难吸引到用户。俞军提出的产品价值公式可以很好诠释这一点，即`新产品价值 > 旧产品价值 + 迁移成本`，这样的新产品才有可能成功。\n\n一款产品想要在推出的时候，占领并持续垄断市场，需要十倍的产品改进。这里我们不细谈市场是否存在，假设已经经过足够的调研验证市场确实存在。如同我们使用微信，很难有新一款社交工具可以打败。\n\n10倍的改进不只在于产品功能本身，还有其交互体验，产品性能与稳定。chrome关于其核心原则的介绍，可以很好的指导10倍的改进。\n\n10倍的改进本身并不容易衡量。但是我们可以从以下几个点去判断：\n- 技术不可替代\n- 交互更加简单\n- 稳定性更佳\n- 交互反应更加快速\n\n此外，安全性不在这里提出，但是也越来越重要，越来越成为一款产品是否“改进”的判断标准之一。\n\n“MVP法则”本身并没有问题，但是很多人在定义minimum value的时候，往往只抓住了某个核心需求即快速的进行产品设计，开发者也只专注于实现核心功能而不考虑优化。当用户有多个价值需求的时候，技术不满足、产品没有完成设计，会让用户体验不佳而造成初始不良印象，甚至放弃使用该产品。而用户对产品的不良反馈将会严重打击产品迭代的积极性。除非产品经理与开发者能认识到自身的不足。更可惜的是，着急推出的可能可以创造改变但是设计不良的产品，无异于让竞争者快速入场并将自己打到。\n\n一款“MVP”产品，应该在一开始就具备建立垄断的能力。Apple产品、Chrome、微信都是如此。即使后来的各种移动端设备、浏览器(包括app内建的浏览器如微信搜索)、社交工具，都无法撼动。Apple在近些年不断被挑战，也是因为其仅做的2-3倍的改进，让华为、小米等竞争者可以快速完成替代，并在其他方面创造竞争力。尽管不足以将Apple踢出竞争环境，但是也不断在蚕食其市场。而其他踢出竞争环境的产品包括Firefox、柯达等。\n\n要做到10倍的改进行，需要深耕技术基础的工程师，准确理解用户需求的产品经理。\n\n要做到看起来很难，事实也是如此。而最基本的方法是，每一次做技术设计或产品设计的时候，都问自己，\n- 有没有理解不到位的地方？\n- 有没有更好的解决方法？\n- 不调整设计减少的成本和收益比是否可以承受？\n\n","slug":"breaking-creation-product","published":1,"updated":"2022-01-30T16:01:03.540Z","_id":"ckz1gacvs000cclht0b2agor6","comments":1,"photos":[],"link":"","content":"<h3 id=\"10倍的产品改进\"><a href=\"#10倍的产品改进\" class=\"headerlink\" title=\"10倍的产品改进\"></a>10倍的产品改进</h3><p>《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如果产品所属的市场价值极大，2-3倍的改进会引来一大群竞争者轻易的介入，这将使得产品在后续的迭代中疲于与其他竞争者斡旋，而丢失了让产品变得更好的目标。如果产品的市场价值有限，那么产品能带来的收益也有限，投入的成本也将有限，并很难再继续做大。事实上，有相当一部分产品的推出，比原来的产品带来的改进少于其带来的麻烦。这样的产品，基本很难吸引到用户。俞军提出的产品价值公式可以很好诠释这一点，即<code>新产品价值 &gt; 旧产品价值 + 迁移成本</code>，这样的新产品才有可能成功。</p>\n<p>一款产品想要在推出的时候，占领并持续垄断市场，需要十倍的产品改进。这里我们不细谈市场是否存在，假设已经经过足够的调研验证市场确实存在。如同我们使用微信，很难有新一款社交工具可以打败。</p>\n<p>10倍的改进不只在于产品功能本身，还有其交互体验，产品性能与稳定。chrome关于其核心原则的介绍，可以很好的指导10倍的改进。</p>\n<p>10倍的改进本身并不容易衡量。但是我们可以从以下几个点去判断：</p>\n<ul>\n<li>技术不可替代</li>\n<li>交互更加简单</li>\n<li>稳定性更佳</li>\n<li>交互反应更加快速</li>\n</ul>\n<p>此外，安全性不在这里提出，但是也越来越重要，越来越成为一款产品是否“改进”的判断标准之一。</p>\n<p>“MVP法则”本身并没有问题，但是很多人在定义minimum value的时候，往往只抓住了某个核心需求即快速的进行产品设计，开发者也只专注于实现核心功能而不考虑优化。当用户有多个价值需求的时候，技术不满足、产品没有完成设计，会让用户体验不佳而造成初始不良印象，甚至放弃使用该产品。而用户对产品的不良反馈将会严重打击产品迭代的积极性。除非产品经理与开发者能认识到自身的不足。更可惜的是，着急推出的可能可以创造改变但是设计不良的产品，无异于让竞争者快速入场并将自己打到。</p>\n<p>一款“MVP”产品，应该在一开始就具备建立垄断的能力。Apple产品、Chrome、微信都是如此。即使后来的各种移动端设备、浏览器(包括app内建的浏览器如微信搜索)、社交工具，都无法撼动。Apple在近些年不断被挑战，也是因为其仅做的2-3倍的改进，让华为、小米等竞争者可以快速完成替代，并在其他方面创造竞争力。尽管不足以将Apple踢出竞争环境，但是也不断在蚕食其市场。而其他踢出竞争环境的产品包括Firefox、柯达等。</p>\n<p>要做到10倍的改进行，需要深耕技术基础的工程师，准确理解用户需求的产品经理。</p>\n<p>要做到看起来很难，事实也是如此。而最基本的方法是，每一次做技术设计或产品设计的时候，都问自己，</p>\n<ul>\n<li>有没有理解不到位的地方？</li>\n<li>有没有更好的解决方法？</li>\n<li>不调整设计减少的成本和收益比是否可以承受？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"10倍的产品改进\"><a href=\"#10倍的产品改进\" class=\"headerlink\" title=\"10倍的产品改进\"></a>10倍的产品改进</h3><p>《从0到1》介绍了一款产品的推出，如果只是2-3倍的改进，可能可以在一开始吸引用户去使用。如果产品所属的市场价值极大，2-3倍的改进会引来一大群竞争者轻易的介入，这将使得产品在后续的迭代中疲于与其他竞争者斡旋，而丢失了让产品变得更好的目标。如果产品的市场价值有限，那么产品能带来的收益也有限，投入的成本也将有限，并很难再继续做大。事实上，有相当一部分产品的推出，比原来的产品带来的改进少于其带来的麻烦。这样的产品，基本很难吸引到用户。俞军提出的产品价值公式可以很好诠释这一点，即<code>新产品价值 &gt; 旧产品价值 + 迁移成本</code>，这样的新产品才有可能成功。</p>\n<p>一款产品想要在推出的时候，占领并持续垄断市场，需要十倍的产品改进。这里我们不细谈市场是否存在，假设已经经过足够的调研验证市场确实存在。如同我们使用微信，很难有新一款社交工具可以打败。</p>\n<p>10倍的改进不只在于产品功能本身，还有其交互体验，产品性能与稳定。chrome关于其核心原则的介绍，可以很好的指导10倍的改进。</p>\n<p>10倍的改进本身并不容易衡量。但是我们可以从以下几个点去判断：</p>\n<ul>\n<li>技术不可替代</li>\n<li>交互更加简单</li>\n<li>稳定性更佳</li>\n<li>交互反应更加快速</li>\n</ul>\n<p>此外，安全性不在这里提出，但是也越来越重要，越来越成为一款产品是否“改进”的判断标准之一。</p>\n<p>“MVP法则”本身并没有问题，但是很多人在定义minimum value的时候，往往只抓住了某个核心需求即快速的进行产品设计，开发者也只专注于实现核心功能而不考虑优化。当用户有多个价值需求的时候，技术不满足、产品没有完成设计，会让用户体验不佳而造成初始不良印象，甚至放弃使用该产品。而用户对产品的不良反馈将会严重打击产品迭代的积极性。除非产品经理与开发者能认识到自身的不足。更可惜的是，着急推出的可能可以创造改变但是设计不良的产品，无异于让竞争者快速入场并将自己打到。</p>\n<p>一款“MVP”产品，应该在一开始就具备建立垄断的能力。Apple产品、Chrome、微信都是如此。即使后来的各种移动端设备、浏览器(包括app内建的浏览器如微信搜索)、社交工具，都无法撼动。Apple在近些年不断被挑战，也是因为其仅做的2-3倍的改进，让华为、小米等竞争者可以快速完成替代，并在其他方面创造竞争力。尽管不足以将Apple踢出竞争环境，但是也不断在蚕食其市场。而其他踢出竞争环境的产品包括Firefox、柯达等。</p>\n<p>要做到10倍的改进行，需要深耕技术基础的工程师，准确理解用户需求的产品经理。</p>\n<p>要做到看起来很难，事实也是如此。而最基本的方法是，每一次做技术设计或产品设计的时候，都问自己，</p>\n<ul>\n<li>有没有理解不到位的地方？</li>\n<li>有没有更好的解决方法？</li>\n<li>不调整设计减少的成本和收益比是否可以承受？</li>\n</ul>\n"},{"layout":"post","title":"如何撰写技术设计文档","date":"2021-12-15T16:00:00.000Z","_content":"\n### 前言\n\n架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在解决的问题，以及方案的设计思路。\n\n### 为什么要写设计文档\n- 要解决的问题是什么需要用文档先介绍清楚\n- 有些问题使用一份设计文档描述思路已经足够\n- 解决方案的选择（decision）是权衡的结果，我们不仅需要了解结果，也需要知道结果产生的原因，即权衡的过程。只有记录下权衡的过程，在后续偿还技术债的时候，才可以更方便的理解产生的原因或初衷，并有更充分的执行架构演进的依据\n- 让团队成员对问题和设计有一个共识\n\n### 设计文档核心内容\n\n基于以上原因，我们也可以推论出，设计文档所需要具备的核心内容：\n- 问题的上下文。一个问题需要解决，自然需要关于该问题的上下文内容。\n- 想要达成的目标是什么\n- 哪些不是我们的目标\n  如果在讨论与设计过程中，发现一些可能会对设计带来干扰，但是明确不是当前要解决的目标，需要记录下来，以便团队对此形成共识\n- 权衡的过程\n  - 为什么选择某个方案\n  - 为什么不选择某个方案\n    如果对于某一个方案，有十分明确的不使用的原因，尤其是行业有充分的应用经验而设计的时候考虑不使用的时候，需要将其记录下来，作为权衡的参考，以避免后续团队演进设计的时候，朝着原先不选择的方案前进。\n  - 当前的一个或多个方案有什么条件限制或成本考虑\n  - 收益是如何的，创造的价值是什么\n\n\n### 什么时候写设计文档\n\n**在着手实现之前，先完成设计文档的撰写与迭代。**\n\n不要试图等到将功能实现之后在补充文档。开发者喜欢写代码甚于写文档。对于开发者来说，在文档中描述某种架构实现方案，不如实现一个demo来演示该方案。当开始写demo之后，很可能就会开始将demo做修修补补，最后完成一份可上线代码。当代码完成之后，除非有某种强制推力要求自己必须完成，或是为了向多个团队或个人介绍自己的方案而减少\n\n在实现之前，完成设计文档的撰写与迭代，可以持续的思考自己的设计的缺陷，并记录下来\n\n设计文档的基本写作步骤：  \n打草稿 -> 重写 -> 重写 -> 重写 -> 重写 -> ...\n- 需求持续在变\n- 有新的设计想法或方案\n- 有新的condition或constraint出现，需要调整设计\n\n### 写文档是一件有趣的事情\n\n写文档，犹如在将学习理解掌握的事情，再向其他人介绍与论述，以寻求与他人的共鸣。我们在白板前讨论的问题，在讨论完毕之后就会被擦除；我们编写的代码，会因为各种需求的变化而被调整（感谢svn让我们可以回顾第一行代码）。而文档，在未来的某一天，仍旧将有人会来翻阅，如同著书立说，言论可能会过时，但是却是在当下时代的最佳产物。\n\n### 参考\n\n[Design Docs at Google](https://www.industrialempathy.com/posts/design-docs-at-google/)\n\n[Scaling Engineering Teams via RFCs: Writing Things Down](https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/)\n\n\n\n","source":"_posts/software-design-doc.md","raw":"---\nlayout: post\ntitle: 如何撰写技术设计文档\ndate: 2021-12-16\n---\n\n### 前言\n\n架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在解决的问题，以及方案的设计思路。\n\n### 为什么要写设计文档\n- 要解决的问题是什么需要用文档先介绍清楚\n- 有些问题使用一份设计文档描述思路已经足够\n- 解决方案的选择（decision）是权衡的结果，我们不仅需要了解结果，也需要知道结果产生的原因，即权衡的过程。只有记录下权衡的过程，在后续偿还技术债的时候，才可以更方便的理解产生的原因或初衷，并有更充分的执行架构演进的依据\n- 让团队成员对问题和设计有一个共识\n\n### 设计文档核心内容\n\n基于以上原因，我们也可以推论出，设计文档所需要具备的核心内容：\n- 问题的上下文。一个问题需要解决，自然需要关于该问题的上下文内容。\n- 想要达成的目标是什么\n- 哪些不是我们的目标\n  如果在讨论与设计过程中，发现一些可能会对设计带来干扰，但是明确不是当前要解决的目标，需要记录下来，以便团队对此形成共识\n- 权衡的过程\n  - 为什么选择某个方案\n  - 为什么不选择某个方案\n    如果对于某一个方案，有十分明确的不使用的原因，尤其是行业有充分的应用经验而设计的时候考虑不使用的时候，需要将其记录下来，作为权衡的参考，以避免后续团队演进设计的时候，朝着原先不选择的方案前进。\n  - 当前的一个或多个方案有什么条件限制或成本考虑\n  - 收益是如何的，创造的价值是什么\n\n\n### 什么时候写设计文档\n\n**在着手实现之前，先完成设计文档的撰写与迭代。**\n\n不要试图等到将功能实现之后在补充文档。开发者喜欢写代码甚于写文档。对于开发者来说，在文档中描述某种架构实现方案，不如实现一个demo来演示该方案。当开始写demo之后，很可能就会开始将demo做修修补补，最后完成一份可上线代码。当代码完成之后，除非有某种强制推力要求自己必须完成，或是为了向多个团队或个人介绍自己的方案而减少\n\n在实现之前，完成设计文档的撰写与迭代，可以持续的思考自己的设计的缺陷，并记录下来\n\n设计文档的基本写作步骤：  \n打草稿 -> 重写 -> 重写 -> 重写 -> 重写 -> ...\n- 需求持续在变\n- 有新的设计想法或方案\n- 有新的condition或constraint出现，需要调整设计\n\n### 写文档是一件有趣的事情\n\n写文档，犹如在将学习理解掌握的事情，再向其他人介绍与论述，以寻求与他人的共鸣。我们在白板前讨论的问题，在讨论完毕之后就会被擦除；我们编写的代码，会因为各种需求的变化而被调整（感谢svn让我们可以回顾第一行代码）。而文档，在未来的某一天，仍旧将有人会来翻阅，如同著书立说，言论可能会过时，但是却是在当下时代的最佳产物。\n\n### 参考\n\n[Design Docs at Google](https://www.industrialempathy.com/posts/design-docs-at-google/)\n\n[Scaling Engineering Teams via RFCs: Writing Things Down](https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/)\n\n\n\n","slug":"software-design-doc","published":1,"updated":"2022-01-30T16:01:38.008Z","_id":"ckz1gaz6q000dclhtebux0om1","comments":1,"photos":[],"link":"","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在解决的问题，以及方案的设计思路。</p>\n<h3 id=\"为什么要写设计文档\"><a href=\"#为什么要写设计文档\" class=\"headerlink\" title=\"为什么要写设计文档\"></a>为什么要写设计文档</h3><ul>\n<li>要解决的问题是什么需要用文档先介绍清楚</li>\n<li>有些问题使用一份设计文档描述思路已经足够</li>\n<li>解决方案的选择（decision）是权衡的结果，我们不仅需要了解结果，也需要知道结果产生的原因，即权衡的过程。只有记录下权衡的过程，在后续偿还技术债的时候，才可以更方便的理解产生的原因或初衷，并有更充分的执行架构演进的依据</li>\n<li>让团队成员对问题和设计有一个共识</li>\n</ul>\n<h3 id=\"设计文档核心内容\"><a href=\"#设计文档核心内容\" class=\"headerlink\" title=\"设计文档核心内容\"></a>设计文档核心内容</h3><p>基于以上原因，我们也可以推论出，设计文档所需要具备的核心内容：</p>\n<ul>\n<li>问题的上下文。一个问题需要解决，自然需要关于该问题的上下文内容。</li>\n<li>想要达成的目标是什么</li>\n<li>哪些不是我们的目标<br>如果在讨论与设计过程中，发现一些可能会对设计带来干扰，但是明确不是当前要解决的目标，需要记录下来，以便团队对此形成共识</li>\n<li>权衡的过程<ul>\n<li>为什么选择某个方案</li>\n<li>为什么不选择某个方案<br>如果对于某一个方案，有十分明确的不使用的原因，尤其是行业有充分的应用经验而设计的时候考虑不使用的时候，需要将其记录下来，作为权衡的参考，以避免后续团队演进设计的时候，朝着原先不选择的方案前进。</li>\n<li>当前的一个或多个方案有什么条件限制或成本考虑</li>\n<li>收益是如何的，创造的价值是什么</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么时候写设计文档\"><a href=\"#什么时候写设计文档\" class=\"headerlink\" title=\"什么时候写设计文档\"></a>什么时候写设计文档</h3><p><strong>在着手实现之前，先完成设计文档的撰写与迭代。</strong></p>\n<p>不要试图等到将功能实现之后在补充文档。开发者喜欢写代码甚于写文档。对于开发者来说，在文档中描述某种架构实现方案，不如实现一个demo来演示该方案。当开始写demo之后，很可能就会开始将demo做修修补补，最后完成一份可上线代码。当代码完成之后，除非有某种强制推力要求自己必须完成，或是为了向多个团队或个人介绍自己的方案而减少</p>\n<p>在实现之前，完成设计文档的撰写与迭代，可以持续的思考自己的设计的缺陷，并记录下来</p>\n<p>设计文档的基本写作步骤：<br>打草稿 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; …</p>\n<ul>\n<li>需求持续在变</li>\n<li>有新的设计想法或方案</li>\n<li>有新的condition或constraint出现，需要调整设计</li>\n</ul>\n<h3 id=\"写文档是一件有趣的事情\"><a href=\"#写文档是一件有趣的事情\" class=\"headerlink\" title=\"写文档是一件有趣的事情\"></a>写文档是一件有趣的事情</h3><p>写文档，犹如在将学习理解掌握的事情，再向其他人介绍与论述，以寻求与他人的共鸣。我们在白板前讨论的问题，在讨论完毕之后就会被擦除；我们编写的代码，会因为各种需求的变化而被调整（感谢svn让我们可以回顾第一行代码）。而文档，在未来的某一天，仍旧将有人会来翻阅，如同著书立说，言论可能会过时，但是却是在当下时代的最佳产物。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.industrialempathy.com/posts/design-docs-at-google/\">Design Docs at Google</a></p>\n<p><a href=\"https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/\">Scaling Engineering Teams via RFCs: Writing Things Down</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>架构设计与编码，是为了解决问题，是一套解决方案。当我们在设计架构和代码开发的时候，有一份相对应的设计文档，可以有效且快速的让团队更好的理解在解决的问题，以及方案的设计思路。</p>\n<h3 id=\"为什么要写设计文档\"><a href=\"#为什么要写设计文档\" class=\"headerlink\" title=\"为什么要写设计文档\"></a>为什么要写设计文档</h3><ul>\n<li>要解决的问题是什么需要用文档先介绍清楚</li>\n<li>有些问题使用一份设计文档描述思路已经足够</li>\n<li>解决方案的选择（decision）是权衡的结果，我们不仅需要了解结果，也需要知道结果产生的原因，即权衡的过程。只有记录下权衡的过程，在后续偿还技术债的时候，才可以更方便的理解产生的原因或初衷，并有更充分的执行架构演进的依据</li>\n<li>让团队成员对问题和设计有一个共识</li>\n</ul>\n<h3 id=\"设计文档核心内容\"><a href=\"#设计文档核心内容\" class=\"headerlink\" title=\"设计文档核心内容\"></a>设计文档核心内容</h3><p>基于以上原因，我们也可以推论出，设计文档所需要具备的核心内容：</p>\n<ul>\n<li>问题的上下文。一个问题需要解决，自然需要关于该问题的上下文内容。</li>\n<li>想要达成的目标是什么</li>\n<li>哪些不是我们的目标<br>如果在讨论与设计过程中，发现一些可能会对设计带来干扰，但是明确不是当前要解决的目标，需要记录下来，以便团队对此形成共识</li>\n<li>权衡的过程<ul>\n<li>为什么选择某个方案</li>\n<li>为什么不选择某个方案<br>如果对于某一个方案，有十分明确的不使用的原因，尤其是行业有充分的应用经验而设计的时候考虑不使用的时候，需要将其记录下来，作为权衡的参考，以避免后续团队演进设计的时候，朝着原先不选择的方案前进。</li>\n<li>当前的一个或多个方案有什么条件限制或成本考虑</li>\n<li>收益是如何的，创造的价值是什么</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"什么时候写设计文档\"><a href=\"#什么时候写设计文档\" class=\"headerlink\" title=\"什么时候写设计文档\"></a>什么时候写设计文档</h3><p><strong>在着手实现之前，先完成设计文档的撰写与迭代。</strong></p>\n<p>不要试图等到将功能实现之后在补充文档。开发者喜欢写代码甚于写文档。对于开发者来说，在文档中描述某种架构实现方案，不如实现一个demo来演示该方案。当开始写demo之后，很可能就会开始将demo做修修补补，最后完成一份可上线代码。当代码完成之后，除非有某种强制推力要求自己必须完成，或是为了向多个团队或个人介绍自己的方案而减少</p>\n<p>在实现之前，完成设计文档的撰写与迭代，可以持续的思考自己的设计的缺陷，并记录下来</p>\n<p>设计文档的基本写作步骤：<br>打草稿 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; 重写 -&gt; …</p>\n<ul>\n<li>需求持续在变</li>\n<li>有新的设计想法或方案</li>\n<li>有新的condition或constraint出现，需要调整设计</li>\n</ul>\n<h3 id=\"写文档是一件有趣的事情\"><a href=\"#写文档是一件有趣的事情\" class=\"headerlink\" title=\"写文档是一件有趣的事情\"></a>写文档是一件有趣的事情</h3><p>写文档，犹如在将学习理解掌握的事情，再向其他人介绍与论述，以寻求与他人的共鸣。我们在白板前讨论的问题，在讨论完毕之后就会被擦除；我们编写的代码，会因为各种需求的变化而被调整（感谢svn让我们可以回顾第一行代码）。而文档，在未来的某一天，仍旧将有人会来翻阅，如同著书立说，言论可能会过时，但是却是在当下时代的最佳产物。</p>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><p><a href=\"https://www.industrialempathy.com/posts/design-docs-at-google/\">Design Docs at Google</a></p>\n<p><a href=\"https://blog.pragmaticengineer.com/scaling-engineering-teams-via-writing-things-down-rfcs/\">Scaling Engineering Teams via RFCs: Writing Things Down</a></p>\n"},{"layout":"post","title":"知识掌握的广度与深度","date":"2022-01-29T16:00:00.000Z","_content":"\n### 什么是广度与深度\n\n想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟hr交流的时候，或者跟领导、行业大佬交流的时候，也经常会听到这样的建议：“要做一名T/π型人才”。\n\n那么，广度要怎么理解，深度又要怎么理解呢。我们掌握了一些知识或者信息，需要达到一个什么程度，算是覆盖了广度，或是达到了深度。\n\n我个人的感受是，当我们对知识、信息达到了，\n- **能够理解其中的原理与逻辑，同时能够自己进行复述**，则算是达到了广度的覆盖\n- **能够机遇已有的信息，思考其深层次的逻辑，举一反三的实践或思考总结，并能达到一定效果**，则算是深度的掌握。\n\n我们每天会浏览五花八门的信息，会folloe各种博客阅读新的思想。多数时候，我们以为我们已经了解其中的相关内容，其实我们仅限于“知道“。我们没有能够梳理其中的逻辑，也更无可能无法复述其中的逻辑。**但是没有关系，因为我们的时间有限，不可能对大多数信息都能完整了解。** 对于我们需要去了解的领域，则需要做到”广度式“的了解。比如很多人打王者荣耀，有的人只是消磨时间，有的人则会去了解每个英雄的连招、出装、阵容搭配等等。前者算不得广度，即不能在相亲介绍中的兴趣爱好栏写打王者荣耀，顶多只能写无聊时打打王者。做到深度掌握打王者打同学，则要摸清楚某个英雄的各种细节，在各种场景中如何操作。\n\n当然，具体要掌握到什么程度，取决于自己。比如我，就只是无聊时打打王者。\n\n### 如何达到广度与深度\n\n我曾经咨询过一位架构师，聊“如何覆盖技术的广度与深度”。在我的工作内容中，甚少会接触大数据工程，也没有直接接触AI项目（两大当前热门“泡沫”领域），我如何让我的技术覆盖到那里呢。我收到的回答是：“当你需要的时候，你自然会去学习去了解。”\n\n需要的时候，是一个很有趣的描述。什么是需要的时候，想“知道”一下，方便吹牛的时候扯扯专业名词；想“了解”一下，虽然用不到但是可以学一学原理；想“挖掘”一下，在某个项目中应用。还有其他的各种情况，都会成为需要的时候。\n\n在当前的互联网时代，要达到知识掌握的广度，其实不难。要了解一个领域的知识，有各种各样的搜索引擎和问答社区，可以找到资料。无论是否正确，逻辑总能在一定程度上自洽。要找到不自洽的点，当然需要更深入的学习理解了。如同狼人杀发言，论述粗看一定有道理，至于是不是真的合理，就需要高级玩家才能分辨出来。\n\n### 有计划的拓展广度和深度\n\n虎年马上要到来，也是2022年的一月份，很多人都会给自己做计划，也有很多人没有什么特别的计划。计划的执行可能也都不一样。我十分建议，能够为自己的知识的广度与深度的拓展做足计划，且最好是有长时与短时计划。也许有的人不知道未来三五年自己会做什么，但是大家多少都有一个方向，或者有些兴趣点。\n\n有计划的去拓展和达成，可以让自己持续的达到某些里程碑，从而持续对自己形成正向激励。 ","source":"_posts/knowledge-breath-and-depth.md","raw":"---\nlayout: post\ntitle: 知识掌握的广度与深度\ndate: 2022/01/30\n---\n\n### 什么是广度与深度\n\n想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟hr交流的时候，或者跟领导、行业大佬交流的时候，也经常会听到这样的建议：“要做一名T/π型人才”。\n\n那么，广度要怎么理解，深度又要怎么理解呢。我们掌握了一些知识或者信息，需要达到一个什么程度，算是覆盖了广度，或是达到了深度。\n\n我个人的感受是，当我们对知识、信息达到了，\n- **能够理解其中的原理与逻辑，同时能够自己进行复述**，则算是达到了广度的覆盖\n- **能够机遇已有的信息，思考其深层次的逻辑，举一反三的实践或思考总结，并能达到一定效果**，则算是深度的掌握。\n\n我们每天会浏览五花八门的信息，会folloe各种博客阅读新的思想。多数时候，我们以为我们已经了解其中的相关内容，其实我们仅限于“知道“。我们没有能够梳理其中的逻辑，也更无可能无法复述其中的逻辑。**但是没有关系，因为我们的时间有限，不可能对大多数信息都能完整了解。** 对于我们需要去了解的领域，则需要做到”广度式“的了解。比如很多人打王者荣耀，有的人只是消磨时间，有的人则会去了解每个英雄的连招、出装、阵容搭配等等。前者算不得广度，即不能在相亲介绍中的兴趣爱好栏写打王者荣耀，顶多只能写无聊时打打王者。做到深度掌握打王者打同学，则要摸清楚某个英雄的各种细节，在各种场景中如何操作。\n\n当然，具体要掌握到什么程度，取决于自己。比如我，就只是无聊时打打王者。\n\n### 如何达到广度与深度\n\n我曾经咨询过一位架构师，聊“如何覆盖技术的广度与深度”。在我的工作内容中，甚少会接触大数据工程，也没有直接接触AI项目（两大当前热门“泡沫”领域），我如何让我的技术覆盖到那里呢。我收到的回答是：“当你需要的时候，你自然会去学习去了解。”\n\n需要的时候，是一个很有趣的描述。什么是需要的时候，想“知道”一下，方便吹牛的时候扯扯专业名词；想“了解”一下，虽然用不到但是可以学一学原理；想“挖掘”一下，在某个项目中应用。还有其他的各种情况，都会成为需要的时候。\n\n在当前的互联网时代，要达到知识掌握的广度，其实不难。要了解一个领域的知识，有各种各样的搜索引擎和问答社区，可以找到资料。无论是否正确，逻辑总能在一定程度上自洽。要找到不自洽的点，当然需要更深入的学习理解了。如同狼人杀发言，论述粗看一定有道理，至于是不是真的合理，就需要高级玩家才能分辨出来。\n\n### 有计划的拓展广度和深度\n\n虎年马上要到来，也是2022年的一月份，很多人都会给自己做计划，也有很多人没有什么特别的计划。计划的执行可能也都不一样。我十分建议，能够为自己的知识的广度与深度的拓展做足计划，且最好是有长时与短时计划。也许有的人不知道未来三五年自己会做什么，但是大家多少都有一个方向，或者有些兴趣点。\n\n有计划的去拓展和达成，可以让自己持续的达到某些里程碑，从而持续对自己形成正向激励。 ","slug":"knowledge-breath-and-depth","published":1,"updated":"2022-01-30T16:55:23.397Z","_id":"ckz1hwvvw0000a5ht3nzk0pcn","comments":1,"photos":[],"link":"","content":"<h3 id=\"什么是广度与深度\"><a href=\"#什么是广度与深度\" class=\"headerlink\" title=\"什么是广度与深度\"></a>什么是广度与深度</h3><p>想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟hr交流的时候，或者跟领导、行业大佬交流的时候，也经常会听到这样的建议：“要做一名T&#x2F;π型人才”。</p>\n<p>那么，广度要怎么理解，深度又要怎么理解呢。我们掌握了一些知识或者信息，需要达到一个什么程度，算是覆盖了广度，或是达到了深度。</p>\n<p>我个人的感受是，当我们对知识、信息达到了，</p>\n<ul>\n<li><strong>能够理解其中的原理与逻辑，同时能够自己进行复述</strong>，则算是达到了广度的覆盖</li>\n<li><strong>能够机遇已有的信息，思考其深层次的逻辑，举一反三的实践或思考总结，并能达到一定效果</strong>，则算是深度的掌握。</li>\n</ul>\n<p>我们每天会浏览五花八门的信息，会folloe各种博客阅读新的思想。多数时候，我们以为我们已经了解其中的相关内容，其实我们仅限于“知道“。我们没有能够梳理其中的逻辑，也更无可能无法复述其中的逻辑。<strong>但是没有关系，因为我们的时间有限，不可能对大多数信息都能完整了解。</strong> 对于我们需要去了解的领域，则需要做到”广度式“的了解。比如很多人打王者荣耀，有的人只是消磨时间，有的人则会去了解每个英雄的连招、出装、阵容搭配等等。前者算不得广度，即不能在相亲介绍中的兴趣爱好栏写打王者荣耀，顶多只能写无聊时打打王者。做到深度掌握打王者打同学，则要摸清楚某个英雄的各种细节，在各种场景中如何操作。</p>\n<p>当然，具体要掌握到什么程度，取决于自己。比如我，就只是无聊时打打王者。</p>\n<h3 id=\"如何达到广度与深度\"><a href=\"#如何达到广度与深度\" class=\"headerlink\" title=\"如何达到广度与深度\"></a>如何达到广度与深度</h3><p>我曾经咨询过一位架构师，聊“如何覆盖技术的广度与深度”。在我的工作内容中，甚少会接触大数据工程，也没有直接接触AI项目（两大当前热门“泡沫”领域），我如何让我的技术覆盖到那里呢。我收到的回答是：“当你需要的时候，你自然会去学习去了解。”</p>\n<p>需要的时候，是一个很有趣的描述。什么是需要的时候，想“知道”一下，方便吹牛的时候扯扯专业名词；想“了解”一下，虽然用不到但是可以学一学原理；想“挖掘”一下，在某个项目中应用。还有其他的各种情况，都会成为需要的时候。</p>\n<p>在当前的互联网时代，要达到知识掌握的广度，其实不难。要了解一个领域的知识，有各种各样的搜索引擎和问答社区，可以找到资料。无论是否正确，逻辑总能在一定程度上自洽。要找到不自洽的点，当然需要更深入的学习理解了。如同狼人杀发言，论述粗看一定有道理，至于是不是真的合理，就需要高级玩家才能分辨出来。</p>\n<h3 id=\"有计划的拓展广度和深度\"><a href=\"#有计划的拓展广度和深度\" class=\"headerlink\" title=\"有计划的拓展广度和深度\"></a>有计划的拓展广度和深度</h3><p>虎年马上要到来，也是2022年的一月份，很多人都会给自己做计划，也有很多人没有什么特别的计划。计划的执行可能也都不一样。我十分建议，能够为自己的知识的广度与深度的拓展做足计划，且最好是有长时与短时计划。也许有的人不知道未来三五年自己会做什么，但是大家多少都有一个方向，或者有些兴趣点。</p>\n<p>有计划的去拓展和达成，可以让自己持续的达到某些里程碑，从而持续对自己形成正向激励。 </p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是广度与深度\"><a href=\"#什么是广度与深度\" class=\"headerlink\" title=\"什么是广度与深度\"></a>什么是广度与深度</h3><p>想要想做一名架构师的同学，大都会听到一句话：“一名架构师要有技术的广度与深度”。很多同学在跟hr交流的时候，或者跟领导、行业大佬交流的时候，也经常会听到这样的建议：“要做一名T&#x2F;π型人才”。</p>\n<p>那么，广度要怎么理解，深度又要怎么理解呢。我们掌握了一些知识或者信息，需要达到一个什么程度，算是覆盖了广度，或是达到了深度。</p>\n<p>我个人的感受是，当我们对知识、信息达到了，</p>\n<ul>\n<li><strong>能够理解其中的原理与逻辑，同时能够自己进行复述</strong>，则算是达到了广度的覆盖</li>\n<li><strong>能够机遇已有的信息，思考其深层次的逻辑，举一反三的实践或思考总结，并能达到一定效果</strong>，则算是深度的掌握。</li>\n</ul>\n<p>我们每天会浏览五花八门的信息，会folloe各种博客阅读新的思想。多数时候，我们以为我们已经了解其中的相关内容，其实我们仅限于“知道“。我们没有能够梳理其中的逻辑，也更无可能无法复述其中的逻辑。<strong>但是没有关系，因为我们的时间有限，不可能对大多数信息都能完整了解。</strong> 对于我们需要去了解的领域，则需要做到”广度式“的了解。比如很多人打王者荣耀，有的人只是消磨时间，有的人则会去了解每个英雄的连招、出装、阵容搭配等等。前者算不得广度，即不能在相亲介绍中的兴趣爱好栏写打王者荣耀，顶多只能写无聊时打打王者。做到深度掌握打王者打同学，则要摸清楚某个英雄的各种细节，在各种场景中如何操作。</p>\n<p>当然，具体要掌握到什么程度，取决于自己。比如我，就只是无聊时打打王者。</p>\n<h3 id=\"如何达到广度与深度\"><a href=\"#如何达到广度与深度\" class=\"headerlink\" title=\"如何达到广度与深度\"></a>如何达到广度与深度</h3><p>我曾经咨询过一位架构师，聊“如何覆盖技术的广度与深度”。在我的工作内容中，甚少会接触大数据工程，也没有直接接触AI项目（两大当前热门“泡沫”领域），我如何让我的技术覆盖到那里呢。我收到的回答是：“当你需要的时候，你自然会去学习去了解。”</p>\n<p>需要的时候，是一个很有趣的描述。什么是需要的时候，想“知道”一下，方便吹牛的时候扯扯专业名词；想“了解”一下，虽然用不到但是可以学一学原理；想“挖掘”一下，在某个项目中应用。还有其他的各种情况，都会成为需要的时候。</p>\n<p>在当前的互联网时代，要达到知识掌握的广度，其实不难。要了解一个领域的知识，有各种各样的搜索引擎和问答社区，可以找到资料。无论是否正确，逻辑总能在一定程度上自洽。要找到不自洽的点，当然需要更深入的学习理解了。如同狼人杀发言，论述粗看一定有道理，至于是不是真的合理，就需要高级玩家才能分辨出来。</p>\n<h3 id=\"有计划的拓展广度和深度\"><a href=\"#有计划的拓展广度和深度\" class=\"headerlink\" title=\"有计划的拓展广度和深度\"></a>有计划的拓展广度和深度</h3><p>虎年马上要到来，也是2022年的一月份，很多人都会给自己做计划，也有很多人没有什么特别的计划。计划的执行可能也都不一样。我十分建议，能够为自己的知识的广度与深度的拓展做足计划，且最好是有长时与短时计划。也许有的人不知道未来三五年自己会做什么，但是大家多少都有一个方向，或者有些兴趣点。</p>\n<p>有计划的去拓展和达成，可以让自己持续的达到某些里程碑，从而持续对自己形成正向激励。 </p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckz1fzx8o0001clht2yij2e9i","tag_id":"ckz1g0k2x0003clht41q1g5px","_id":"ckz1g9ii9000bclht1nbkaeri"}],"Tag":[{"name":"agile","_id":"ckz1g0k2x0003clht41q1g5px"}]}}